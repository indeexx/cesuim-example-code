(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-vendors~1bb6302b"],{2039:function(t,e,a){"use strict";var i=a("dde0"),n=a("8d54"),o=a("ae9b"),r=a("1a5d"),s=a("c937"),c=a("e2a6"),u=a("e107"),l=a("b8b5");function d(t,e,a){if(0===t)return e*a;const i=t*t,n=i*i,o=n*i,r=o*i,s=r*i,c=s*i,u=a,l=Math.sin(2*u),d=Math.sin(4*u),h=Math.sin(6*u),m=Math.sin(8*u),f=Math.sin(10*u),p=Math.sin(12*u);return e*((1-i/4-3*n/64-5*o/256-175*r/16384-441*s/65536-4851*c/1048576)*u-(3*i/8+3*n/32+45*o/1024+105*r/4096+2205*s/131072+6237*c/524288)*l+(15*n/256+45*o/1024+525*r/16384+1575*s/65536+155925*c/8388608)*d-(35*o/3072+175*r/12288+3675*s/262144+13475*c/1048576)*h+(315*r/131072+2205*s/524288+43659*c/8388608)*m-(693*s/1310720+6237*c/5242880)*f+1001*c/8388608*p)}function h(t,e,a){const i=t/a;if(0===e)return i;const n=i*i,o=n*i,r=o*i,s=e,c=s*s,u=c*c,l=u*c,d=l*c,h=d*c,m=h*c,f=Math.sin(2*i),p=Math.cos(2*i),_=Math.sin(4*i),g=Math.cos(4*i),b=Math.sin(6*i),O=Math.cos(6*i),y=Math.sin(8*i),A=Math.cos(8*i),x=Math.sin(10*i),w=Math.cos(10*i),P=Math.sin(12*i);return i+i*c/4+7*i*u/64+15*i*l/256+579*i*d/16384+1515*i*h/65536+16837*i*m/1048576+(3*i*u/16+45*i*l/256-i*(32*n-561)*d/4096-i*(232*n-1677)*h/16384+i*(399985-90560*n+512*r)*m/5242880)*p+(21*i*l/256+483*i*d/4096-i*(224*n-1969)*h/16384-i*(33152*n-112599)*m/1048576)*g+(151*i*d/4096+4681*i*h/65536+1479*i*m/16384-453*o*m/32768)*O+(1097*i*h/65536+42783*i*m/1048576)*A+8011*i*m/1048576*w+(3*c/8+3*u/16+213*l/2048-3*n*l/64+255*d/4096-33*n*d/512+20861*h/524288-33*n*h/512+r*h/1024+28273*m/1048576-471*n*m/8192+9*r*m/4096)*f+(21*u/256+21*l/256+533*d/8192-21*n*d/512+197*h/4096-315*n*h/4096+584039*m/16777216-12517*n*m/131072+7*r*m/2048)*_+(151*l/6144+151*d/4096+5019*h/131072-453*n*h/16384+26965*m/786432-8607*n*m/131072)*b+(1097*d/131072+1097*h/65536+225797*m/10485760-1097*n*m/65536)*y+(8011*h/2621440+8011*m/1048576)*x+293393*m/251658240*P}function m(t,e){if(0===t)return Math.log(Math.tan(.5*(l["a"].PI_OVER_TWO+e)));const a=t*Math.sin(e);return Math.log(Math.tan(.5*(l["a"].PI_OVER_TWO+e)))-t/2*Math.log((1+a)/(1-a))}function f(t,e,a,i,n){const o=m(t._ellipticity,a),r=m(t._ellipticity,n);return Math.atan2(l["a"].negativePiToPi(i-e),r-o)}function p(t,e,a,i,n,o,r){const s=t._heading,c=o-i;let u=0;if(l["a"].equalsEpsilon(Math.abs(s),l["a"].PI_OVER_TWO,l["a"].EPSILON8))if(e===a)u=e*Math.cos(n)*l["a"].negativePiToPi(c);else{const a=Math.sin(n);u=e*Math.cos(n)*l["a"].negativePiToPi(c)/Math.sqrt(1-t._ellipticitySquared*a*a)}else{const a=d(t._ellipticity,e,n),i=d(t._ellipticity,e,r);u=(i-a)/Math.cos(s)}return Math.abs(u)}const _=new i["a"],g=new i["a"];function b(t,e,a,r){const s=i["a"].normalize(r.cartographicToCartesian(e,g),_),c=i["a"].normalize(r.cartographicToCartesian(a,g),g);o["a"].typeOf.number.greaterThanOrEquals("value",Math.abs(Math.abs(i["a"].angleBetween(s,c))-Math.PI),.0125);const u=r.maximumRadius,l=r.minimumRadius,d=u*u,h=l*l;t._ellipticitySquared=(d-h)/d,t._ellipticity=Math.sqrt(t._ellipticitySquared),t._start=n["a"].clone(e,t._start),t._start.height=0,t._end=n["a"].clone(a,t._end),t._end.height=0,t._heading=f(t,e.longitude,e.latitude,a.longitude,a.latitude),t._distance=p(t,r.maximumRadius,r.minimumRadius,e.longitude,e.latitude,a.longitude,a.latitude)}function O(t,e,a,i,o,r){if(0===a)return n["a"].clone(t,r);const c=o*o;let u,f,p;if(Math.abs(l["a"].PI_OVER_TWO-Math.abs(e))>l["a"].EPSILON8){const n=d(o,i,t.latitude),r=a*Math.cos(e),s=n+r;f=h(s,o,i);const c=m(o,t.latitude),_=m(o,f);p=Math.tan(e)*(_-c),u=l["a"].negativePiToPi(t.longitude+p)}else{let n;if(f=t.latitude,0===o)n=i*Math.cos(t.latitude);else{const e=Math.sin(t.latitude);n=i*Math.cos(t.latitude)/Math.sqrt(1-c*e*e)}p=a/n,u=e>0?l["a"].negativePiToPi(t.longitude+p):l["a"].negativePiToPi(t.longitude-p)}return Object(s["a"])(r)?(r.longitude=u,r.latitude=f,r.height=0,r):new n["a"](u,f,0)}function y(t,e,a){const i=Object(r["a"])(a,u["a"].WGS84);this._ellipsoid=i,this._start=new n["a"],this._end=new n["a"],this._heading=void 0,this._distance=void 0,this._ellipticity=void 0,this._ellipticitySquared=void 0,Object(s["a"])(t)&&Object(s["a"])(e)&&b(this,t,e,i)}Object.defineProperties(y.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return o["a"].defined("distance",this._distance),this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},heading:{get:function(){return o["a"].defined("distance",this._distance),this._heading}}}),y.fromStartHeadingDistance=function(t,e,a,i,n){o["a"].defined("start",t),o["a"].defined("heading",e),o["a"].defined("distance",a),o["a"].typeOf.number.greaterThan("distance",a,0);const c=Object(r["a"])(i,u["a"].WGS84),d=c.maximumRadius,h=c.minimumRadius,m=d*d,f=h*h,p=Math.sqrt((m-f)/m);e=l["a"].negativePiToPi(e);const _=O(t,e,a,c.maximumRadius,p);return!Object(s["a"])(n)||Object(s["a"])(i)&&!i.equals(n.ellipsoid)?new y(t,_,c):(n.setEndPoints(t,_),n)},y.prototype.setEndPoints=function(t,e){o["a"].defined("start",t),o["a"].defined("end",e),b(this,t,e,this._ellipsoid)},y.prototype.interpolateUsingFraction=function(t,e){return this.interpolateUsingSurfaceDistance(t*this._distance,e)},y.prototype.interpolateUsingSurfaceDistance=function(t,e){if(o["a"].typeOf.number("distance",t),!Object(s["a"])(this._distance)||0===this._distance)throw new c["a"]("EllipsoidRhumbLine must have distinct start and end set.");return O(this._start,this._heading,t,this._ellipsoid.maximumRadius,this._ellipticity,e)},y.prototype.findIntersectionWithLongitude=function(t,e){if(o["a"].typeOf.number("intersectionLongitude",t),!Object(s["a"])(this._distance)||0===this._distance)throw new c["a"]("EllipsoidRhumbLine must have distinct start and end set.");const a=this._ellipticity,i=this._heading,r=Math.abs(i),u=this._start;if(t=l["a"].negativePiToPi(t),l["a"].equalsEpsilon(Math.abs(t),Math.PI,l["a"].EPSILON14)&&(t=l["a"].sign(u.longitude)*Math.PI),Object(s["a"])(e)||(e=new n["a"]),Math.abs(l["a"].PI_OVER_TWO-r)<=l["a"].EPSILON8)return e.longitude=t,e.latitude=u.latitude,e.height=0,e;if(l["a"].equalsEpsilon(Math.abs(l["a"].PI_OVER_TWO-r),l["a"].PI_OVER_TWO,l["a"].EPSILON8)){if(l["a"].equalsEpsilon(t,u.longitude,l["a"].EPSILON12))return;return e.longitude=t,e.latitude=l["a"].PI_OVER_TWO*l["a"].sign(l["a"].PI_OVER_TWO-i),e.height=0,e}const d=u.latitude,h=a*Math.sin(d),m=Math.tan(.5*(l["a"].PI_OVER_TWO+d))*Math.exp((t-u.longitude)/Math.tan(i)),f=(1+h)/(1-h);let p,_=u.latitude;do{p=_;const t=a*Math.sin(p),e=(1+t)/(1-t);_=2*Math.atan(m*Math.pow(e/f,a/2))-l["a"].PI_OVER_TWO}while(!l["a"].equalsEpsilon(_,p,l["a"].EPSILON12));return e.longitude=t,e.latitude=_,e.height=0,e},y.prototype.findIntersectionWithLatitude=function(t,e){if(o["a"].typeOf.number("intersectionLatitude",t),!Object(s["a"])(this._distance)||0===this._distance)throw new c["a"]("EllipsoidRhumbLine must have distinct start and end set.");const a=this._ellipticity,i=this._heading,r=this._start;if(l["a"].equalsEpsilon(Math.abs(i),l["a"].PI_OVER_TWO,l["a"].EPSILON8))return;const u=m(a,r.latitude),d=m(a,t),h=Math.tan(i)*(d-u),f=l["a"].negativePiToPi(r.longitude+h);return Object(s["a"])(e)?(e.longitude=f,e.latitude=t,e.height=0,e):new n["a"](f,t,0)},e["a"]=y},2459:function(t,e,a){"use strict";var i=a("9dc9"),n=a("8656"),o=a("85b2"),r=a("dde0"),s=a("cbf0"),c=a("1a5d"),u=a("c937"),l=a("e2a6"),d=a("e107"),h=a("5a72"),m=a("f3a4"),f=a("0c02"),p=a("e148"),_=a("2642"),g=a("b8b5"),b=a("82ba"),O=a("514d");const y=new r["a"],A=new r["a"],x=new r["a"],w=new r["a"],P=new r["a"],M=new r["a"](1,1,1),T=Math.cos,E=Math.sin;function j(t){t=Object(c["a"])(t,c["a"].EMPTY_OBJECT);const e=Object(c["a"])(t.radii,M),a=Object(c["a"])(t.innerRadii,e),i=Object(c["a"])(t.minimumClock,0),n=Object(c["a"])(t.maximumClock,g["a"].TWO_PI),o=Object(c["a"])(t.minimumCone,0),s=Object(c["a"])(t.maximumCone,g["a"].PI),u=Math.round(Object(c["a"])(t.stackPartitions,64)),d=Math.round(Object(c["a"])(t.slicePartitions,64)),h=Object(c["a"])(t.vertexFormat,O["a"].DEFAULT);if(d<3)throw new l["a"]("options.slicePartitions cannot be less than three.");if(u<3)throw new l["a"]("options.stackPartitions cannot be less than three.");this._radii=r["a"].clone(e),this._innerRadii=r["a"].clone(a),this._minimumClock=i,this._maximumClock=n,this._minimumCone=o,this._maximumCone=s,this._stackPartitions=u,this._slicePartitions=d,this._vertexFormat=O["a"].clone(h),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}j.packedLength=2*r["a"].packedLength+O["a"].packedLength+7,j.pack=function(t,e,a){if(!Object(u["a"])(t))throw new l["a"]("value is required");if(!Object(u["a"])(e))throw new l["a"]("array is required");return a=Object(c["a"])(a,0),r["a"].pack(t._radii,e,a),a+=r["a"].packedLength,r["a"].pack(t._innerRadii,e,a),a+=r["a"].packedLength,O["a"].pack(t._vertexFormat,e,a),a+=O["a"].packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=Object(c["a"])(t._offsetAttribute,-1),e};const S=new r["a"],I=new r["a"],v=new O["a"],N={radii:S,innerRadii:I,vertexFormat:v,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let C;j.unpack=function(t,e,a){if(!Object(u["a"])(t))throw new l["a"]("array is required");e=Object(c["a"])(e,0);const i=r["a"].unpack(t,e,S);e+=r["a"].packedLength;const n=r["a"].unpack(t,e,I);e+=r["a"].packedLength;const o=O["a"].unpack(t,e,v);e+=O["a"].packedLength;const s=t[e++],d=t[e++],h=t[e++],m=t[e++],f=t[e++],p=t[e++],_=t[e];return Object(u["a"])(a)?(a._radii=r["a"].clone(i,a._radii),a._innerRadii=r["a"].clone(n,a._innerRadii),a._vertexFormat=O["a"].clone(o,a._vertexFormat),a._minimumClock=s,a._maximumClock=d,a._minimumCone=h,a._maximumCone=m,a._stackPartitions=f,a._slicePartitions=p,a._offsetAttribute=-1===_?void 0:_,a):(N.minimumClock=s,N.maximumClock=d,N.minimumCone=h,N.maximumCone=m,N.stackPartitions=f,N.slicePartitions=p,N.offsetAttribute=-1===_?void 0:_,new j(N))},j.createGeometry=function(t){const e=t._radii;if(e.x<=0||e.y<=0||e.z<=0)return;const a=t._innerRadii;if(a.x<=0||a.y<=0||a.z<=0)return;const c=t._minimumClock,l=t._maximumClock,O=t._minimumCone,M=t._maximumCone,j=t._vertexFormat;let S,I,v=t._slicePartitions+1,N=t._stackPartitions+1;v=Math.round(v*Math.abs(l-c)/g["a"].TWO_PI),N=Math.round(N*Math.abs(M-O)/g["a"].PI),v<2&&(v=2),N<2&&(N=2);let C=0;const R=[O],k=[c];for(S=0;S<N;S++)R.push(O+S*(M-O)/(N-1));for(R.push(M),I=0;I<v;I++)k.push(c+I*(l-c)/(v-1));k.push(l);const L=R.length,z=k.length;let q=0,U=1;const F=a.x!==e.x||a.y!==e.y||a.z!==e.z;let D=!1,V=!1,B=!1;F&&(U=2,O>0&&(D=!0,q+=v-1),M<Math.PI&&(V=!0,q+=v-1),(l-c)%g["a"].TWO_PI?(B=!0,q+=2*(N-1)+1):q+=1);const G=z*L*U,H=new Float64Array(3*G),W=Object(i["a"])(new Array(G),!1),Y=Object(i["a"])(new Array(G),!1),Q=v*N*U,Z=6*(Q+q+1-(v+N)*U),J=_["a"].createTypedArray(Q,Z),X=j.normal?new Float32Array(3*G):void 0,K=j.tangent?new Float32Array(3*G):void 0,$=j.bitangent?new Float32Array(3*G):void 0,tt=j.st?new Float32Array(2*G):void 0,et=new Array(L),at=new Array(L);for(S=0;S<L;S++)et[S]=E(R[S]),at[S]=T(R[S]);const it=new Array(z),nt=new Array(z);for(I=0;I<z;I++)nt[I]=T(k[I]),it[I]=E(k[I]);for(S=0;S<L;S++)for(I=0;I<z;I++)H[C++]=e.x*et[S]*nt[I],H[C++]=e.y*et[S]*it[I],H[C++]=e.z*at[S];let ot,rt,st,ct,ut=G/2;if(F)for(S=0;S<L;S++)for(I=0;I<z;I++)H[C++]=a.x*et[S]*nt[I],H[C++]=a.y*et[S]*it[I],H[C++]=a.z*at[S],W[ut]=!0,S>0&&S!==L-1&&0!==I&&I!==z-1&&(Y[ut]=!0),ut++;for(C=0,S=1;S<L-2;S++)for(ot=S*z,rt=(S+1)*z,I=1;I<z-2;I++)J[C++]=rt+I,J[C++]=rt+I+1,J[C++]=ot+I+1,J[C++]=rt+I,J[C++]=ot+I+1,J[C++]=ot+I;if(F){const t=L*z;for(S=1;S<L-2;S++)for(ot=t+S*z,rt=t+(S+1)*z,I=1;I<z-2;I++)J[C++]=rt+I,J[C++]=ot+I,J[C++]=ot+I+1,J[C++]=rt+I,J[C++]=ot+I+1,J[C++]=rt+I+1}if(F){if(D)for(ct=L*z,S=1;S<z-2;S++)J[C++]=S,J[C++]=S+1,J[C++]=ct+S+1,J[C++]=S,J[C++]=ct+S+1,J[C++]=ct+S;if(V)for(st=L*z-z,ct=L*z*U-z,S=1;S<z-2;S++)J[C++]=st+S+1,J[C++]=st+S,J[C++]=ct+S,J[C++]=st+S+1,J[C++]=ct+S,J[C++]=ct+S+1}if(B){for(S=1;S<L-2;S++)ct=z*L+z*S,st=z*S,J[C++]=ct,J[C++]=st+z,J[C++]=st,J[C++]=ct,J[C++]=ct+z,J[C++]=st+z;for(S=1;S<L-2;S++)ct=z*L+z*(S+1)-1,st=z*(S+1)-1,J[C++]=st+z,J[C++]=ct,J[C++]=st,J[C++]=st+z,J[C++]=ct+z,J[C++]=ct}const lt=new f["a"];j.position&&(lt.position=new m["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:H}));let dt=0,ht=0,mt=0,ft=0;const pt=G/2;let _t;const gt=d["a"].fromCartesian3(e),bt=d["a"].fromCartesian3(a);if(j.st||j.normal||j.tangent||j.bitangent){for(S=0;S<G;S++){_t=W[S]?bt:gt;const t=r["a"].fromArray(H,3*S,y),e=_t.geodeticSurfaceNormal(t,A);if(Y[S]&&r["a"].negate(e,e),j.st){const t=o["a"].negate(e,P);tt[dt++]=Math.atan2(t.y,t.x)/g["a"].TWO_PI+.5,tt[dt++]=Math.asin(e.z)/Math.PI+.5}if(j.normal&&(X[ht++]=e.x,X[ht++]=e.y,X[ht++]=e.z),j.tangent||j.bitangent){const t=x;let a,i=0;if(W[S]&&(i=pt),a=!D&&S>=i&&S<i+2*z?r["a"].UNIT_X:r["a"].UNIT_Z,r["a"].cross(a,e,t),r["a"].normalize(t,t),j.tangent&&(K[mt++]=t.x,K[mt++]=t.y,K[mt++]=t.z),j.bitangent){const a=r["a"].cross(e,t,w);r["a"].normalize(a,a),$[ft++]=a.x,$[ft++]=a.y,$[ft++]=a.z}}}j.st&&(lt.st=new m["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:2,values:tt})),j.normal&&(lt.normal=new m["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:X})),j.tangent&&(lt.tangent=new m["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:K})),j.bitangent&&(lt.bitangent=new m["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:$}))}if(Object(u["a"])(t._offsetAttribute)){const e=H.length,a=new Uint8Array(e/3),n=t._offsetAttribute===p["a"].NONE?0:1;Object(i["a"])(a,n),lt.applyOffset=new m["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new h["a"]({attributes:lt,indices:J,primitiveType:b["a"].TRIANGLES,boundingSphere:n["a"].fromEllipsoid(gt),offsetAttribute:t._offsetAttribute})},j.getUnitEllipsoid=function(){return Object(u["a"])(C)||(C=j.createGeometry(new j({radii:new r["a"](1,1,1),vertexFormat:O["a"].POSITION_ONLY}))),C},e["a"]=j},4754:function(t,e,a){"use strict";var i=a("9dc9"),n=a("8656"),o=a("85b2"),r=a("dde0"),s=a("8d54"),c=a("ae9b"),u=a("cbf0"),l=a("1a5d"),d=a("c937"),h=a("e2a6"),m=a("a295"),f=a("e107"),p=a("1f02"),_=a("5a72"),g=a("f3a4"),b=a("0c02"),O=a("e8ff"),y=a("e148"),A=a("f6fe"),x=a("2642"),w=a("b8b5"),P=a("d767"),M=a("82ba"),T=a("1b9c"),E=a("4a63"),j=a("514d");const S=new r["a"],I=new r["a"],v=new r["a"],N=new r["a"],C=new o["a"],R=new P["a"],k=new P["a"],L=new T["a"],z=new r["a"],q=new r["a"],U=new r["a"],F=new s["a"],D=new r["a"],V=new o["a"],B=new o["a"];function G(t,e,a){const n=e.vertexFormat,s=e.center,c=e.semiMajorAxis,l=e.semiMinorAxis,h=e.ellipsoid,f=e.stRotation,_=a?t.length/3*2:t.length/3,O=e.shadowVolume,A=n.st?new Float32Array(2*_):void 0,x=n.normal?new Float32Array(3*_):void 0,w=n.tangent?new Float32Array(3*_):void 0,M=n.bitangent?new Float32Array(3*_):void 0,E=O?new Float32Array(3*_):void 0;let j=0,N=z,G=q,H=U;const W=new p["a"](h),Y=W.project(h.cartesianToCartographic(s,F),D),Q=h.scaleToGeodeticSurface(s,S);h.geodeticSurfaceNormal(Q,Q);let Z=R,J=k;if(0!==f){let t=T["a"].fromAxisAngle(Q,f,L);Z=P["a"].fromQuaternion(t,Z),t=T["a"].fromAxisAngle(Q,-f,L),J=P["a"].fromQuaternion(t,J)}else Z=P["a"].clone(P["a"].IDENTITY,Z),J=P["a"].clone(P["a"].IDENTITY,J);const X=o["a"].fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,V),K=o["a"].fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,B);let $=t.length;const tt=a?$:0,et=tt/3*2;for(let i=0;i<$;i+=3){const e=i+1,o=i+2,s=r["a"].fromArray(t,i,S);if(n.st){const t=P["a"].multiplyByVector(Z,s,I),e=W.project(h.cartesianToCartographic(t,F),v);r["a"].subtract(e,Y,e),C.x=(e.x+c)/(2*c),C.y=(e.y+l)/(2*l),X.x=Math.min(C.x,X.x),X.y=Math.min(C.y,X.y),K.x=Math.max(C.x,K.x),K.y=Math.max(C.y,K.y),a&&(A[j+et]=C.x,A[j+1+et]=C.y),A[j++]=C.x,A[j++]=C.y}(n.normal||n.tangent||n.bitangent||O)&&(N=h.geodeticSurfaceNormal(s,N),O&&(E[i+tt]=-N.x,E[e+tt]=-N.y,E[o+tt]=-N.z),(n.normal||n.tangent||n.bitangent)&&((n.tangent||n.bitangent)&&(G=r["a"].normalize(r["a"].cross(r["a"].UNIT_Z,N,G),G),P["a"].multiplyByVector(J,G,G)),n.normal&&(x[i]=N.x,x[e]=N.y,x[o]=N.z,a&&(x[i+tt]=-N.x,x[e+tt]=-N.y,x[o+tt]=-N.z)),n.tangent&&(w[i]=G.x,w[e]=G.y,w[o]=G.z,a&&(w[i+tt]=-G.x,w[e+tt]=-G.y,w[o+tt]=-G.z)),n.bitangent&&(H=r["a"].normalize(r["a"].cross(N,G,H),H),M[i]=H.x,M[e]=H.y,M[o]=H.z,a&&(M[i+tt]=H.x,M[e+tt]=H.y,M[o+tt]=H.z))))}if(n.st){$=A.length;for(let t=0;t<$;t+=2)A[t]=(A[t]-X.x)/(K.x-X.x),A[t+1]=(A[t+1]-X.y)/(K.y-X.y)}const at=new b["a"];if(n.position){const i=m["a"].raisePositionsToHeight(t,e,a);at.position=new g["a"]({componentDatatype:u["a"].DOUBLE,componentsPerAttribute:3,values:i})}if(n.st&&(at.st=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:2,values:A})),n.normal&&(at.normal=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:x})),n.tangent&&(at.tangent=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:w})),n.bitangent&&(at.bitangent=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:M})),O&&(at.extrudeDirection=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:E})),a&&Object(d["a"])(e.offsetAttribute)){let t=new Uint8Array(_);if(e.offsetAttribute===y["a"].TOP)t=Object(i["a"])(t,1,0,_/2);else{const a=e.offsetAttribute===y["a"].NONE?0:1;t=Object(i["a"])(t,a)}at.applyOffset=new g["a"]({componentDatatype:u["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return at}function H(t){const e=new Array(t*(t+1)*12-6);let a,i,n,o,r,s=0;for(a=0,n=1,o=0;o<3;o++)e[s++]=n++,e[s++]=a,e[s++]=n;for(o=2;o<t+1;++o){for(n=o*(o+1)-1,a=(o-1)*o-1,e[s++]=n++,e[s++]=a,e[s++]=n,i=2*o,r=0;r<i-1;++r)e[s++]=n,e[s++]=a++,e[s++]=a,e[s++]=n++,e[s++]=a,e[s++]=n;e[s++]=n++,e[s++]=a,e[s++]=n}for(i=2*t,++n,++a,o=0;o<i-1;++o)e[s++]=n,e[s++]=a++,e[s++]=a,e[s++]=n++,e[s++]=a,e[s++]=n;for(e[s++]=n,e[s++]=a++,e[s++]=a,e[s++]=n++,e[s++]=a++,e[s++]=a,++a,o=t-1;o>1;--o){for(e[s++]=a++,e[s++]=a,e[s++]=n,i=2*o,r=0;r<i-1;++r)e[s++]=n,e[s++]=a++,e[s++]=a,e[s++]=n++,e[s++]=a,e[s++]=n;e[s++]=a++,e[s++]=a++,e[s++]=n++}for(o=0;o<3;o++)e[s++]=a++,e[s++]=a,e[s++]=n;return e}let W=new r["a"];function Y(t){const e=t.center;W=r["a"].multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(e,W),t.height,W),W=r["a"].add(e,W,W);const a=new n["a"](W,t.semiMajorAxis),i=m["a"].computeEllipsePositions(t,!0,!1),o=i.positions,s=i.numPts,c=G(o,t,!1);let u=H(s);return u=x["a"].createTypedArray(o.length/3,u),{boundingSphere:a,attributes:c,indices:u}}function Q(t,e){const a=e.vertexFormat,n=e.center,s=e.semiMajorAxis,c=e.semiMinorAxis,l=e.ellipsoid,h=e.height,m=e.extrudedHeight,f=e.stRotation,_=t.length/3*2,O=new Float64Array(3*_),A=a.st?new Float32Array(2*_):void 0,x=a.normal?new Float32Array(3*_):void 0,w=a.tangent?new Float32Array(3*_):void 0,M=a.bitangent?new Float32Array(3*_):void 0,E=e.shadowVolume,j=E?new Float32Array(3*_):void 0;let k=0,G=z,H=q,W=U;const Y=new p["a"](l),Q=Y.project(l.cartesianToCartographic(n,F),D),Z=l.scaleToGeodeticSurface(n,S);l.geodeticSurfaceNormal(Z,Z);const J=T["a"].fromAxisAngle(Z,f,L),X=P["a"].fromQuaternion(J,R),K=o["a"].fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,V),$=o["a"].fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,B);let tt=t.length;const et=tt/3*2;for(let i=0;i<tt;i+=3){const e=i+1,n=i+2;let o,u=r["a"].fromArray(t,i,S);if(a.st){const t=P["a"].multiplyByVector(X,u,I),e=Y.project(l.cartesianToCartographic(t,F),v);r["a"].subtract(e,Q,e),C.x=(e.x+s)/(2*s),C.y=(e.y+c)/(2*c),K.x=Math.min(C.x,K.x),K.y=Math.min(C.y,K.y),$.x=Math.max(C.x,$.x),$.y=Math.max(C.y,$.y),A[k+et]=C.x,A[k+1+et]=C.y,A[k++]=C.x,A[k++]=C.y}u=l.scaleToGeodeticSurface(u,u),o=r["a"].clone(u,I),G=l.geodeticSurfaceNormal(u,G),E&&(j[i+tt]=-G.x,j[e+tt]=-G.y,j[n+tt]=-G.z);let d=r["a"].multiplyByScalar(G,h,N);if(u=r["a"].add(u,d,u),d=r["a"].multiplyByScalar(G,m,d),o=r["a"].add(o,d,o),a.position&&(O[i+tt]=o.x,O[e+tt]=o.y,O[n+tt]=o.z,O[i]=u.x,O[e]=u.y,O[n]=u.z),a.normal||a.tangent||a.bitangent){W=r["a"].clone(G,W);const s=r["a"].fromArray(t,(i+3)%tt,N);r["a"].subtract(s,u,s);const c=r["a"].subtract(o,u,v);G=r["a"].normalize(r["a"].cross(c,s,G),G),a.normal&&(x[i]=G.x,x[e]=G.y,x[n]=G.z,x[i+tt]=G.x,x[e+tt]=G.y,x[n+tt]=G.z),a.tangent&&(H=r["a"].normalize(r["a"].cross(W,G,H),H),w[i]=H.x,w[e]=H.y,w[n]=H.z,w[i+tt]=H.x,w[i+1+tt]=H.y,w[i+2+tt]=H.z),a.bitangent&&(M[i]=W.x,M[e]=W.y,M[n]=W.z,M[i+tt]=W.x,M[e+tt]=W.y,M[n+tt]=W.z)}}if(a.st){tt=A.length;for(let t=0;t<tt;t+=2)A[t]=(A[t]-K.x)/($.x-K.x),A[t+1]=(A[t+1]-K.y)/($.y-K.y)}const at=new b["a"];if(a.position&&(at.position=new g["a"]({componentDatatype:u["a"].DOUBLE,componentsPerAttribute:3,values:O})),a.st&&(at.st=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:2,values:A})),a.normal&&(at.normal=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:x})),a.tangent&&(at.tangent=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:w})),a.bitangent&&(at.bitangent=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:M})),E&&(at.extrudeDirection=new g["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:j})),Object(d["a"])(e.offsetAttribute)){let t=new Uint8Array(_);if(e.offsetAttribute===y["a"].TOP)t=Object(i["a"])(t,1,0,_/2);else{const a=e.offsetAttribute===y["a"].NONE?0:1;t=Object(i["a"])(t,a)}at.applyOffset=new g["a"]({componentDatatype:u["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return at}function Z(t){const e=t.length/3,a=x["a"].createTypedArray(e,6*e);let i=0;for(let n=0;n<e;n++){const t=n,o=n+e,r=(t+1)%e,s=r+e;a[i++]=t,a[i++]=o,a[i++]=r,a[i++]=r,a[i++]=o,a[i++]=s}return a}const J=new n["a"],X=new n["a"];function K(t){const e=t.center,a=t.ellipsoid,i=t.semiMajorAxis;let o=r["a"].multiplyByScalar(a.geodeticSurfaceNormal(e,S),t.height,S);J.center=r["a"].add(e,o,J.center),J.radius=i,o=r["a"].multiplyByScalar(a.geodeticSurfaceNormal(e,o),t.extrudedHeight,o),X.center=r["a"].add(e,o,X.center),X.radius=i;const s=m["a"].computeEllipsePositions(t,!0,!0),c=s.positions,u=s.numPts,l=s.outerPositions,d=n["a"].union(J,X),h=G(c,t,!0);let f=H(u);const p=f.length;f.length=2*p;const g=c.length/3;for(let n=0;n<p;n+=3)f[n+p]=f[n+2]+g,f[n+1+p]=f[n+1]+g,f[n+2+p]=f[n]+g;const b=x["a"].createTypedArray(2*g/3,f),y=new _["a"]({attributes:h,indices:b,primitiveType:M["a"].TRIANGLES}),w=Q(l,t);f=Z(l);const P=x["a"].createTypedArray(2*l.length/3,f),T=new _["a"]({attributes:w,indices:P,primitiveType:M["a"].TRIANGLES}),E=A["a"].combineInstances([new O["a"]({geometry:y}),new O["a"]({geometry:T})]);return{boundingSphere:d,attributes:E[0].attributes,indices:E[0].indices}}function $(t,e,a,i,n,o,s){const c=m["a"].computeEllipsePositions({center:t,semiMajorAxis:e,semiMinorAxis:a,rotation:i,granularity:n},!1,!0),u=c.outerPositions,l=u.length/3,d=new Array(l);for(let m=0;m<l;++m)d[m]=r["a"].fromArray(u,3*m);const h=E["a"].fromCartesianArray(d,o,s);return h.width>w["a"].PI&&(h.north=h.north>0?w["a"].PI_OVER_TWO-w["a"].EPSILON7:h.north,h.south=h.south<0?w["a"].EPSILON7-w["a"].PI_OVER_TWO:h.south,h.east=w["a"].PI,h.west=-w["a"].PI),h}function tt(t){t=Object(l["a"])(t,l["a"].EMPTY_OBJECT);const e=t.center,a=Object(l["a"])(t.ellipsoid,f["a"].WGS84),i=t.semiMajorAxis,n=t.semiMinorAxis,o=Object(l["a"])(t.granularity,w["a"].RADIANS_PER_DEGREE),s=Object(l["a"])(t.vertexFormat,j["a"].DEFAULT);if(c["a"].defined("options.center",e),c["a"].typeOf.number("options.semiMajorAxis",i),c["a"].typeOf.number("options.semiMinorAxis",n),i<n)throw new h["a"]("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(o<=0)throw new h["a"]("granularity must be greater than zero.");const u=Object(l["a"])(t.height,0),d=Object(l["a"])(t.extrudedHeight,u);this._center=r["a"].clone(e),this._semiMajorAxis=i,this._semiMinorAxis=n,this._ellipsoid=f["a"].clone(a),this._rotation=Object(l["a"])(t.rotation,0),this._stRotation=Object(l["a"])(t.stRotation,0),this._height=Math.max(d,u),this._granularity=o,this._vertexFormat=j["a"].clone(s),this._extrudedHeight=Math.min(d,u),this._shadowVolume=Object(l["a"])(t.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}tt.packedLength=r["a"].packedLength+f["a"].packedLength+j["a"].packedLength+9,tt.pack=function(t,e,a){return c["a"].defined("value",t),c["a"].defined("array",e),a=Object(l["a"])(a,0),r["a"].pack(t._center,e,a),a+=r["a"].packedLength,f["a"].pack(t._ellipsoid,e,a),a+=f["a"].packedLength,j["a"].pack(t._vertexFormat,e,a),a+=j["a"].packedLength,e[a++]=t._semiMajorAxis,e[a++]=t._semiMinorAxis,e[a++]=t._rotation,e[a++]=t._stRotation,e[a++]=t._height,e[a++]=t._granularity,e[a++]=t._extrudedHeight,e[a++]=t._shadowVolume?1:0,e[a]=Object(l["a"])(t._offsetAttribute,-1),e};const et=new r["a"],at=new f["a"],it=new j["a"],nt={center:et,ellipsoid:at,vertexFormat:it,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};function ot(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const a=m["a"].computeEllipsePositions({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,rotation:t._rotation,granularity:t._granularity},!1,!0),i=a.outerPositions,n=i.length/3,o=new Array(n);for(let u=0;u<n;++u)o[u]=r["a"].fromArray(i,3*u);const s=t._ellipsoid,c=t.rectangle;return _["a"]._textureCoordinateRotationPoints(o,e,s,c)}tt.unpack=function(t,e,a){c["a"].defined("array",t),e=Object(l["a"])(e,0);const i=r["a"].unpack(t,e,et);e+=r["a"].packedLength;const n=f["a"].unpack(t,e,at);e+=f["a"].packedLength;const o=j["a"].unpack(t,e,it);e+=j["a"].packedLength;const s=t[e++],u=t[e++],h=t[e++],m=t[e++],p=t[e++],_=t[e++],g=t[e++],b=1===t[e++],O=t[e];return Object(d["a"])(a)?(a._center=r["a"].clone(i,a._center),a._ellipsoid=f["a"].clone(n,a._ellipsoid),a._vertexFormat=j["a"].clone(o,a._vertexFormat),a._semiMajorAxis=s,a._semiMinorAxis=u,a._rotation=h,a._stRotation=m,a._height=p,a._granularity=_,a._extrudedHeight=g,a._shadowVolume=b,a._offsetAttribute=-1===O?void 0:O,a):(nt.height=p,nt.extrudedHeight=g,nt.granularity=_,nt.stRotation=m,nt.rotation=h,nt.semiMajorAxis=s,nt.semiMinorAxis=u,nt.shadowVolume=b,nt.offsetAttribute=-1===O?void 0:O,new tt(nt))},tt.computeRectangle=function(t,e){t=Object(l["a"])(t,l["a"].EMPTY_OBJECT);const a=t.center,i=Object(l["a"])(t.ellipsoid,f["a"].WGS84),n=t.semiMajorAxis,o=t.semiMinorAxis,r=Object(l["a"])(t.granularity,w["a"].RADIANS_PER_DEGREE),s=Object(l["a"])(t.rotation,0);if(c["a"].defined("options.center",a),c["a"].typeOf.number("options.semiMajorAxis",n),c["a"].typeOf.number("options.semiMinorAxis",o),n<o)throw new h["a"]("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(r<=0)throw new h["a"]("granularity must be greater than zero.");return $(a,n,o,s,r,i,e)},tt.createGeometry=function(t){if(t._semiMajorAxis<=0||t._semiMinorAxis<=0)return;const e=t._height,a=t._extrudedHeight,n=!w["a"].equalsEpsilon(e,a,0,w["a"].EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const o={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:e,granularity:t._granularity,vertexFormat:t._vertexFormat,stRotation:t._stRotation};let r;if(n)o.extrudedHeight=a,o.shadowVolume=t._shadowVolume,o.offsetAttribute=t._offsetAttribute,r=K(o);else if(r=Y(o),Object(d["a"])(t._offsetAttribute)){const e=r.attributes.position.values.length,a=new Uint8Array(e/3),n=t._offsetAttribute===y["a"].NONE?0:1;Object(i["a"])(a,n),r.attributes.applyOffset=new g["a"]({componentDatatype:u["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new _["a"]({attributes:r.attributes,indices:r.indices,primitiveType:M["a"].TRIANGLES,boundingSphere:r.boundingSphere,offsetAttribute:t._offsetAttribute})},tt.createShadowVolume=function(t,e,a){const i=t._granularity,n=t._ellipsoid,o=e(i,n),r=a(i,n);return new tt({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:n,rotation:t._rotation,stRotation:t._stRotation,granularity:i,extrudedHeight:o,height:r,vertexFormat:j["a"].POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(tt.prototype,{rectangle:{get:function(){return Object(d["a"])(this._rectangle)||(this._rectangle=$(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return Object(d["a"])(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=ot(this)),this._textureCoordinateRotationPoints}}}),e["a"]=tt},"626a":function(t,e,a){"use strict";var i=a("1a5d"),n=a("c937"),o=a("e107"),r=a("f7b5"),s=a("2dd3"),c=a("b869"),u=a("5df2");function l(t){t=Object(i["a"])(t,i["a"].EMPTY_OBJECT),this._tilingScheme=t.tilingScheme,Object(n["a"])(this._tilingScheme)||(this._tilingScheme=new s["a"]({ellipsoid:Object(i["a"])(t.ellipsoid,o["a"].WGS84)})),this._levelZeroMaximumGeometricError=u["a"].getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid,64,this._tilingScheme.getNumberOfXTilesAtLevel(0)),this._errorEvent=new r["a"],this._readyPromise=Promise.resolve(!0)}Object.defineProperties(l.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){}},tilingScheme:{get:function(){return this._tilingScheme}},ready:{get:function(){return!0}},readyPromise:{get:function(){return this._readyPromise}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){}}}),l.prototype.requestTileGeometry=function(t,e,a,i){const n=16,o=16;return Promise.resolve(new c["a"]({buffer:new Uint8Array(n*o),width:n,height:o}))},l.prototype.getLevelMaximumGeometricError=function(t){return this._levelZeroMaximumGeometricError/(1<<t)},l.prototype.getTileDataAvailable=function(t,e,a){},l.prototype.loadTileDataAvailability=function(t,e,a){},e["a"]=l},"7e56":function(t,e,a){"use strict";var i=a("ad6a"),n=a("85b2"),o=a("dde0"),r=a("6b82"),s=a("ae9b"),c=a("1a5d"),u=a("c937"),l=a("e2a6"),d=a("e107"),h=a("7f05"),m=a("722e"),f=a("a7b2"),p=a("430c"),_=a("6f7c");const g=new r["a"];function b(t,e){if(s["a"].defined("origin",t),e=Object(c["a"])(e,d["a"].WGS84),t=e.scaleToGeodeticSurface(t),!Object(u["a"])(t))throw new l["a"]("origin must not be at the center of the ellipsoid.");const a=_["a"].eastNorthUpToFixedFrame(t,e);this._ellipsoid=e,this._origin=t,this._xAxis=o["a"].fromCartesian4(m["a"].getColumn(a,0,g)),this._yAxis=o["a"].fromCartesian4(m["a"].getColumn(a,1,g));const i=o["a"].fromCartesian4(m["a"].getColumn(a,2,g));this._plane=f["a"].fromPointNormal(t,i)}Object.defineProperties(b.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},origin:{get:function(){return this._origin}},plane:{get:function(){return this._plane}},xAxis:{get:function(){return this._xAxis}},yAxis:{get:function(){return this._yAxis}},zAxis:{get:function(){return this._plane.normal}}});const O=new i["a"];b.fromPoints=function(t,e){s["a"].defined("cartesians",t);const a=i["a"].fromPoints(t,O);return new b(a.center,e)};const y=new p["a"],A=new o["a"];b.prototype.projectPointOntoPlane=function(t,e){s["a"].defined("cartesian",t);const a=y;a.origin=t,o["a"].normalize(t,a.direction);let i=h["a"].rayPlane(a,this._plane,A);if(Object(u["a"])(i)||(o["a"].negate(a.direction,a.direction),i=h["a"].rayPlane(a,this._plane,A)),Object(u["a"])(i)){const t=o["a"].subtract(i,this._origin,i),a=o["a"].dot(this._xAxis,t),r=o["a"].dot(this._yAxis,t);return Object(u["a"])(e)?(e.x=a,e.y=r,e):new n["a"](a,r)}},b.prototype.projectPointsOntoPlane=function(t,e){s["a"].defined("cartesians",t),Object(u["a"])(e)||(e=[]);let a=0;const i=t.length;for(let n=0;n<i;n++){const i=this.projectPointOntoPlane(t[n],e[a]);Object(u["a"])(i)&&(e[a]=i,a++)}return e.length=a,e},b.prototype.projectPointToNearestOnPlane=function(t,e){s["a"].defined("cartesian",t),Object(u["a"])(e)||(e=new n["a"]);const a=y;a.origin=t,o["a"].clone(this._plane.normal,a.direction);let i=h["a"].rayPlane(a,this._plane,A);Object(u["a"])(i)||(o["a"].negate(a.direction,a.direction),i=h["a"].rayPlane(a,this._plane,A));const r=o["a"].subtract(i,this._origin,i),c=o["a"].dot(this._xAxis,r),l=o["a"].dot(this._yAxis,r);return e.x=c,e.y=l,e},b.prototype.projectPointsToNearestOnPlane=function(t,e){s["a"].defined("cartesians",t),Object(u["a"])(e)||(e=[]);const a=t.length;e.length=a;for(let i=0;i<a;i++)e[i]=this.projectPointToNearestOnPlane(t[i],e[i]);return e};const x=new o["a"];b.prototype.projectPointOntoEllipsoid=function(t,e){s["a"].defined("cartesian",t),Object(u["a"])(e)||(e=new o["a"]);const a=this._ellipsoid,i=this._origin,n=this._xAxis,r=this._yAxis,c=x;return o["a"].multiplyByScalar(n,t.x,c),e=o["a"].add(i,c,e),o["a"].multiplyByScalar(r,t.y,c),o["a"].add(e,c,e),a.scaleToGeocentricSurface(e,e),e},b.prototype.projectPointsOntoEllipsoid=function(t,e){s["a"].defined("cartesians",t);const a=t.length;Object(u["a"])(e)?e.length=a:e=new Array(a);for(let i=0;i<a;++i)e[i]=this.projectPointOntoEllipsoid(t[i],e[i]);return e},e["a"]=b},"7e67":function(t,e,a){"use strict";var i=a("97c9");const n={LINEAR_NONE:i["a"].Easing.Linear.None,QUADRATIC_IN:i["a"].Easing.Quadratic.In,QUADRATIC_OUT:i["a"].Easing.Quadratic.Out,QUADRATIC_IN_OUT:i["a"].Easing.Quadratic.InOut,CUBIC_IN:i["a"].Easing.Cubic.In,CUBIC_OUT:i["a"].Easing.Cubic.Out,CUBIC_IN_OUT:i["a"].Easing.Cubic.InOut,QUARTIC_IN:i["a"].Easing.Quartic.In,QUARTIC_OUT:i["a"].Easing.Quartic.Out,QUARTIC_IN_OUT:i["a"].Easing.Quartic.InOut,QUINTIC_IN:i["a"].Easing.Quintic.In,QUINTIC_OUT:i["a"].Easing.Quintic.Out,QUINTIC_IN_OUT:i["a"].Easing.Quintic.InOut,SINUSOIDAL_IN:i["a"].Easing.Sinusoidal.In,SINUSOIDAL_OUT:i["a"].Easing.Sinusoidal.Out,SINUSOIDAL_IN_OUT:i["a"].Easing.Sinusoidal.InOut,EXPONENTIAL_IN:i["a"].Easing.Exponential.In,EXPONENTIAL_OUT:i["a"].Easing.Exponential.Out,EXPONENTIAL_IN_OUT:i["a"].Easing.Exponential.InOut,CIRCULAR_IN:i["a"].Easing.Circular.In,CIRCULAR_OUT:i["a"].Easing.Circular.Out,CIRCULAR_IN_OUT:i["a"].Easing.Circular.InOut,ELASTIC_IN:i["a"].Easing.Elastic.In,ELASTIC_OUT:i["a"].Easing.Elastic.Out,ELASTIC_IN_OUT:i["a"].Easing.Elastic.InOut,BACK_IN:i["a"].Easing.Back.In,BACK_OUT:i["a"].Easing.Back.Out,BACK_IN_OUT:i["a"].Easing.Back.InOut,BOUNCE_IN:i["a"].Easing.Bounce.In,BOUNCE_OUT:i["a"].Easing.Bounce.Out,BOUNCE_IN_OUT:i["a"].Easing.Bounce.InOut};e["a"]=Object.freeze(n)},a295:function(t,e,a){"use strict";var i=a("dde0"),n=a("b8b5"),o=a("d767"),r=a("1b9c");const s={},c=new i["a"],u=new i["a"],l=new r["a"],d=new o["a"];function h(t,e,a,n,s,h,m,f,p,_){const g=t+e;i["a"].multiplyByScalar(n,Math.cos(g),c),i["a"].multiplyByScalar(a,Math.sin(g),u),i["a"].add(c,u,c);let b=Math.cos(t);b*=b;let O=Math.sin(t);O*=O;const y=h/Math.sqrt(m*b+s*O),A=y/f;return r["a"].fromAxisAngle(c,A,l),o["a"].fromQuaternion(l,d),o["a"].multiplyByVector(d,p,_),i["a"].normalize(_,_),i["a"].multiplyByScalar(_,f,_),_}const m=new i["a"],f=new i["a"],p=new i["a"],_=new i["a"];s.raisePositionsToHeight=function(t,e,a){const n=e.ellipsoid,o=e.height,r=e.extrudedHeight,s=a?t.length/3*2:t.length/3,c=new Float64Array(3*s),u=t.length,l=a?u:0;for(let d=0;d<u;d+=3){const e=d+1,s=d+2,u=i["a"].fromArray(t,d,m);n.scaleToGeodeticSurface(u,u);const h=i["a"].clone(u,f),g=n.geodeticSurfaceNormal(u,_),b=i["a"].multiplyByScalar(g,o,p);i["a"].add(u,b,u),a&&(i["a"].multiplyByScalar(g,r,b),i["a"].add(h,b,h),c[d+l]=h.x,c[e+l]=h.y,c[s+l]=h.z),c[d]=u.x,c[e]=u.y,c[s]=u.z}return c};const g=new i["a"],b=new i["a"],O=new i["a"];s.computeEllipsePositions=function(t,e,a){const o=t.semiMinorAxis,r=t.semiMajorAxis,s=t.rotation,c=t.center,u=8*t.granularity,l=o*o,d=r*r,_=r*o,y=i["a"].magnitude(c),A=i["a"].normalize(c,g);let x=i["a"].cross(i["a"].UNIT_Z,c,b);x=i["a"].normalize(x,x);const w=i["a"].cross(A,x,O);let P=1+Math.ceil(n["a"].PI_OVER_TWO/u);const M=n["a"].PI_OVER_TWO/(P-1);let T=n["a"].PI_OVER_TWO-P*M;T<0&&(P-=Math.ceil(Math.abs(T)/M));const E=P*(P+2)*2,j=e?new Array(3*E):void 0;let S=0,I=m,v=f;const N=4*P*3;let C=N-1,R=0;const k=a?new Array(N):void 0;let L,z,q,U,F;for(T=n["a"].PI_OVER_TWO,I=h(T,s,w,x,l,_,d,y,A,I),e&&(j[S++]=I.x,j[S++]=I.y,j[S++]=I.z),a&&(k[C--]=I.z,k[C--]=I.y,k[C--]=I.x),T=n["a"].PI_OVER_TWO-M,L=1;L<P+1;++L){if(I=h(T,s,w,x,l,_,d,y,A,I),v=h(Math.PI-T,s,w,x,l,_,d,y,A,v),e){for(j[S++]=I.x,j[S++]=I.y,j[S++]=I.z,q=2*L+2,z=1;z<q-1;++z)U=z/(q-1),F=i["a"].lerp(I,v,U,p),j[S++]=F.x,j[S++]=F.y,j[S++]=F.z;j[S++]=v.x,j[S++]=v.y,j[S++]=v.z}a&&(k[C--]=I.z,k[C--]=I.y,k[C--]=I.x,k[R++]=v.x,k[R++]=v.y,k[R++]=v.z),T=n["a"].PI_OVER_TWO-(L+1)*M}for(L=P;L>1;--L){if(T=n["a"].PI_OVER_TWO-(L-1)*M,I=h(-T,s,w,x,l,_,d,y,A,I),v=h(T+Math.PI,s,w,x,l,_,d,y,A,v),e){for(j[S++]=I.x,j[S++]=I.y,j[S++]=I.z,q=2*(L-1)+2,z=1;z<q-1;++z)U=z/(q-1),F=i["a"].lerp(I,v,U,p),j[S++]=F.x,j[S++]=F.y,j[S++]=F.z;j[S++]=v.x,j[S++]=v.y,j[S++]=v.z}a&&(k[C--]=I.z,k[C--]=I.y,k[C--]=I.x,k[R++]=v.x,k[R++]=v.y,k[R++]=v.z)}T=n["a"].PI_OVER_TWO,I=h(-T,s,w,x,l,_,d,y,A,I);const D={};return e&&(j[S++]=I.x,j[S++]=I.y,j[S++]=I.z,D.positions=j,D.numPts=P),a&&(k[C--]=I.z,k[C--]=I.y,k[C--]=I.x,D.outerPositions=k),D},e["a"]=s},a76e:function(t,e,a){"use strict";var i=a("8656"),n=a("dde0"),o=a("ae9b"),r=a("1a5d"),s=a("c937"),c=a("e107"),u=a("4a63");function l(t,e){o["a"].typeOf.object("ellipsoid",t),this._ellipsoid=t,this._cameraPosition=new n["a"],this._cameraPositionInScaledSpace=new n["a"],this._distanceToLimbInScaledSpaceSquared=0,Object(s["a"])(e)&&(this.cameraPosition=e)}Object.defineProperties(l.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},cameraPosition:{get:function(){return this._cameraPosition},set:function(t){const e=this._ellipsoid,a=e.transformPositionToScaledSpace(t,this._cameraPositionInScaledSpace),i=n["a"].magnitudeSquared(a)-1;n["a"].clone(t,this._cameraPosition),this._cameraPositionInScaledSpace=a,this._distanceToLimbInScaledSpaceSquared=i}}});const d=new n["a"];l.prototype.isPointVisible=function(t){const e=this._ellipsoid,a=e.transformPositionToScaledSpace(t,d);return y(a,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)},l.prototype.isScaledSpacePointVisible=function(t){return y(t,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};const h=new n["a"];l.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid=function(t,e){const a=this._ellipsoid;let i,n;return Object(s["a"])(e)&&e<0&&a.minimumRadius>-e?(n=h,n.x=this._cameraPosition.x/(a.radii.x+e),n.y=this._cameraPosition.y/(a.radii.y+e),n.z=this._cameraPosition.z/(a.radii.z+e),i=n.x*n.x+n.y*n.y+n.z*n.z-1):(n=this._cameraPositionInScaledSpace,i=this._distanceToLimbInScaledSpaceSquared),y(t,n,i)},l.prototype.computeHorizonCullingPoint=function(t,e,a){return g(this._ellipsoid,t,e,a)};const m=c["a"].clone(c["a"].UNIT_SPHERE);l.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid=function(t,e,a,i){const n=_(this._ellipsoid,a,m);return g(n,t,e,i)},l.prototype.computeHorizonCullingPointFromVertices=function(t,e,a,i,n){return O(this._ellipsoid,t,e,a,i,n)},l.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid=function(t,e,a,i,n,o){const r=_(this._ellipsoid,n,m);return O(r,t,e,a,i,o)};const f=[];l.prototype.computeHorizonCullingPointFromRectangle=function(t,e,a){o["a"].typeOf.object("rectangle",t);const r=u["a"].subsample(t,e,0,f),s=i["a"].fromPoints(r);if(!(n["a"].magnitude(s.center)<.1*e.minimumRadius))return this.computeHorizonCullingPoint(s.center,r,a)};const p=new n["a"];function _(t,e,a){if(Object(s["a"])(e)&&e<0&&t.minimumRadius>-e){const i=n["a"].fromElements(t.radii.x+e,t.radii.y+e,t.radii.z+e,p);t=c["a"].fromCartesian3(i,a)}return t}function g(t,e,a,i){o["a"].typeOf.object("directionToPoint",e),o["a"].defined("positions",a),Object(s["a"])(i)||(i=new n["a"]);const r=T(t,e);let c=0;for(let n=0,o=a.length;n<o;++n){const e=a[n],i=w(t,e,r);if(i<0)return;c=Math.max(c,i)}return P(r,c,i)}const b=new n["a"];function O(t,e,a,i,c,u){o["a"].typeOf.object("directionToPoint",e),o["a"].defined("vertices",a),o["a"].typeOf.number("stride",i),Object(s["a"])(u)||(u=new n["a"]),i=Object(r["a"])(i,3),c=Object(r["a"])(c,n["a"].ZERO);const l=T(t,e);let d=0;for(let n=0,o=a.length;n<o;n+=i){b.x=a[n]+c.x,b.y=a[n+1]+c.y,b.z=a[n+2]+c.z;const e=w(t,b,l);if(e<0)return;d=Math.max(d,e)}return P(l,d,u)}function y(t,e,a){const i=e,o=a,r=n["a"].subtract(t,i,d),s=-n["a"].dot(r,i),c=o<0?s>0:s>o&&s*s/n["a"].magnitudeSquared(r)>o;return!c}const A=new n["a"],x=new n["a"];function w(t,e,a){const i=t.transformPositionToScaledSpace(e,A);let o=n["a"].magnitudeSquared(i),r=Math.sqrt(o);const s=n["a"].divideByScalar(i,r,x);o=Math.max(1,o),r=Math.max(1,r);const c=n["a"].dot(s,a),u=n["a"].magnitude(n["a"].cross(s,a,s)),l=1/r,d=Math.sqrt(o-1)*l;return 1/(c*l-u*d)}function P(t,e,a){if(!(e<=0||e===1/0||e!==e))return n["a"].multiplyByScalar(t,e,a)}const M=new n["a"];function T(t,e){return n["a"].equals(e,n["a"].ZERO)?e:(t.transformPositionToScaledSpace(e,M),n["a"].normalize(M,M))}e["a"]=l},c256:function(t,e,a){"use strict";var i=a("9dc9"),n=a("8656"),o=a("dde0"),r=a("cbf0"),s=a("1a5d"),c=a("c937"),u=a("e2a6"),l=a("a295"),d=a("e107"),h=a("5a72"),m=a("f3a4"),f=a("0c02"),p=a("e148"),_=a("2642"),g=a("b8b5"),b=a("82ba");const O=new o["a"];let y=new o["a"];function A(t){const e=t.center;y=o["a"].multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(e,y),t.height,y),y=o["a"].add(e,y,y);const a=new n["a"](y,t.semiMajorAxis),i=l["a"].computeEllipsePositions(t,!1,!0).outerPositions,s=new f["a"]({position:new m["a"]({componentDatatype:r["a"].DOUBLE,componentsPerAttribute:3,values:l["a"].raisePositionsToHeight(i,t,!1)})}),c=i.length/3,u=_["a"].createTypedArray(c,2*c);let d=0;for(let n=0;n<c;++n)u[d++]=n,u[d++]=(n+1)%c;return{boundingSphere:a,attributes:s,indices:u}}const x=new n["a"],w=new n["a"];function P(t){const e=t.center,a=t.ellipsoid,u=t.semiMajorAxis;let d=o["a"].multiplyByScalar(a.geodeticSurfaceNormal(e,O),t.height,O);x.center=o["a"].add(e,d,x.center),x.radius=u,d=o["a"].multiplyByScalar(a.geodeticSurfaceNormal(e,d),t.extrudedHeight,d),w.center=o["a"].add(e,d,w.center),w.radius=u;let h=l["a"].computeEllipsePositions(t,!1,!0).outerPositions;const b=new f["a"]({position:new m["a"]({componentDatatype:r["a"].DOUBLE,componentsPerAttribute:3,values:l["a"].raisePositionsToHeight(h,t,!0)})});h=b.position.values;const y=n["a"].union(x,w);let A=h.length/3;if(Object(c["a"])(t.offsetAttribute)){let e=new Uint8Array(A);if(t.offsetAttribute===p["a"].TOP)e=Object(i["a"])(e,1,0,A/2);else{const a=t.offsetAttribute===p["a"].NONE?0:1;e=Object(i["a"])(e,a)}b.applyOffset=new m["a"]({componentDatatype:r["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let P=Object(s["a"])(t.numberOfVerticalLines,16);P=g["a"].clamp(P,0,A/2);const M=_["a"].createTypedArray(A,2*A+2*P);A/=2;let T,E,j=0;for(T=0;T<A;++T)M[j++]=T,M[j++]=(T+1)%A,M[j++]=T+A,M[j++]=(T+1)%A+A;if(P>0){const t=Math.min(P,A);E=Math.round(A/t);const e=Math.min(E*P,A);for(T=0;T<e;T+=E)M[j++]=T,M[j++]=T+A}return{boundingSphere:y,attributes:b,indices:M}}function M(t){t=Object(s["a"])(t,s["a"].EMPTY_OBJECT);const e=t.center,a=Object(s["a"])(t.ellipsoid,d["a"].WGS84),i=t.semiMajorAxis,n=t.semiMinorAxis,r=Object(s["a"])(t.granularity,g["a"].RADIANS_PER_DEGREE);if(!Object(c["a"])(e))throw new u["a"]("center is required.");if(!Object(c["a"])(i))throw new u["a"]("semiMajorAxis is required.");if(!Object(c["a"])(n))throw new u["a"]("semiMinorAxis is required.");if(i<n)throw new u["a"]("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(r<=0)throw new u["a"]("granularity must be greater than zero.");const l=Object(s["a"])(t.height,0),h=Object(s["a"])(t.extrudedHeight,l);this._center=o["a"].clone(e),this._semiMajorAxis=i,this._semiMinorAxis=n,this._ellipsoid=d["a"].clone(a),this._rotation=Object(s["a"])(t.rotation,0),this._height=Math.max(h,l),this._granularity=r,this._extrudedHeight=Math.min(h,l),this._numberOfVerticalLines=Math.max(Object(s["a"])(t.numberOfVerticalLines,16),0),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}M.packedLength=o["a"].packedLength+d["a"].packedLength+8,M.pack=function(t,e,a){if(!Object(c["a"])(t))throw new u["a"]("value is required");if(!Object(c["a"])(e))throw new u["a"]("array is required");return a=Object(s["a"])(a,0),o["a"].pack(t._center,e,a),a+=o["a"].packedLength,d["a"].pack(t._ellipsoid,e,a),a+=d["a"].packedLength,e[a++]=t._semiMajorAxis,e[a++]=t._semiMinorAxis,e[a++]=t._rotation,e[a++]=t._height,e[a++]=t._granularity,e[a++]=t._extrudedHeight,e[a++]=t._numberOfVerticalLines,e[a]=Object(s["a"])(t._offsetAttribute,-1),e};const T=new o["a"],E=new d["a"],j={center:T,ellipsoid:E,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};M.unpack=function(t,e,a){if(!Object(c["a"])(t))throw new u["a"]("array is required");e=Object(s["a"])(e,0);const i=o["a"].unpack(t,e,T);e+=o["a"].packedLength;const n=d["a"].unpack(t,e,E);e+=d["a"].packedLength;const r=t[e++],l=t[e++],h=t[e++],m=t[e++],f=t[e++],p=t[e++],_=t[e++],g=t[e];return Object(c["a"])(a)?(a._center=o["a"].clone(i,a._center),a._ellipsoid=d["a"].clone(n,a._ellipsoid),a._semiMajorAxis=r,a._semiMinorAxis=l,a._rotation=h,a._height=m,a._granularity=f,a._extrudedHeight=p,a._numberOfVerticalLines=_,a._offsetAttribute=-1===g?void 0:g,a):(j.height=m,j.extrudedHeight=p,j.granularity=f,j.rotation=h,j.semiMajorAxis=r,j.semiMinorAxis=l,j.numberOfVerticalLines=_,j.offsetAttribute=-1===g?void 0:g,new M(j))},M.createGeometry=function(t){if(t._semiMajorAxis<=0||t._semiMinorAxis<=0)return;const e=t._height,a=t._extrudedHeight,n=!g["a"].equalsEpsilon(e,a,0,g["a"].EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const o={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:e,granularity:t._granularity,numberOfVerticalLines:t._numberOfVerticalLines};let s;if(n)o.extrudedHeight=a,o.offsetAttribute=t._offsetAttribute,s=P(o);else if(s=A(o),Object(c["a"])(t._offsetAttribute)){const e=s.attributes.position.values.length,a=new Uint8Array(e/3),n=t._offsetAttribute===p["a"].NONE?0:1;Object(i["a"])(a,n),s.attributes.applyOffset=new m["a"]({componentDatatype:r["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new h["a"]({attributes:s.attributes,indices:s.indices,primitiveType:b["a"].LINES,boundingSphere:s.boundingSphere,offsetAttribute:t._offsetAttribute})},e["a"]=M},c993:function(t,e,a){"use strict";var i=a("dde0"),n=a("8d54"),o=a("ae9b"),r=a("1a5d"),s=a("c937"),c=a("e107"),u=a("b8b5");function l(t){const e=t._uSquared,a=t._ellipsoid.maximumRadius,i=t._ellipsoid.minimumRadius,n=(a-i)/a,o=Math.cos(t._startHeading),r=Math.sin(t._startHeading),s=(1-n)*Math.tan(t._start.latitude),c=1/Math.sqrt(1+s*s),u=c*s,l=Math.atan2(s,o),d=c*r,h=d*d,m=1-h,f=Math.sqrt(m),p=e/4,_=p*p,g=_*p,b=_*_,O=1+p-3*_/4+5*g/4-175*b/64,y=1-p+15*_/8-35*g/8,A=1-3*p+35*_/4,x=1-5*p,w=O*l-y*Math.sin(2*l)*p/2-A*Math.sin(4*l)*_/16-x*Math.sin(6*l)*g/48-5*Math.sin(8*l)*b/512,P=t._constants;P.a=a,P.b=i,P.f=n,P.cosineHeading=o,P.sineHeading=r,P.tanU=s,P.cosineU=c,P.sineU=u,P.sigma=l,P.sineAlpha=d,P.sineSquaredAlpha=h,P.cosineSquaredAlpha=m,P.cosineAlpha=f,P.u2Over4=p,P.u4Over16=_,P.u6Over64=g,P.u8Over256=b,P.a0=O,P.a1=y,P.a2=A,P.a3=x,P.distanceRatio=w}function d(t,e){return t*e*(4+t*(4-3*e))/16}function h(t,e,a,i,n,o,r){const s=d(t,a);return(1-s)*t*e*(i+s*n*(r+s*o*(2*r*r-1)))}function m(t,e,a,i,n,o,r){const s=(e-a)/e,c=o-i,l=Math.atan((1-s)*Math.tan(n)),d=Math.atan((1-s)*Math.tan(r)),m=Math.cos(l),f=Math.sin(l),p=Math.cos(d),_=Math.sin(d),g=m*p,b=m*_,O=f*_,y=f*p;let A,x,w,P,M,T=c,E=u["a"].TWO_PI,j=Math.cos(T),S=Math.sin(T);do{j=Math.cos(T),S=Math.sin(T);const t=b-y*j;let e;w=Math.sqrt(p*p*S*S+t*t),x=O+g*j,A=Math.atan2(w,x),0===w?(e=0,P=1):(e=g*S/w,P=1-e*e),E=T,M=x-2*O/P,isFinite(M)||(M=0),T=c+h(s,e,P,A,w,x,M)}while(Math.abs(T-E)>u["a"].EPSILON12);const I=P*(e*e-a*a)/(a*a),v=1+I*(4096+I*(I*(320-175*I)-768))/16384,N=I*(256+I*(I*(74-47*I)-128))/1024,C=M*M,R=N*w*(M+N*(x*(2*C-1)-N*M*(4*w*w-3)*(4*C-3)/6)/4),k=a*v*(A-R),L=Math.atan2(p*S,b-y*j),z=Math.atan2(m*S,b*j-y);t._distance=k,t._startHeading=L,t._endHeading=z,t._uSquared=I}const f=new i["a"],p=new i["a"];function _(t,e,a,r){const s=i["a"].normalize(r.cartographicToCartesian(e,p),f),c=i["a"].normalize(r.cartographicToCartesian(a,p),p);o["a"].typeOf.number.greaterThanOrEquals("value",Math.abs(Math.abs(i["a"].angleBetween(s,c))-Math.PI),.0125),m(t,r.maximumRadius,r.minimumRadius,e.longitude,e.latitude,a.longitude,a.latitude),t._start=n["a"].clone(e,t._start),t._end=n["a"].clone(a,t._end),t._start.height=0,t._end.height=0,l(t)}function g(t,e,a){const i=Object(r["a"])(a,c["a"].WGS84);this._ellipsoid=i,this._start=new n["a"],this._end=new n["a"],this._constants={},this._startHeading=void 0,this._endHeading=void 0,this._distance=void 0,this._uSquared=void 0,Object(s["a"])(t)&&Object(s["a"])(e)&&_(this,t,e,i)}Object.defineProperties(g.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return o["a"].defined("distance",this._distance),this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},startHeading:{get:function(){return o["a"].defined("distance",this._distance),this._startHeading}},endHeading:{get:function(){return o["a"].defined("distance",this._distance),this._endHeading}}}),g.prototype.setEndPoints=function(t,e){o["a"].defined("start",t),o["a"].defined("end",e),_(this,t,e,this._ellipsoid)},g.prototype.interpolateUsingFraction=function(t,e){return this.interpolateUsingSurfaceDistance(this._distance*t,e)},g.prototype.interpolateUsingSurfaceDistance=function(t,e){o["a"].defined("distance",this._distance);const a=this._constants,i=a.distanceRatio+t/a.b,r=Math.cos(2*i),c=Math.cos(4*i),u=Math.cos(6*i),l=Math.sin(2*i),d=Math.sin(4*i),m=Math.sin(6*i),f=Math.sin(8*i),p=i*i,_=i*p,g=a.u8Over256,b=a.u2Over4,O=a.u6Over64,y=a.u4Over16;let A=2*_*g*r/3+i*(1-b+7*y/4-15*O/4+579*g/64-(y-15*O/4+187*g/16)*r-(5*O/4-115*g/16)*c-29*g*u/16)+(b/2-y+71*O/32-85*g/16)*l+(5*y/16-5*O/4+383*g/96)*d-p*((O-11*g/2)*l+5*g*d/2)+(29*O/96-29*g/16)*m+539*g*f/1536;const x=Math.asin(Math.sin(A)*a.cosineAlpha),w=Math.atan(a.a/a.b*Math.tan(x));A-=a.sigma;const P=Math.cos(2*a.sigma+A),M=Math.sin(A),T=Math.cos(A),E=a.cosineU*T,j=a.sineU*M,S=Math.atan2(M*a.sineHeading,E-j*a.cosineHeading),I=S-h(a.f,a.sineAlpha,a.cosineSquaredAlpha,A,M,T,P);return Object(s["a"])(e)?(e.longitude=this._start.longitude+I,e.latitude=w,e.height=0,e):new n["a"](this._start.longitude+I,w,0)},e["a"]=g},e107:function(t,e,a){"use strict";var i=a("dde0"),n=a("8d54"),o=a("ae9b"),r=a("1a5d"),s=a("c937"),c=a("e2a6"),u=a("b8b5"),l=a("0299");function d(t,e,a,n){e=Object(r["a"])(e,0),a=Object(r["a"])(a,0),n=Object(r["a"])(n,0),o["a"].typeOf.number.greaterThanOrEquals("x",e,0),o["a"].typeOf.number.greaterThanOrEquals("y",a,0),o["a"].typeOf.number.greaterThanOrEquals("z",n,0),t._radii=new i["a"](e,a,n),t._radiiSquared=new i["a"](e*e,a*a,n*n),t._radiiToTheFourth=new i["a"](e*e*e*e,a*a*a*a,n*n*n*n),t._oneOverRadii=new i["a"](0===e?0:1/e,0===a?0:1/a,0===n?0:1/n),t._oneOverRadiiSquared=new i["a"](0===e?0:1/(e*e),0===a?0:1/(a*a),0===n?0:1/(n*n)),t._minimumRadius=Math.min(e,a,n),t._maximumRadius=Math.max(e,a,n),t._centerToleranceSquared=u["a"].EPSILON1,0!==t._radiiSquared.z&&(t._squaredXOverSquaredZ=t._radiiSquared.x/t._radiiSquared.z)}function h(t,e,a){this._radii=void 0,this._radiiSquared=void 0,this._radiiToTheFourth=void 0,this._oneOverRadii=void 0,this._oneOverRadiiSquared=void 0,this._minimumRadius=void 0,this._maximumRadius=void 0,this._centerToleranceSquared=void 0,this._squaredXOverSquaredZ=void 0,d(this,t,e,a)}Object.defineProperties(h.prototype,{radii:{get:function(){return this._radii}},radiiSquared:{get:function(){return this._radiiSquared}},radiiToTheFourth:{get:function(){return this._radiiToTheFourth}},oneOverRadii:{get:function(){return this._oneOverRadii}},oneOverRadiiSquared:{get:function(){return this._oneOverRadiiSquared}},minimumRadius:{get:function(){return this._minimumRadius}},maximumRadius:{get:function(){return this._maximumRadius}}}),h.clone=function(t,e){if(!Object(s["a"])(t))return;const a=t._radii;return Object(s["a"])(e)?(i["a"].clone(a,e._radii),i["a"].clone(t._radiiSquared,e._radiiSquared),i["a"].clone(t._radiiToTheFourth,e._radiiToTheFourth),i["a"].clone(t._oneOverRadii,e._oneOverRadii),i["a"].clone(t._oneOverRadiiSquared,e._oneOverRadiiSquared),e._minimumRadius=t._minimumRadius,e._maximumRadius=t._maximumRadius,e._centerToleranceSquared=t._centerToleranceSquared,e):new h(a.x,a.y,a.z)},h.fromCartesian3=function(t,e){return Object(s["a"])(e)||(e=new h),Object(s["a"])(t)?(d(e,t.x,t.y,t.z),e):e},h.WGS84=Object.freeze(new h(6378137,6378137,6356752.314245179)),h.UNIT_SPHERE=Object.freeze(new h(1,1,1)),h.MOON=Object.freeze(new h(u["a"].LUNAR_RADIUS,u["a"].LUNAR_RADIUS,u["a"].LUNAR_RADIUS)),h.prototype.clone=function(t){return h.clone(this,t)},h.packedLength=i["a"].packedLength,h.pack=function(t,e,a){return o["a"].typeOf.object("value",t),o["a"].defined("array",e),a=Object(r["a"])(a,0),i["a"].pack(t._radii,e,a),e},h.unpack=function(t,e,a){o["a"].defined("array",t),e=Object(r["a"])(e,0);const n=i["a"].unpack(t,e);return h.fromCartesian3(n,a)},h.prototype.geocentricSurfaceNormal=i["a"].normalize,h.prototype.geodeticSurfaceNormalCartographic=function(t,e){o["a"].typeOf.object("cartographic",t);const a=t.longitude,n=t.latitude,r=Math.cos(n),c=r*Math.cos(a),u=r*Math.sin(a),l=Math.sin(n);return Object(s["a"])(e)||(e=new i["a"]),e.x=c,e.y=u,e.z=l,i["a"].normalize(e,e)},h.prototype.geodeticSurfaceNormal=function(t,e){if(!i["a"].equalsEpsilon(t,i["a"].ZERO,u["a"].EPSILON14))return Object(s["a"])(e)||(e=new i["a"]),e=i["a"].multiplyComponents(t,this._oneOverRadiiSquared,e),i["a"].normalize(e,e)};const m=new i["a"],f=new i["a"];h.prototype.cartographicToCartesian=function(t,e){const a=m,n=f;this.geodeticSurfaceNormalCartographic(t,a),i["a"].multiplyComponents(this._radiiSquared,a,n);const o=Math.sqrt(i["a"].dot(a,n));return i["a"].divideByScalar(n,o,n),i["a"].multiplyByScalar(a,t.height,a),Object(s["a"])(e)||(e=new i["a"]),i["a"].add(n,a,e)},h.prototype.cartographicArrayToCartesianArray=function(t,e){o["a"].defined("cartographics",t);const a=t.length;Object(s["a"])(e)?e.length=a:e=new Array(a);for(let i=0;i<a;i++)e[i]=this.cartographicToCartesian(t[i],e[i]);return e};const p=new i["a"],_=new i["a"],g=new i["a"];h.prototype.cartesianToCartographic=function(t,e){const a=this.scaleToGeodeticSurface(t,_);if(!Object(s["a"])(a))return;const o=this.geodeticSurfaceNormal(a,p),r=i["a"].subtract(t,a,g),c=Math.atan2(o.y,o.x),l=Math.asin(o.z),d=u["a"].sign(i["a"].dot(r,t))*i["a"].magnitude(r);return Object(s["a"])(e)?(e.longitude=c,e.latitude=l,e.height=d,e):new n["a"](c,l,d)},h.prototype.cartesianArrayToCartographicArray=function(t,e){o["a"].defined("cartesians",t);const a=t.length;Object(s["a"])(e)?e.length=a:e=new Array(a);for(let i=0;i<a;++i)e[i]=this.cartesianToCartographic(t[i],e[i]);return e},h.prototype.scaleToGeodeticSurface=function(t,e){return Object(l["a"])(t,this._oneOverRadii,this._oneOverRadiiSquared,this._centerToleranceSquared,e)},h.prototype.scaleToGeocentricSurface=function(t,e){o["a"].typeOf.object("cartesian",t),Object(s["a"])(e)||(e=new i["a"]);const a=t.x,n=t.y,r=t.z,c=this._oneOverRadiiSquared,u=1/Math.sqrt(a*a*c.x+n*n*c.y+r*r*c.z);return i["a"].multiplyByScalar(t,u,e)},h.prototype.transformPositionToScaledSpace=function(t,e){return Object(s["a"])(e)||(e=new i["a"]),i["a"].multiplyComponents(t,this._oneOverRadii,e)},h.prototype.transformPositionFromScaledSpace=function(t,e){return Object(s["a"])(e)||(e=new i["a"]),i["a"].multiplyComponents(t,this._radii,e)},h.prototype.equals=function(t){return this===t||Object(s["a"])(t)&&i["a"].equals(this._radii,t._radii)},h.prototype.toString=function(){return this._radii.toString()},h.prototype.getSurfaceNormalIntersectionWithZAxis=function(t,e,a){if(o["a"].typeOf.object("position",t),!u["a"].equalsEpsilon(this._radii.x,this._radii.y,u["a"].EPSILON15))throw new c["a"]("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");o["a"].typeOf.number.greaterThan("Ellipsoid.radii.z",this._radii.z,0),e=Object(r["a"])(e,0);const n=this._squaredXOverSquaredZ;if(Object(s["a"])(a)||(a=new i["a"]),a.x=0,a.y=0,a.z=t.z*(1-n),!(Math.abs(a.z)>=this._radii.z-e))return a};const b=[.14887433898163,.43339539412925,.67940956829902,.86506336668898,.97390652851717,0],O=[.29552422471475,.26926671930999,.21908636251598,.14945134915058,.066671344308684,0];function y(t,e,a){o["a"].typeOf.number("a",t),o["a"].typeOf.number("b",e),o["a"].typeOf.func("func",a);const i=.5*(e+t),n=.5*(e-t);let r=0;for(let o=0;o<5;o++){const t=n*b[o];r+=O[o]*(a(i+t)+a(i-t))}return r*=n,r}h.prototype.surfaceArea=function(t){o["a"].typeOf.object("rectangle",t);const e=t.west;let a=t.east;const i=t.south,n=t.north;while(a<e)a+=u["a"].TWO_PI;const r=this._radiiSquared,s=r.x,c=r.y,l=r.z,d=s*c;return y(i,n,(function(t){const i=Math.cos(t),n=Math.sin(t);return Math.cos(t)*y(e,a,(function(t){const e=Math.cos(t),a=Math.sin(t);return Math.sqrt(d*n*n+l*(c*e*e+s*a*a)*i*i)}))}))},e["a"]=h},e19c:function(t,e,a){"use strict";var i=a("9dc9"),n=a("8656"),o=a("dde0"),r=a("cbf0"),s=a("1a5d"),c=a("c937"),u=a("e2a6"),l=a("e107"),d=a("5a72"),h=a("f3a4"),m=a("0c02"),f=a("e148"),p=a("2642"),_=a("b8b5"),g=a("82ba");const b=new o["a"](1,1,1),O=Math.cos,y=Math.sin;function A(t){t=Object(s["a"])(t,s["a"].EMPTY_OBJECT);const e=Object(s["a"])(t.radii,b),a=Object(s["a"])(t.innerRadii,e),i=Object(s["a"])(t.minimumClock,0),n=Object(s["a"])(t.maximumClock,_["a"].TWO_PI),r=Object(s["a"])(t.minimumCone,0),l=Object(s["a"])(t.maximumCone,_["a"].PI),d=Math.round(Object(s["a"])(t.stackPartitions,10)),h=Math.round(Object(s["a"])(t.slicePartitions,8)),m=Math.round(Object(s["a"])(t.subdivisions,128));if(d<1)throw new u["a"]("options.stackPartitions cannot be less than 1");if(h<0)throw new u["a"]("options.slicePartitions cannot be less than 0");if(m<0)throw new u["a"]("options.subdivisions must be greater than or equal to zero.");if(Object(c["a"])(t.offsetAttribute)&&t.offsetAttribute===f["a"].TOP)throw new u["a"]("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=o["a"].clone(e),this._innerRadii=o["a"].clone(a),this._minimumClock=i,this._maximumClock=n,this._minimumCone=r,this._maximumCone=l,this._stackPartitions=d,this._slicePartitions=h,this._subdivisions=m,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}A.packedLength=2*o["a"].packedLength+8,A.pack=function(t,e,a){if(!Object(c["a"])(t))throw new u["a"]("value is required");if(!Object(c["a"])(e))throw new u["a"]("array is required");return a=Object(s["a"])(a,0),o["a"].pack(t._radii,e,a),a+=o["a"].packedLength,o["a"].pack(t._innerRadii,e,a),a+=o["a"].packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a++]=t._subdivisions,e[a]=Object(s["a"])(t._offsetAttribute,-1),e};const x=new o["a"],w=new o["a"],P={radii:x,innerRadii:w,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};A.unpack=function(t,e,a){if(!Object(c["a"])(t))throw new u["a"]("array is required");e=Object(s["a"])(e,0);const i=o["a"].unpack(t,e,x);e+=o["a"].packedLength;const n=o["a"].unpack(t,e,w);e+=o["a"].packedLength;const r=t[e++],l=t[e++],d=t[e++],h=t[e++],m=t[e++],f=t[e++],p=t[e++],_=t[e];return Object(c["a"])(a)?(a._radii=o["a"].clone(i,a._radii),a._innerRadii=o["a"].clone(n,a._innerRadii),a._minimumClock=r,a._maximumClock=l,a._minimumCone=d,a._maximumCone=h,a._stackPartitions=m,a._slicePartitions=f,a._subdivisions=p,a._offsetAttribute=-1===_?void 0:_,a):(P.minimumClock=r,P.maximumClock=l,P.minimumCone=d,P.maximumCone=h,P.stackPartitions=m,P.slicePartitions=f,P.subdivisions=p,P.offsetAttribute=-1===_?void 0:_,new A(P))},A.createGeometry=function(t){const e=t._radii;if(e.x<=0||e.y<=0||e.z<=0)return;const a=t._innerRadii;if(a.x<=0||a.y<=0||a.z<=0)return;const o=t._minimumClock,s=t._maximumClock,u=t._minimumCone,b=t._maximumCone,A=t._subdivisions,x=l["a"].fromCartesian3(e);let w=t._slicePartitions+1,P=t._stackPartitions+1;w=Math.round(w*Math.abs(s-o)/_["a"].TWO_PI),P=Math.round(P*Math.abs(b-u)/_["a"].PI),w<2&&(w=2),P<2&&(P=2);let M=0,T=1;const E=a.x!==e.x||a.y!==e.y||a.z!==e.z;let j=!1,S=!1;E&&(T=2,u>0&&(j=!0,M+=w),b<Math.PI&&(S=!0,M+=w));const I=A*T*(P+w),v=new Float64Array(3*I),N=2*(I+M-(w+P)*T),C=p["a"].createTypedArray(I,N);let R,k,L,z,q=0;const U=new Array(P),F=new Array(P);for(R=0;R<P;R++)z=u+R*(b-u)/(P-1),U[R]=y(z),F[R]=O(z);const D=new Array(A),V=new Array(A);for(R=0;R<A;R++)L=o+R*(s-o)/(A-1),D[R]=y(L),V[R]=O(L);for(R=0;R<P;R++)for(k=0;k<A;k++)v[q++]=e.x*U[R]*V[k],v[q++]=e.y*U[R]*D[k],v[q++]=e.z*F[R];if(E)for(R=0;R<P;R++)for(k=0;k<A;k++)v[q++]=a.x*U[R]*V[k],v[q++]=a.y*U[R]*D[k],v[q++]=a.z*F[R];for(U.length=A,F.length=A,R=0;R<A;R++)z=u+R*(b-u)/(A-1),U[R]=y(z),F[R]=O(z);for(D.length=w,V.length=w,R=0;R<w;R++)L=o+R*(s-o)/(w-1),D[R]=y(L),V[R]=O(L);for(R=0;R<A;R++)for(k=0;k<w;k++)v[q++]=e.x*U[R]*V[k],v[q++]=e.y*U[R]*D[k],v[q++]=e.z*F[R];if(E)for(R=0;R<A;R++)for(k=0;k<w;k++)v[q++]=a.x*U[R]*V[k],v[q++]=a.y*U[R]*D[k],v[q++]=a.z*F[R];for(q=0,R=0;R<P*T;R++){const t=R*A;for(k=0;k<A-1;k++)C[q++]=t+k,C[q++]=t+k+1}let B=P*A*T;for(R=0;R<w;R++)for(k=0;k<A-1;k++)C[q++]=B+R+k*w,C[q++]=B+R+(k+1)*w;if(E)for(B=P*A*T+w*A,R=0;R<w;R++)for(k=0;k<A-1;k++)C[q++]=B+R+k*w,C[q++]=B+R+(k+1)*w;if(E){let t=P*A*T,e=t+A*w;if(j)for(R=0;R<w;R++)C[q++]=t+R,C[q++]=e+R;if(S)for(t+=A*w-w,e+=A*w-w,R=0;R<w;R++)C[q++]=t+R,C[q++]=e+R}const G=new m["a"]({position:new h["a"]({componentDatatype:r["a"].DOUBLE,componentsPerAttribute:3,values:v})});if(Object(c["a"])(t._offsetAttribute)){const e=v.length,a=new Uint8Array(e/3),n=t._offsetAttribute===f["a"].NONE?0:1;Object(i["a"])(a,n),G.applyOffset=new h["a"]({componentDatatype:r["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new d["a"]({attributes:G,indices:C,primitiveType:g["a"].LINES,boundingSphere:n["a"].fromEllipsoid(x),offsetAttribute:t._offsetAttribute})},e["a"]=A}}]);