(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-vendors~fc89b83a"],{"0f7c":function(e,n,t){"use strict";n["a"]="#ifdef WRITE_DEPTH\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n#endif\n#endif\n\nuniform vec3 u_radii;\nuniform vec3 u_oneOverEllipsoidRadiiSquared;\n\nvarying vec3 v_positionEC;\n\nvec4 computeEllipsoidColor(czm_ray ray, float intersection, float side)\n{\n    vec3 positionEC = czm_pointAlongRay(ray, intersection);\n    vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\n    vec3 geodeticNormal = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), u_oneOverEllipsoidRadiiSquared));\n    vec3 sphericalNormal = normalize(positionMC / u_radii);\n    vec3 normalMC = geodeticNormal * side;              // normalized surface normal (always facing the viewer) in model coordinates\n    vec3 normalEC = normalize(czm_normal * normalMC);   // normalized surface normal in eye coordiantes\n\n    vec2 st = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);\n    vec3 positionToEyeEC = -positionEC;\n\n    czm_materialInput materialInput;\n    materialInput.s = st.s;\n    materialInput.st = st;\n    materialInput.str = (positionMC + u_radii) / u_radii;\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef ONLY_SUN_LIGHTING\n    return czm_private_phong(normalize(positionToEyeEC), material, czm_sunDirectionEC);\n#else\n    return czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n\nvoid main()\n{\n    // PERFORMANCE_TODO: When dynamic branching is available, compute ratio of maximum and minimum radii\n    // in the vertex shader. Only when it is larger than some constant, march along the ray.\n    // Otherwise perform one intersection test which will be the common case.\n\n    // Test if the ray intersects a sphere with the ellipsoid's maximum radius.\n    // For very oblate ellipsoids, using the ellipsoid's radii for an intersection test\n    // may cause false negatives. This will discard fragments before marching the ray forward.\n    float maxRadius = max(u_radii.x, max(u_radii.y, u_radii.z)) * 1.5;\n    vec3 direction = normalize(v_positionEC);\n    vec3 ellipsoidCenter = czm_modelView[3].xyz;\n\n    float t1 = -1.0;\n    float t2 = -1.0;\n\n    float b = -2.0 * dot(direction, ellipsoidCenter);\n    float c = dot(ellipsoidCenter, ellipsoidCenter) - maxRadius * maxRadius;\n\n    float discriminant = b * b - 4.0 * c;\n    if (discriminant >= 0.0) {\n        t1 = (-b - sqrt(discriminant)) * 0.5;\n        t2 = (-b + sqrt(discriminant)) * 0.5;\n    }\n\n    if (t1 < 0.0 && t2 < 0.0) {\n        discard;\n    }\n\n    float t = min(t1, t2);\n    if (t < 0.0) {\n        t = 0.0;\n    }\n\n    // March ray forward to intersection with larger sphere and find\n    czm_ray ray = czm_ray(t * direction, direction);\n\n    vec3 ellipsoid_inverseRadii = vec3(1.0 / u_radii.x, 1.0 / u_radii.y, 1.0 / u_radii.z);\n\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoidCenter, ellipsoid_inverseRadii);\n\n    if (czm_isEmpty(intersection))\n    {\n        discard;\n    }\n\n    // If the viewer is outside, compute outsideFaceColor, with normals facing outward.\n    vec4 outsideFaceColor = (intersection.start != 0.0) ? computeEllipsoidColor(ray, intersection.start, 1.0) : vec4(0.0);\n\n    // If the viewer either is inside or can see inside, compute insideFaceColor, with normals facing inward.\n    vec4 insideFaceColor = (outsideFaceColor.a < 1.0) ? computeEllipsoidColor(ray, intersection.stop, -1.0) : vec4(0.0);\n\n    gl_FragColor = mix(insideFaceColor, outsideFaceColor, outsideFaceColor.a);\n    gl_FragColor.a = 1.0 - (1.0 - insideFaceColor.a) * (1.0 - outsideFaceColor.a);\n\n#ifdef WRITE_DEPTH\n#ifdef GL_EXT_frag_depth\n    t = (intersection.start != 0.0) ? intersection.start : intersection.stop;\n    vec3 positionEC = czm_pointAlongRay(ray, t);\n    vec4 positionCC = czm_projection * vec4(positionEC, 1.0);\n#ifdef LOG_DEPTH\n    czm_writeLogDepth(1.0 + positionCC.w);\n#else\n    float z = positionCC.z / positionCC.w;\n\n    float n = czm_depthRange.near;\n    float f = czm_depthRange.far;\n\n    gl_FragDepthEXT = (z * (f - n) + f + n) * 0.5;\n#endif\n#endif\n#endif\n}\n"},"215e":function(e,n,t){"use strict";n["a"]="/**\n * Compositing for Weighted Blended Order-Independent Transparency. See:\n * - http://jcgt.org/published/0002/02/09/\n * - http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html\n */\n\nuniform sampler2D u_opaque;\nuniform sampler2D u_accumulation;\nuniform sampler2D u_revealage;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    vec4 opaque = texture2D(u_opaque, v_textureCoordinates);\n    vec4 accum = texture2D(u_accumulation, v_textureCoordinates);\n    float r = texture2D(u_revealage, v_textureCoordinates).r;\n\n#ifdef MRT\n    vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);\n#else\n    vec4 transparent = vec4(accum.rgb / clamp(accum.a, 1e-4, 5e4), r);\n#endif\n\n    gl_FragColor = (1.0 - transparent.a) * transparent + transparent.a * opaque;\n\n    if (opaque != czm_backgroundColor)\n    {\n        gl_FragColor.a = 1.0;\n    }\n}\n"},"2be3":function(e,n,t){"use strict";n["a"]="uniform sampler2D u_noiseTexture;\nuniform vec3 u_noiseTextureDimensions;\nuniform float u_noiseDetail;\nvarying vec2 v_offset;\nvarying vec3 v_maximumSize;\nvarying vec4 v_color;\nvarying float v_slice;\nvarying float v_brightness;\n\nfloat wrap(float value, float rangeLength) {\n    if(value < 0.0) {\n        float absValue = abs(value);\n        float modValue = mod(absValue, rangeLength);\n        return mod(rangeLength - modValue, rangeLength);\n    }\n    return mod(value, rangeLength);\n}\n\nvec3 wrapVec(vec3 value, float rangeLength) {\n    return vec3(wrap(value.x, rangeLength),\n                wrap(value.y, rangeLength),\n                wrap(value.z, rangeLength));\n}\n\nfloat textureSliceWidth = u_noiseTextureDimensions.x;\nfloat noiseTextureRows = u_noiseTextureDimensions.y;\nfloat inverseNoiseTextureRows = u_noiseTextureDimensions.z;\n\nfloat textureSliceWidthSquared = textureSliceWidth * textureSliceWidth;\nvec2 inverseNoiseTextureDimensions = vec2(noiseTextureRows / textureSliceWidthSquared,\n                                          inverseNoiseTextureRows / textureSliceWidth);\n\nvec2 voxelToUV(vec3 voxelIndex) {\n    vec3 wrappedIndex = wrapVec(voxelIndex, textureSliceWidth);\n    float column = mod(wrappedIndex.z, textureSliceWidth * inverseNoiseTextureRows);\n    float row = floor(wrappedIndex.z / textureSliceWidth * noiseTextureRows);\n\n    float xPixelCoord = wrappedIndex.x + column * textureSliceWidth;\n    float yPixelCoord = wrappedIndex.y + row * textureSliceWidth;\n    return vec2(xPixelCoord, yPixelCoord) * inverseNoiseTextureDimensions;\n}\n\n// Interpolate a voxel with its neighbor (along the positive X-axis)\nvec4 lerpSamplesX(vec3 voxelIndex, float x) {\n    vec2 uv0 = voxelToUV(voxelIndex);\n    vec2 uv1 = voxelToUV(voxelIndex + vec3(1.0, 0.0, 0.0));\n    vec4 sample0 = texture2D(u_noiseTexture, uv0);\n    vec4 sample1 = texture2D(u_noiseTexture, uv1);\n    return mix(sample0, sample1, x);\n}\n\nvec4 sampleNoiseTexture(vec3 position) {\n    vec3 recenteredPos = position + vec3(textureSliceWidth / 2.0);\n    vec3 lerpValue = fract(recenteredPos);\n    vec3 voxelIndex = floor(recenteredPos);\n\n    vec4 xLerp00 = lerpSamplesX(voxelIndex, lerpValue.x);\n    vec4 xLerp01 = lerpSamplesX(voxelIndex + vec3(0.0, 0.0, 1.0), lerpValue.x);\n    vec4 xLerp10 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 0.0), lerpValue.x);\n    vec4 xLerp11 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 1.0), lerpValue.x);\n\n    vec4 yLerp0 = mix(xLerp00, xLerp10, lerpValue.y);\n    vec4 yLerp1 = mix(xLerp01, xLerp11, lerpValue.y);\n    return mix(yLerp0, yLerp1, lerpValue.z);\n}\n\n// Intersection with a unit sphere with radius 0.5 at center (0, 0, 0).\nbool intersectSphere(vec3 origin, vec3 dir, float slice,\n                     out vec3 point, out vec3 normal) {\n    float A = dot(dir, dir);\n    float B = dot(origin, dir);\n    float C = dot(origin, origin) - 0.25;\n    float discriminant = (B * B) - (A * C);\n    if(discriminant < 0.0) {\n        return false;\n    }\n    float root = sqrt(discriminant);\n    float t = (-B - root) / A;\n    if(t < 0.0) {\n        t = (-B + root) / A;\n    }\n    point = origin + t * dir;\n\n    if(slice >= 0.0) {\n        point.z = (slice / 2.0) - 0.5;\n        if(length(point) > 0.5) {\n            return false;\n        }\n    }\n\n    normal = normalize(point);\n    point -= czm_epsilon2 * normal;\n    return true;\n}\n\n// Transforms the ray origin and direction into unit sphere space,\n// then transforms the result back into the ellipsoid's space.\nbool intersectEllipsoid(vec3 origin, vec3 dir, vec3 center, vec3 scale, float slice,\n                        out vec3 point, out vec3 normal) {\n    if(scale.x <= 0.01 || scale.y < 0.01 || scale.z < 0.01) {\n        return false;\n    }\n\n    vec3 o = (origin - center) / scale;\n    vec3 d = dir / scale;\n    vec3 p, n;\n    bool intersected = intersectSphere(o, d, slice, p, n);\n    if(intersected) {\n        point = (p * scale) + center;\n        normal = n;\n    }\n    return intersected;\n}\n\n// Assume that if phase shift is being called for octave i,\n// the frequency is of i - 1. This saves us from doing extra\n// division / multiplication operations.\nvec2 phaseShift2D(vec2 p, vec2 freq) {\n    return (czm_pi / 2.0) * sin(freq.yx * p.yx);\n}\n\nvec2 phaseShift3D(vec3 p, vec2 freq) {\n    return phaseShift2D(p.xy, freq) + czm_pi * vec2(sin(freq.x * p.z));\n}\n\n// The cloud texture function derived from Gardner's 1985 paper,\n// \"Visual Simulation of Clouds.\"\n// https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf\nconst float T0    = 0.6;  // contrast of the texture pattern\nconst float k     = 0.1;  // computed to produce a maximum value of 1\nconst float C0    = 0.8;  // coefficient\nconst float FX0   = 0.6;  // frequency X\nconst float FY0   = 0.6;  // frequency Y\nconst int octaves = 5;\n\nfloat T(vec3 point) {\n    vec2 sum = vec2(0.0);\n    float Ci = C0;\n    vec2 FXY = vec2(FX0, FY0);\n    vec2 PXY = vec2(0.0);\n    for(int i = 1; i <= octaves; i++) {\n        PXY = phaseShift3D(point, FXY);\n        Ci *= 0.707;\n        FXY *= 2.0;\n        vec2 sinTerm = sin(FXY * point.xy + PXY);\n        sum += Ci * sinTerm + vec2(T0);\n    }\n    return k * sum.x * sum.y;\n}\n\nconst float a = 0.5;  // fraction of surface reflection due to ambient or scattered light,\nconst float t = 0.4;  // fraction of texture shading\nconst float s = 0.25; // fraction of specular reflection\n\nfloat I(float Id, float Is, float It) {\n    return (1.0 - a) * ((1.0 - t) * ((1.0 - s) * Id + s * Is) + t * It) + a;\n}\n\nconst vec3 lightDir = normalize(vec3(0.2, -1.0, 0.7));\n\nvec4 drawCloud(vec3 rayOrigin, vec3 rayDir, vec3 cloudCenter, vec3 cloudScale, float cloudSlice,\n               float brightness) {\n    vec3 cloudPoint, cloudNormal;\n    if(!intersectEllipsoid(rayOrigin, rayDir, cloudCenter, cloudScale, cloudSlice,\n                            cloudPoint, cloudNormal)) {\n        return vec4(0.0);\n    }\n\n    float Id = clamp(dot(cloudNormal, -lightDir), 0.0, 1.0);  // diffuse reflection\n    float Is = max(pow(dot(-lightDir, -rayDir), 2.0), 0.0);   // specular reflection\n    float It = T(cloudPoint);                                 // texture function\n    float intensity = I(Id, Is, It);\n    vec3 color = vec3(intensity * clamp(brightness, 0.1, 1.0));\n\n    vec4 noise = sampleNoiseTexture(u_noiseDetail * cloudPoint);\n    float W = noise.x;\n    float W2 = noise.y;\n    float W3 = noise.z;\n\n    // The dot product between the cloud's normal and the ray's direction is greatest\n    // in the center of the ellipsoid's surface. It decreases towards the edge.\n    // Thus, it is used to blur the areas leading to the edges of the ellipsoid,\n    // so that no harsh lines appear.\n\n    // The first (and biggest) layer of worley noise is then subtracted from this.\n    // The final result is scaled up so that the base cloud is not too translucent.\n    float ndDot = clamp(dot(cloudNormal, -rayDir), 0.0, 1.0);\n    float TR = pow(ndDot, 3.0) - W; // translucency\n    TR *= 1.3;\n\n    // Subtracting the second and third layers of worley noise is more complicated.\n    // If these layers of noise were simply subtracted from the current translucency,\n    // the shape derived from the first layer of noise would be completely deleted.\n    // The erosion of this noise should thus be constricted to the edges of the cloud.\n    // However, because the edges of the ellipsoid were already blurred away, mapping\n    // the noise to (1.0 - ndDot) will have no impact on most of the cloud's appearance.\n    // The value of (0.5 - ndDot) provides the best compromise.\n    float minusDot = 0.5 - ndDot;\n\n    // Even with the previous calculation, subtracting the second layer of wnoise\n    // erode too much of the cloud. The addition of it, however, will detailed\n    // volume to the cloud. As long as the noise is only added and not subtracted,\n    // the results are aesthetically pleasing.\n\n    // The minusDot product is mapped in a way that it is larger at the edges of\n    // the ellipsoid, so a subtraction and min operation are used instead of\n    // an addition and max one.\n    TR -= min(minusDot * W2, 0.0);\n\n    // The third level of worley noise is subtracted from the result, with some\n    // modifications. First, a scalar is added to minusDot so that the noise\n    // starts affecting the shape farther away from the center of the ellipsoid's\n    // surface. Then, it is scaled down so its impact is not too intense.\n    TR -= 0.8 * (minusDot + 0.25) * W3;\n\n    // The texture function's shading does not correlate with the shape of the cloud\n    // produced by the layers of noise, so an extra shading scalar is calculated.\n    // The darkest areas of the cloud are assigned to be where the noise erodes\n    // the cloud the most. This is then interpolated based on the translucency\n    // and the diffuse shading term of that point in the cloud.\n    float shading = mix(1.0 - 0.8 * W * W, 1.0, Id * TR);\n\n    // To avoid values that are too dark, this scalar is increased by a small amount\n    // and clamped so it never goes to zero.\n    shading = clamp(shading + 0.2, 0.3, 1.0);\n\n    // Finally, the contrast of the cloud's color is increased.\n    vec3 finalColor = mix(vec3(0.5), shading * color, 1.15);\n    return vec4(finalColor, clamp(TR, 0.0, 1.0)) * v_color;\n}\n\nvoid main() {\n#ifdef DEBUG_BILLBOARDS\n    gl_FragColor = vec4(0.0, 0.5, 0.5, 1.0);\n#endif\n    // To avoid calculations with high values,\n    // we raycast from an arbitrarily smaller space.\n    vec2 coordinate = v_maximumSize.xy * v_offset;\n\n    vec3 ellipsoidScale = 0.82 * v_maximumSize;\n    vec3 ellipsoidCenter = vec3(0.0);\n\n    float zOffset = max(ellipsoidScale.z - 10.0, 0.0);\n    vec3 eye = vec3(0, 0, -10.0 - zOffset);\n    vec3 rayDir = normalize(vec3(coordinate, 1.0) - eye);\n    vec3 rayOrigin = eye;\n#ifdef DEBUG_ELLIPSOIDS\n    vec3 point, normal;\n    if(intersectEllipsoid(rayOrigin, rayDir, ellipsoidCenter, ellipsoidScale, v_slice,\n                          point, normal)) {\n        gl_FragColor = v_brightness * v_color;\n    }\n#else\n#ifndef DEBUG_BILLBOARDS\n    vec4 cloud = drawCloud(rayOrigin, rayDir,\n                           ellipsoidCenter, ellipsoidScale, v_slice, v_brightness);\n    if(cloud.w < 0.01) {\n        discard;\n    }\n    gl_FragColor = cloud;\n#endif\n#endif\n}\n"},4455:function(e,n,t){"use strict";n["a"]="uniform vec3 u_noiseTextureDimensions;\nuniform float u_noiseDetail;\nuniform vec3 u_noiseOffset;\nvarying vec2 v_position;\n\nfloat textureSliceWidth = u_noiseTextureDimensions.x;\nfloat inverseNoiseTextureRows = u_noiseTextureDimensions.z;\n\nfloat wrap(float value, float rangeLength) {\n    if(value < 0.0) {\n        float absValue = abs(value);\n        float modValue = mod(absValue, rangeLength);\n        return mod(rangeLength - modValue, rangeLength);\n    }\n    return mod(value, rangeLength);\n}\n\nvec3 wrapVec(vec3 value, float rangeLength) {\n    return vec3(wrap(value.x, rangeLength),\n                wrap(value.y, rangeLength),\n                wrap(value.z, rangeLength));\n}\n\nvec3 random3(vec3 p) {\n    float dot1 = dot(p, vec3(127.1, 311.7, 932.8));\n    float dot2 = dot(p, vec3(269.5, 183.3, 421.4));\n    return fract(vec3(sin(dot1 - dot2), cos(dot1 * dot2), dot1 * dot2));\n}\n\n// Frequency corresponds to cell size.\n// The higher the frequency, the smaller the cell size.\nvec3 getWorleyCellPoint(vec3 centerCell, vec3 offset, float freq) {\n    vec3 cell = centerCell + offset;\n    cell = wrapVec(cell, textureSliceWidth / u_noiseDetail);\n    cell += floor(u_noiseOffset / u_noiseDetail);\n    vec3 p = offset + random3(cell);\n    return p;\n}\n\nfloat worleyNoise(vec3 p, float freq) {\n    vec3 centerCell = floor(p * freq);\n    vec3 pointInCell = fract(p * freq);\n    float shortestDistance = 1000.0;\n\n    for(float z = -1.0; z <= 1.0; z++) {\n        for(float y = -1.0; y <= 1.0; y++) {\n            for(float x = -1.0; x <= 1.0; x++) {\n                vec3 offset = vec3(x, y, z);\n                vec3 point = getWorleyCellPoint(centerCell, offset, freq);\n\n                float distance = length(pointInCell - point);\n                if(distance < shortestDistance) {\n                    shortestDistance = distance;\n                }\n            }\n        }\n    }\n\n    return shortestDistance;\n}\n\nconst float MAX_FBM_ITERATIONS = 10.0;\n\nfloat worleyFBMNoise(vec3 p, float octaves, float scale) {\n    float noise = 0.0;\n    float freq = 1.0;\n    float persistence = 0.625;\n    for(float i = 0.0; i < MAX_FBM_ITERATIONS; i++) {\n        if(i >= octaves) {\n            break;\n        }\n\n        noise += worleyNoise(p * scale, freq * scale) * persistence;\n        persistence *= 0.5;\n        freq *= 2.0;\n    }\n    return noise;\n}\n\nvoid main() {\n    float x = mod(v_position.x, textureSliceWidth);\n    float y = mod(v_position.y, textureSliceWidth);\n    float sliceRow = floor(v_position.y / textureSliceWidth);\n    float z = floor(v_position.x / textureSliceWidth) + sliceRow * inverseNoiseTextureRows * textureSliceWidth;\n\n    vec3 position = vec3(x, y, z);\n    position /= u_noiseDetail;\n    float worley0 = clamp(worleyFBMNoise(position, 3.0, 1.0), 0.0, 1.0);\n    float worley1 = clamp(worleyFBMNoise(position, 3.0, 2.0), 0.0, 1.0);\n    float worley2 = clamp(worleyFBMNoise(position, 3.0, 3.0), 0.0, 1.0);\n    gl_FragColor = vec4(worley0, worley1, worley2, 1.0);\n}\n"},"70b2":function(e,n,t){"use strict";n["a"]="varying vec4 positionEC;\n\nvoid main()\n{\n    vec3 position;\n    vec3 direction;\n    if (czm_orthographicIn3D == 1.0)\n    {\n        vec2 uv = (gl_FragCoord.xy -  czm_viewport.xy) / czm_viewport.zw;\n        vec2 minPlane = vec2(czm_frustumPlanes.z, czm_frustumPlanes.y); // left, bottom\n        vec2 maxPlane = vec2(czm_frustumPlanes.w, czm_frustumPlanes.x); // right, top\n        position = vec3(mix(minPlane, maxPlane, uv), 0.0);\n        direction = vec3(0.0, 0.0, -1.0);\n    } \n    else \n    {\n        position = vec3(0.0);\n        direction = normalize(positionEC.xyz);\n    }\n\n    czm_ray ray = czm_ray(position, direction);\n\n    vec3 ellipsoid_center = czm_view[3].xyz;\n\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);\n    if (!czm_isEmpty(intersection))\n    {\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    else\n    {\n        discard;\n    }\n\n    czm_writeLogDepth();\n}\n"},"8de3":function(e,n,t){"use strict";n["a"]="attribute vec4 position;\n\nvarying vec4 positionEC;\n\nvoid main()\n{\n    positionEC = czm_modelView * position;\n    gl_Position = czm_projection * positionEC;\n\n    czm_vertexLogDepth();\n}\n"},"9aea":function(e,n,t){"use strict";n["a"]="#ifdef INSTANCED\nattribute vec2 direction;\n#endif\nattribute vec4 positionHighAndScaleX;\nattribute vec4 positionLowAndScaleY;\nattribute vec4 packedAttribute0;\nattribute vec4 packedAttribute1;\nattribute vec4 color;\n\nvarying vec2 v_offset;\nvarying vec3 v_maximumSize;\nvarying vec4 v_color;\nvarying float v_slice;\nvarying float v_brightness;\n\nvoid main() {\n    // Unpack attributes.\n    vec3 positionHigh = positionHighAndScaleX.xyz;\n    vec3 positionLow = positionLowAndScaleY.xyz;\n    vec2 scale = vec2(positionHighAndScaleX.w, positionLowAndScaleY.w);\n\n    float show = packedAttribute0.x;\n    float brightness = packedAttribute0.y;\n    vec2 coordinates = packedAttribute0.wz;\n    vec3 maximumSize = packedAttribute1.xyz;\n    float slice = packedAttribute1.w;\n\n#ifdef INSTANCED\n    vec2 dir = direction;\n#else\n    vec2 dir = coordinates;\n#endif\n\n    vec2 offset = dir - vec2(0.5, 0.5);\n    vec2 scaledOffset = scale * offset;\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n    positionEC.xy += scaledOffset;\n    \n    positionEC.xyz *= show;\n    gl_Position = czm_projection * positionEC;\n\n    v_offset = offset;\n    v_maximumSize = maximumSize;\n    v_color = color;\n    v_slice = slice;\n    v_brightness = brightness;\n}\n"},d109:function(e,n,t){"use strict";n["a"]="uniform vec3 u_noiseTextureDimensions;\nattribute vec2 position;\n\nvarying vec2 v_position;\n\nvoid main()\n{\n    gl_Position = vec4(position, 0.1, 1.0);\n\n    float textureSliceWidth = u_noiseTextureDimensions.x;\n    float noiseTextureRows = u_noiseTextureDimensions.y;\n    float inverseNoiseTextureRows = u_noiseTextureDimensions.z;\n    vec2 transformedPos = (position * 0.5) + vec2(0.5);\n    transformedPos *= textureSliceWidth;\n    transformedPos.x *= textureSliceWidth * inverseNoiseTextureRows;\n    transformedPos.y *= noiseTextureRows;\n    v_position = transformedPos;\n}\n"},d1db:function(e,n,t){"use strict";n["a"]="uniform sampler2D u_opaqueDepthTexture;\nuniform sampler2D u_translucentDepthTexture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    float opaqueDepth = texture2D(u_opaqueDepthTexture, v_textureCoordinates).r;\n    float translucentDepth = texture2D(u_translucentDepthTexture, v_textureCoordinates).r;\n    translucentDepth = czm_branchFreeTernary(translucentDepth > opaqueDepth, 1.0, translucentDepth);\n    gl_FragColor = czm_packDepth(translucentDepth);\n}\n"},ea7f:function(e,n,t){"use strict";n["a"]="attribute vec3 position;\n\nuniform vec3 u_radii;\n\nvarying vec3 v_positionEC;\n\nvoid main()\n{\n    // In the vertex data, the cube goes from (-1.0, -1.0, -1.0) to (1.0, 1.0, 1.0) in model coordinates.\n    // Scale to consider the radii.  We could also do this once on the CPU when using the BoxGeometry,\n    // but doing it here allows us to change the radii without rewriting the vertex data, and\n    // allows all ellipsoids to reuse the same vertex data.\n    vec4 p = vec4(u_radii * position, 1.0);\n\n    v_positionEC = (czm_modelView * p).xyz;     // position in eye coordinates\n    gl_Position = czm_modelViewProjection * p;  // position in clip coordinates\n\n    // With multi-frustum, when the ellipsoid primitive is positioned on the intersection of two frustums\n    // and close to terrain, the terrain (writes depth) in the closest frustum can overwrite part of the\n    // ellipsoid (does not write depth) that was rendered in the farther frustum.\n    //\n    // Here, we clamp the depth in the vertex shader to avoid being overwritten; however, this creates\n    // artifacts since some fragments can be alpha blended twice.  This is solved by only rendering\n    // the ellipsoid in the closest frustum to the viewer.\n    gl_Position.z = clamp(gl_Position.z, czm_depthRange.near, czm_depthRange.far);\n\n    czm_vertexLogDepth();\n}\n"}}]);