(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-vendors~b812049a"],{c70c:function(t,i,o){"use strict";var a=o("8656"),e=o("85b2"),n=o("dde0"),r=o("6b82"),s=o("8d54"),c=o("1a5d"),u=o("c937"),h=o("e2a6"),l=o("7e67"),d=o("e107"),m=o("c993"),p=o("f7b5"),f=o("4b7f"),_=o("aec1"),g=o("d0db"),w=o("a61d"),C=o("7f05"),O=o("b8b5"),T=o("d767"),y=o("722e"),E=o("ec1a"),b=o("1345"),j=o("3f87"),I=o("1b9c"),W=o("430c"),v=o("4a63"),P=o("6f7c"),x=o("1f34"),M=o("d58e"),S=o("dc6c");function N(t){if(!Object(u["a"])(t))throw new h["a"]("scene is required.");this._scene=t,this._transform=y["a"].clone(y["a"].IDENTITY),this._invTransform=y["a"].clone(y["a"].IDENTITY),this._actualTransform=y["a"].clone(y["a"].IDENTITY),this._actualInvTransform=y["a"].clone(y["a"].IDENTITY),this._transformChanged=!1,this.position=new n["a"],this._position=new n["a"],this._positionWC=new n["a"],this._positionCartographic=new s["a"],this._oldPositionWC=void 0,this.positionWCDeltaMagnitude=0,this.positionWCDeltaMagnitudeLastFrame=0,this.timeSinceMoved=0,this._lastMovedTimestamp=0,this.direction=new n["a"],this._direction=new n["a"],this._directionWC=new n["a"],this.up=new n["a"],this._up=new n["a"],this._upWC=new n["a"],this.right=new n["a"],this._right=new n["a"],this._rightWC=new n["a"],this.frustum=new j["a"],this.frustum.aspectRatio=t.drawingBufferWidth/t.drawingBufferHeight,this.frustum.fov=O["a"].toRadians(60),this.defaultMoveAmount=1e5,this.defaultLookAmount=Math.PI/60,this.defaultRotateAmount=Math.PI/3600,this.defaultZoomAmount=1e5,this.constrainedAxis=void 0,this.maximumZoomFactor=1.5,this._moveStart=new p["a"],this._moveEnd=new p["a"],this._changed=new p["a"],this._changedPosition=void 0,this._changedDirection=void 0,this._changedFrustum=void 0,this._changedHeading=void 0,this.percentageChanged=.5,this._viewMatrix=new y["a"],this._invViewMatrix=new y["a"],R(this),this._mode=S["a"].SCENE3D,this._modeChanged=!0;const i=t.mapProjection;this._projection=i,this._maxCoord=i.project(new s["a"](Math.PI,O["a"].PI_OVER_TWO)),this._max2Dfrustum=void 0,oi(this,N.DEFAULT_VIEW_RECTANGLE,this.position,!0);let o=n["a"].magnitude(this.position);o+=o*N.DEFAULT_VIEW_FACTOR,n["a"].normalize(this.position,this.position),n["a"].multiplyByScalar(this.position,o,this.position)}function R(t){y["a"].computeView(t._position,t._direction,t._up,t._right,t._viewMatrix),y["a"].multiply(t._viewMatrix,t._actualInvTransform,t._viewMatrix),y["a"].inverseTransformation(t._viewMatrix,t._invViewMatrix)}function D(t){if(Object(u["a"])(t._oldPositionWC)){t.positionWCDeltaMagnitudeLastFrame=t.positionWCDeltaMagnitude;const i=n["a"].subtract(t.positionWC,t._oldPositionWC,t._oldPositionWC);t.positionWCDeltaMagnitude=n["a"].magnitude(i),t._oldPositionWC=n["a"].clone(t.positionWC,t._oldPositionWC),t.positionWCDeltaMagnitude>0?(t.timeSinceMoved=0,t._lastMovedTimestamp=Object(f["a"])()):t.timeSinceMoved=Math.max(Object(f["a"])()-t._lastMovedTimestamp,0)/1e3}else t._oldPositionWC=n["a"].clone(t.positionWC,t._oldPositionWC)}function A(t){P["a"].basisTo2D(t._projection,t._transform,t._actualTransform)}N.TRANSFORM_2D=new y["a"](0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1),N.TRANSFORM_2D_INVERSE=y["a"].inverseTransformation(N.TRANSFORM_2D,new y["a"]),N.DEFAULT_VIEW_RECTANGLE=v["a"].fromDegrees(-95,-20,-70,90),N.DEFAULT_VIEW_FACTOR=.5,N.DEFAULT_OFFSET=new _["a"](0,-O["a"].PI_OVER_FOUR,0),N.prototype.canPreloadFlight=function(){return Object(u["a"])(this._currentFlight)&&this._mode!==S["a"].SCENE2D},N.prototype._updateCameraChanged=function(){const t=this;if(D(t),0===t._changed.numberOfListeners)return;const i=t.percentageChanged,o=t.heading;Object(u["a"])(t._changedHeading)||(t._changedHeading=o);let a=Math.abs(t._changedHeading-o)%O["a"].TWO_PI;a=a>O["a"].PI?O["a"].TWO_PI-a:a;const e=a/Math.PI;if(e>i&&(t._changed.raiseEvent(e),t._changedHeading=o),t._mode===S["a"].SCENE2D){if(!Object(u["a"])(t._changedFrustum))return t._changedPosition=n["a"].clone(t.position,t._changedPosition),void(t._changedFrustum=t.frustum.clone());const o=t.position,a=t._changedPosition,e=t.frustum,r=t._changedFrustum,s=o.x+e.left,c=o.x+e.right,h=a.x+r.left,l=a.x+r.right,d=o.y+e.bottom,m=o.y+e.top,p=a.y+r.bottom,f=a.y+r.top,_=Math.max(s,h),g=Math.min(c,l),w=Math.max(d,p),C=Math.min(m,f);let O;if(_>=g||w>=m)O=1;else{let t=r;s<h&&c>l&&d<p&&m>f&&(t=e),O=1-(g-_)*(C-w)/((t.right-t.left)*(t.top-t.bottom))}return void(O>i&&(t._changed.raiseEvent(O),t._changedPosition=n["a"].clone(t.position,t._changedPosition),t._changedFrustum=t.frustum.clone(t._changedFrustum)))}if(!Object(u["a"])(t._changedDirection))return t._changedPosition=n["a"].clone(t.positionWC,t._changedPosition),void(t._changedDirection=n["a"].clone(t.directionWC,t._changedDirection));const r=O["a"].acosClamped(n["a"].dot(t.directionWC,t._changedDirection));let s;s=Object(u["a"])(t.frustum.fovy)?r/(.5*t.frustum.fovy):r;const c=n["a"].distance(t.positionWC,t._changedPosition),h=c/t.positionCartographic.height;(s>i||h>i)&&(t._changed.raiseEvent(Math.max(s,h)),t._changedPosition=n["a"].clone(t.positionWC,t._changedPosition),t._changedDirection=n["a"].clone(t.directionWC,t._changedDirection))};const F=new s["a"],V=new n["a"],B=new n["a"],L=new r["a"],z=new r["a"],U=new r["a"],q=new r["a"],k=new r["a"];function H(t){const i=t._projection,o=i.ellipsoid,a=y["a"].getColumn(t._transform,3,L),e=o.cartesianToCartographic(a,F),s=i.project(e,V),c=z;c.x=s.z,c.y=s.x,c.z=s.y,c.w=1;const u=r["a"].clone(r["a"].UNIT_X,k),h=r["a"].add(y["a"].getColumn(t._transform,0,B),a,B);o.cartesianToCartographic(h,e),i.project(e,s);const l=U;l.x=s.z,l.y=s.x,l.z=s.y,l.w=0,n["a"].subtract(l,c,l),l.x=0;const d=q;if(n["a"].magnitudeSquared(l)>O["a"].EPSILON10)n["a"].cross(u,l,d);else{const u=r["a"].add(y["a"].getColumn(t._transform,1,B),a,B);o.cartesianToCartographic(u,e),i.project(e,s),d.x=s.z,d.y=s.x,d.z=s.y,d.w=0,n["a"].subtract(d,c,d),d.x=0,n["a"].magnitudeSquared(d)<O["a"].EPSILON10&&(r["a"].clone(r["a"].UNIT_Y,l),r["a"].clone(r["a"].UNIT_Z,d))}n["a"].cross(d,u,l),n["a"].normalize(l,l),n["a"].cross(u,l,d),n["a"].normalize(d,d),y["a"].setColumn(t._actualTransform,0,l,t._actualTransform),y["a"].setColumn(t._actualTransform,1,d,t._actualTransform),y["a"].setColumn(t._actualTransform,2,u,t._actualTransform),y["a"].setColumn(t._actualTransform,3,c,t._actualTransform)}const Y=new n["a"];function G(t){const i=t._mode;let o=!1,a=0;i===S["a"].SCENE2D&&(a=t.frustum.right-t.frustum.left,o=a!==t._positionCartographic.height);let e=t._position;const r=!n["a"].equals(e,t.position)||o;r&&(e=n["a"].clone(t.position,t._position));let s=t._direction;const c=!n["a"].equals(s,t.direction);c&&(n["a"].normalize(t.direction,t.direction),s=n["a"].clone(t.direction,t._direction));let u=t._up;const h=!n["a"].equals(u,t.up);h&&(n["a"].normalize(t.up,t.up),u=n["a"].clone(t.up,t._up));let l=t._right;const d=!n["a"].equals(l,t.right);d&&(n["a"].normalize(t.right,t.right),l=n["a"].clone(t.right,t._right));const m=t._transformChanged||t._modeChanged;t._transformChanged=!1,m&&(y["a"].inverseTransformation(t._transform,t._invTransform),t._mode===S["a"].COLUMBUS_VIEW||t._mode===S["a"].SCENE2D?y["a"].equals(y["a"].IDENTITY,t._transform)?y["a"].clone(N.TRANSFORM_2D,t._actualTransform):t._mode===S["a"].COLUMBUS_VIEW?A(t):H(t):y["a"].clone(t._transform,t._actualTransform),y["a"].inverseTransformation(t._actualTransform,t._actualInvTransform),t._modeChanged=!1);const p=t._actualTransform;if(r||m)if(t._positionWC=y["a"].multiplyByPoint(p,e,t._positionWC),i===S["a"].SCENE3D||i===S["a"].MORPHING)t._positionCartographic=t._projection.ellipsoid.cartesianToCartographic(t._positionWC,t._positionCartographic);else{const o=Y;o.x=t._positionWC.y,o.y=t._positionWC.z,o.z=t._positionWC.x,i===S["a"].SCENE2D&&(o.z=a),t._projection.unproject(o,t._positionCartographic)}if(c||h||d){const i=n["a"].dot(s,n["a"].cross(u,l,Y));if(Math.abs(1-i)>O["a"].EPSILON2){const i=1/n["a"].magnitudeSquared(u),o=n["a"].dot(u,s)*i,a=n["a"].multiplyByScalar(s,o,Y);u=n["a"].normalize(n["a"].subtract(u,a,t._up),t._up),n["a"].clone(u,t.up),l=n["a"].cross(s,u,t._right),n["a"].clone(l,t.right)}}(c||m)&&(t._directionWC=y["a"].multiplyByPointAsVector(p,s,t._directionWC),n["a"].normalize(t._directionWC,t._directionWC)),(h||m)&&(t._upWC=y["a"].multiplyByPointAsVector(p,u,t._upWC),n["a"].normalize(t._upWC,t._upWC)),(d||m)&&(t._rightWC=y["a"].multiplyByPointAsVector(p,l,t._rightWC),n["a"].normalize(t._rightWC,t._rightWC)),(r||c||h||d||m)&&R(t)}function Z(t,i){let o;return o=O["a"].equalsEpsilon(Math.abs(t.z),1,O["a"].EPSILON3)?Math.atan2(i.y,i.x)-O["a"].PI_OVER_TWO:Math.atan2(t.y,t.x)-O["a"].PI_OVER_TWO,O["a"].TWO_PI-O["a"].zeroToTwoPi(o)}function X(t){return O["a"].PI_OVER_TWO-O["a"].acosClamped(t.z)}function J(t,i,o){let a=0;return O["a"].equalsEpsilon(Math.abs(t.z),1,O["a"].EPSILON3)||(a=Math.atan2(-o.z,i.z),a=O["a"].zeroToTwoPi(a+O["a"].TWO_PI)),a}const Q=new y["a"],K=new y["a"];Object.defineProperties(N.prototype,{transform:{get:function(){return this._transform}},inverseTransform:{get:function(){return G(this),this._invTransform}},viewMatrix:{get:function(){return G(this),this._viewMatrix}},inverseViewMatrix:{get:function(){return G(this),this._invViewMatrix}},positionCartographic:{get:function(){return G(this),this._positionCartographic}},positionWC:{get:function(){return G(this),this._positionWC}},directionWC:{get:function(){return G(this),this._directionWC}},upWC:{get:function(){return G(this),this._upWC}},rightWC:{get:function(){return G(this),this._rightWC}},heading:{get:function(){if(this._mode!==S["a"].MORPHING){const t=this._projection.ellipsoid,i=y["a"].clone(this._transform,Q),o=P["a"].eastNorthUpToFixedFrame(this.positionWC,t,K);this._setTransform(o);const a=Z(this.direction,this.up);return this._setTransform(i),a}}},pitch:{get:function(){if(this._mode!==S["a"].MORPHING){const t=this._projection.ellipsoid,i=y["a"].clone(this._transform,Q),o=P["a"].eastNorthUpToFixedFrame(this.positionWC,t,K);this._setTransform(o);const a=X(this.direction);return this._setTransform(i),a}}},roll:{get:function(){if(this._mode!==S["a"].MORPHING){const t=this._projection.ellipsoid,i=y["a"].clone(this._transform,Q),o=P["a"].eastNorthUpToFixedFrame(this.positionWC,t,K);this._setTransform(o);const a=J(this.direction,this.up,this.right);return this._setTransform(i),a}}},moveStart:{get:function(){return this._moveStart}},moveEnd:{get:function(){return this._moveEnd}},changed:{get:function(){return this._changed}}}),N.prototype.update=function(t){if(!Object(u["a"])(t))throw new h["a"]("mode is required.");if(t===S["a"].SCENE2D&&!(this.frustum instanceof b["a"]))throw new h["a"]("An OrthographicOffCenterFrustum is required in 2D.");if((t===S["a"].SCENE3D||t===S["a"].COLUMBUS_VIEW)&&!(this.frustum instanceof j["a"])&&!(this.frustum instanceof E["a"]))throw new h["a"]("A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view");let i=!1;if(t!==this._mode&&(this._mode=t,this._modeChanged=t!==S["a"].MORPHING,i=this._mode===S["a"].SCENE2D),i){const t=this._max2Dfrustum=this.frustum.clone();if(!(t instanceof b["a"]))throw new h["a"]("The camera frustum is expected to be orthographic for 2D camera control.");const i=2,o=t.top/t.right;t.right=this._maxCoord.x*i,t.left=-t.right,t.top=o*t.right,t.bottom=-t.top}this._mode===S["a"].SCENE2D&&Et(this,this.position)};const $=new n["a"],tt=new n["a"],it=new n["a"];N.prototype._setTransform=function(t){const i=n["a"].clone(this.positionWC,$),o=n["a"].clone(this.upWC,tt),a=n["a"].clone(this.directionWC,it);y["a"].clone(t,this._transform),this._transformChanged=!0,G(this);const e=this._actualInvTransform;y["a"].multiplyByPoint(e,i,this.position),y["a"].multiplyByPointAsVector(e,a,this.direction),y["a"].multiplyByPointAsVector(e,o,this.up),n["a"].cross(this.direction,this.up,this.right),G(this)};const ot=new e["a"],at=new W["a"],et=new n["a"],nt=new n["a"];function rt(t){if(!y["a"].equals(y["a"].IDENTITY,t.transform))return n["a"].magnitude(t.position);const i=t._scene,o=i.globe,a=ot;let e,r,s;if(a.x=i.drawingBufferWidth/2,a.y=i.drawingBufferHeight/2,Object(u["a"])(o)){const n=t.getPickRay(a,at);e=o.pickWorldCoordinates(n,i,!0,et)}if(i.pickPositionSupported&&(r=i.pickPositionWorldCoordinates(a,nt)),Object(u["a"])(e)||Object(u["a"])(r)){const i=Object(u["a"])(r)?n["a"].distance(r,t.positionWC):Number.POSITIVE_INFINITY,o=Object(u["a"])(e)?n["a"].distance(e,t.positionWC):Number.POSITIVE_INFINITY;s=Math.min(i,o)}else s=Math.max(t.positionCartographic.height,0);return s}N.prototype._adjustOrthographicFrustum=function(t){this.frustum instanceof E["a"]&&(!t&&this._positionCartographic.height<15e4||(this.frustum.width=rt(this)))};const st=new n["a"],ct=new y["a"],ut=new y["a"],ht=new I["a"],lt=new T["a"],dt=new s["a"];function mt(t,i,o){const a=y["a"].clone(t.transform,ct),e=P["a"].eastNorthUpToFixedFrame(i,t._projection.ellipsoid,ut);t._setTransform(e),n["a"].clone(n["a"].ZERO,t.position),o.heading=o.heading-O["a"].PI_OVER_TWO;const r=I["a"].fromHeadingPitchRoll(o,ht),s=T["a"].fromQuaternion(r,lt);T["a"].getColumn(s,0,t.direction),T["a"].getColumn(s,2,t.up),n["a"].cross(t.direction,t.up,t.right),t._setTransform(a),t._adjustOrthographicFrustum(!0)}function pt(t,i,o,a){const e=y["a"].clone(t.transform,ct);if(t._setTransform(y["a"].IDENTITY),!n["a"].equals(i,t.positionWC)){if(a){const o=t._projection,a=o.ellipsoid.cartesianToCartographic(i,dt);i=o.project(a,st)}n["a"].clone(i,t.position)}o.heading=o.heading-O["a"].PI_OVER_TWO;const r=I["a"].fromHeadingPitchRoll(o,ht),s=T["a"].fromQuaternion(r,lt);T["a"].getColumn(s,0,t.direction),T["a"].getColumn(s,2,t.up),n["a"].cross(t.direction,t.up,t.right),t._setTransform(e),t._adjustOrthographicFrustum(!0)}function ft(t,i,o,a){const r=y["a"].clone(t.transform,ct);if(t._setTransform(y["a"].IDENTITY),!n["a"].equals(i,t.positionWC)){if(a){const o=t._projection,a=o.ellipsoid.cartesianToCartographic(i,dt);i=o.project(a,st)}e["a"].clone(i,t.position);const o=.5*-i.z,n=-o,r=t.frustum;if(n>o){const t=r.top/r.right;r.right=n,r.left=o,r.top=r.right*t,r.bottom=-r.top}}if(t._scene.mapMode2D===M["a"].ROTATE){o.heading=o.heading-O["a"].PI_OVER_TWO,o.pitch=-O["a"].PI_OVER_TWO,o.roll=0;const i=I["a"].fromHeadingPitchRoll(o,ht),a=T["a"].fromQuaternion(i,lt);T["a"].getColumn(a,2,t.up),n["a"].cross(t.direction,t.up,t.right)}t._setTransform(r)}const _t=new n["a"],gt=new n["a"],wt=new n["a"];function Ct(t,i,o,a){const e=n["a"].clone(o.direction,_t),r=n["a"].clone(o.up,gt);if(t._scene.mode===S["a"].SCENE3D){const o=t._projection.ellipsoid,a=P["a"].eastNorthUpToFixedFrame(i,o,Q),n=y["a"].inverseTransformation(a,K);y["a"].multiplyByPointAsVector(n,e,e),y["a"].multiplyByPointAsVector(n,r,r)}const s=n["a"].cross(e,r,wt);return a.heading=Z(e,r),a.pitch=X(e),a.roll=J(e,r,s),a}const Ot={destination:void 0,orientation:{direction:void 0,up:void 0,heading:void 0,pitch:void 0,roll:void 0},convert:void 0,endTransform:void 0},Tt=new g["a"];N.prototype.setView=function(t){t=Object(c["a"])(t,c["a"].EMPTY_OBJECT);let i=Object(c["a"])(t.orientation,c["a"].EMPTY_OBJECT);const o=this._mode;if(o===S["a"].MORPHING)return;Object(u["a"])(t.endTransform)&&this._setTransform(t.endTransform);let a=Object(c["a"])(t.convert,!0),e=Object(c["a"])(t.destination,n["a"].clone(this.positionWC,st));Object(u["a"])(e)&&Object(u["a"])(e.west)&&(e=this.getRectangleCameraCoordinates(e,st),a=!1),Object(u["a"])(i.direction)&&(i=Ct(this,e,i,Ot.orientation)),Tt.heading=Object(c["a"])(i.heading,0),Tt.pitch=Object(c["a"])(i.pitch,-O["a"].PI_OVER_TWO),Tt.roll=Object(c["a"])(i.roll,0),o===S["a"].SCENE3D?mt(this,e,Tt):o===S["a"].SCENE2D?ft(this,e,Tt,a):pt(this,e,Tt,a)};const yt=new n["a"];function Et(t,i){const o=t._scene.mapMode2D===M["a"].ROTATE,a=t._maxCoord.x,e=t._maxCoord.y;let n,r;o?(r=a,n=-r):(r=i.x-2*a,n=i.x+2*a),i.x>a&&(i.x=r),i.x<-a&&(i.x=n),i.y>e&&(i.y=e),i.y<-e&&(i.y=-e)}N.prototype.flyHome=function(t){const i=this._mode;if(i===S["a"].MORPHING&&this._scene.completeMorph(),i===S["a"].SCENE2D)this.flyTo({destination:N.DEFAULT_VIEW_RECTANGLE,duration:t,endTransform:y["a"].IDENTITY});else if(i===S["a"].SCENE3D){const i=this.getRectangleCameraCoordinates(N.DEFAULT_VIEW_RECTANGLE);let o=n["a"].magnitude(i);o+=o*N.DEFAULT_VIEW_FACTOR,n["a"].normalize(i,i),n["a"].multiplyByScalar(i,o,i),this.flyTo({destination:i,duration:t,endTransform:y["a"].IDENTITY})}else if(i===S["a"].COLUMBUS_VIEW){const i=this._projection.ellipsoid.maximumRadius;let o=new n["a"](0,-1,1);o=n["a"].multiplyByScalar(n["a"].normalize(o,o),5*i,o),this.flyTo({destination:o,duration:t,orientation:{heading:0,pitch:-Math.acos(n["a"].normalize(o,yt).z),roll:0},endTransform:y["a"].IDENTITY,convert:!1})}},N.prototype.worldToCameraCoordinates=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("cartesian is required.");return Object(u["a"])(i)||(i=new r["a"]),G(this),y["a"].multiplyByVector(this._actualInvTransform,t,i)},N.prototype.worldToCameraCoordinatesPoint=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("cartesian is required.");return Object(u["a"])(i)||(i=new n["a"]),G(this),y["a"].multiplyByPoint(this._actualInvTransform,t,i)},N.prototype.worldToCameraCoordinatesVector=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("cartesian is required.");return Object(u["a"])(i)||(i=new n["a"]),G(this),y["a"].multiplyByPointAsVector(this._actualInvTransform,t,i)},N.prototype.cameraToWorldCoordinates=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("cartesian is required.");return Object(u["a"])(i)||(i=new r["a"]),G(this),y["a"].multiplyByVector(this._actualTransform,t,i)},N.prototype.cameraToWorldCoordinatesPoint=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("cartesian is required.");return Object(u["a"])(i)||(i=new n["a"]),G(this),y["a"].multiplyByPoint(this._actualTransform,t,i)},N.prototype.cameraToWorldCoordinatesVector=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("cartesian is required.");return Object(u["a"])(i)||(i=new n["a"]),G(this),y["a"].multiplyByPointAsVector(this._actualTransform,t,i)};const bt=new n["a"];N.prototype.move=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("direction is required.");const o=this.position;n["a"].multiplyByScalar(t,i,bt),n["a"].add(o,bt,o),this._mode===S["a"].SCENE2D&&Et(this,o),this._adjustOrthographicFrustum(!0)},N.prototype.moveForward=function(t){t=Object(c["a"])(t,this.defaultMoveAmount),this._mode===S["a"].SCENE2D?Dt(this,t):this.move(this.direction,t)},N.prototype.moveBackward=function(t){t=Object(c["a"])(t,this.defaultMoveAmount),this._mode===S["a"].SCENE2D?Dt(this,-t):this.move(this.direction,-t)},N.prototype.moveUp=function(t){t=Object(c["a"])(t,this.defaultMoveAmount),this.move(this.up,t)},N.prototype.moveDown=function(t){t=Object(c["a"])(t,this.defaultMoveAmount),this.move(this.up,-t)},N.prototype.moveRight=function(t){t=Object(c["a"])(t,this.defaultMoveAmount),this.move(this.right,t)},N.prototype.moveLeft=function(t){t=Object(c["a"])(t,this.defaultMoveAmount),this.move(this.right,-t)},N.prototype.lookLeft=function(t){t=Object(c["a"])(t,this.defaultLookAmount),this._mode!==S["a"].SCENE2D&&this.look(this.up,-t)},N.prototype.lookRight=function(t){t=Object(c["a"])(t,this.defaultLookAmount),this._mode!==S["a"].SCENE2D&&this.look(this.up,t)},N.prototype.lookUp=function(t){t=Object(c["a"])(t,this.defaultLookAmount),this._mode!==S["a"].SCENE2D&&this.look(this.right,-t)},N.prototype.lookDown=function(t){t=Object(c["a"])(t,this.defaultLookAmount),this._mode!==S["a"].SCENE2D&&this.look(this.right,t)};const jt=new I["a"],It=new T["a"];N.prototype.look=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("axis is required.");const o=Object(c["a"])(i,this.defaultLookAmount),a=I["a"].fromAxisAngle(t,-o,jt),e=T["a"].fromQuaternion(a,It),n=this.direction,r=this.up,s=this.right;T["a"].multiplyByVector(e,n,n),T["a"].multiplyByVector(e,r,r),T["a"].multiplyByVector(e,s,s)},N.prototype.twistLeft=function(t){t=Object(c["a"])(t,this.defaultLookAmount),this.look(this.direction,t)},N.prototype.twistRight=function(t){t=Object(c["a"])(t,this.defaultLookAmount),this.look(this.direction,-t)};const Wt=new I["a"],vt=new T["a"];N.prototype.rotate=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("axis is required.");const o=Object(c["a"])(i,this.defaultRotateAmount),a=I["a"].fromAxisAngle(t,-o,Wt),e=T["a"].fromQuaternion(a,vt);T["a"].multiplyByVector(e,this.position,this.position),T["a"].multiplyByVector(e,this.direction,this.direction),T["a"].multiplyByVector(e,this.up,this.up),n["a"].cross(this.direction,this.up,this.right),n["a"].cross(this.right,this.direction,this.up),this._adjustOrthographicFrustum(!1)},N.prototype.rotateDown=function(t){t=Object(c["a"])(t,this.defaultRotateAmount),Nt(this,t)},N.prototype.rotateUp=function(t){t=Object(c["a"])(t,this.defaultRotateAmount),Nt(this,-t)};const Pt=new n["a"],xt=new n["a"],Mt=new n["a"],St=new n["a"];function Nt(t,i){const o=t.position;if(Object(u["a"])(t.constrainedAxis)&&!n["a"].equalsEpsilon(t.position,n["a"].ZERO,O["a"].EPSILON2)){const a=n["a"].normalize(o,Pt),e=n["a"].equalsEpsilon(a,t.constrainedAxis,O["a"].EPSILON2),r=n["a"].equalsEpsilon(a,n["a"].negate(t.constrainedAxis,St),O["a"].EPSILON2);if(e||r)(e&&i<0||r&&i>0)&&t.rotate(t.right,i);else{const o=n["a"].normalize(t.constrainedAxis,xt);let e=n["a"].dot(a,o),r=O["a"].acosClamped(e);i>0&&i>r&&(i=r-O["a"].EPSILON4),e=n["a"].dot(a,n["a"].negate(o,St)),r=O["a"].acosClamped(e),i<0&&-i>r&&(i=-r+O["a"].EPSILON4);const s=n["a"].cross(o,a,Mt);t.rotate(s,i)}}else t.rotate(t.right,i)}function Rt(t,i){Object(u["a"])(t.constrainedAxis)?t.rotate(t.constrainedAxis,i):t.rotate(t.up,i)}function Dt(t,i){const o=t.frustum;if(!(o instanceof b["a"])||!Object(u["a"])(o.left)||!Object(u["a"])(o.right)||!Object(u["a"])(o.bottom)||!Object(u["a"])(o.top))throw new h["a"]("The camera frustum is expected to be orthographic for 2D camera control.");let a;if(i*=.5,Math.abs(o.top)+Math.abs(o.bottom)>Math.abs(o.left)+Math.abs(o.right)){let e=o.top-i,n=o.bottom+i,r=t._maxCoord.y;t._scene.mapMode2D===M["a"].ROTATE&&(r*=t.maximumZoomFactor),n>r&&(n=r,e=-r),e<=n&&(e=1,n=-1),a=o.right/o.top,o.top=e,o.bottom=n,o.right=o.top*a,o.left=-o.right}else{let e=o.right-i,n=o.left+i,r=t._maxCoord.x;t._scene.mapMode2D===M["a"].ROTATE&&(r*=t.maximumZoomFactor),e>r&&(e=r,n=-r),e<=n&&(e=1,n=-1),a=o.top/o.right,o.right=e,o.left=n,o.top=o.right*a,o.bottom=-o.top}}function At(t,i){t.move(t.direction,i)}N.prototype.rotateRight=function(t){t=Object(c["a"])(t,this.defaultRotateAmount),Rt(this,-t)},N.prototype.rotateLeft=function(t){t=Object(c["a"])(t,this.defaultRotateAmount),Rt(this,t)},N.prototype.zoomIn=function(t){t=Object(c["a"])(t,this.defaultZoomAmount),this._mode===S["a"].SCENE2D?Dt(this,t):At(this,t)},N.prototype.zoomOut=function(t){t=Object(c["a"])(t,this.defaultZoomAmount),this._mode===S["a"].SCENE2D?Dt(this,-t):At(this,-t)},N.prototype.getMagnitude=function(){return this._mode===S["a"].SCENE3D?n["a"].magnitude(this.position):this._mode===S["a"].COLUMBUS_VIEW?Math.abs(this.position.z):this._mode===S["a"].SCENE2D?Math.max(this.frustum.right-this.frustum.left,this.frustum.top-this.frustum.bottom):void 0};const Ft=new y["a"];N.prototype.lookAt=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("target is required");if(!Object(u["a"])(i))throw new h["a"]("offset is required");if(this._mode===S["a"].MORPHING)throw new h["a"]("lookAt is not supported while morphing.");const o=P["a"].eastNorthUpToFixedFrame(t,d["a"].WGS84,Ft);this.lookAtTransform(o,i)};const Vt=new n["a"],Bt=new I["a"],Lt=new I["a"],zt=new T["a"];function Ut(t,i,o){i=O["a"].clamp(i,-O["a"].PI_OVER_TWO,O["a"].PI_OVER_TWO),t=O["a"].zeroToTwoPi(t)-O["a"].PI_OVER_TWO;const a=I["a"].fromAxisAngle(n["a"].UNIT_Y,-i,Bt),e=I["a"].fromAxisAngle(n["a"].UNIT_Z,-t,Lt),r=I["a"].multiply(e,a,e),s=T["a"].fromQuaternion(r,zt),c=n["a"].clone(n["a"].UNIT_X,Vt);return T["a"].multiplyByVector(s,c,c),n["a"].negate(c,c),n["a"].multiplyByScalar(c,o,c),c}N.prototype.lookAtTransform=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("transform is required");if(this._mode===S["a"].MORPHING)throw new h["a"]("lookAtTransform is not supported while morphing.");if(this._setTransform(t),!Object(u["a"])(i))return;let o;if(o=Object(u["a"])(i.heading)?Ut(i.heading,i.pitch,i.range):i,this._mode===S["a"].SCENE2D){e["a"].clone(e["a"].ZERO,this.position),n["a"].negate(o,this.up),this.up.z=0,n["a"].magnitudeSquared(this.up)<O["a"].EPSILON10&&n["a"].clone(n["a"].UNIT_Y,this.up),n["a"].normalize(this.up,this.up),this._setTransform(y["a"].IDENTITY),n["a"].negate(n["a"].UNIT_Z,this.direction),n["a"].cross(this.direction,this.up,this.right),n["a"].normalize(this.right,this.right);const i=this.frustum,a=i.top/i.right;return i.right=.5*n["a"].magnitude(o),i.left=-i.right,i.top=a*i.right,i.bottom=-i.top,void this._setTransform(t)}n["a"].clone(o,this.position),n["a"].negate(this.position,this.direction),n["a"].normalize(this.direction,this.direction),n["a"].cross(this.direction,n["a"].UNIT_Z,this.right),n["a"].magnitudeSquared(this.right)<O["a"].EPSILON10&&n["a"].clone(n["a"].UNIT_X,this.right),n["a"].normalize(this.right,this.right),n["a"].cross(this.right,this.direction,this.up),n["a"].normalize(this.up,this.up),this._adjustOrthographicFrustum(!0)};const qt=new s["a"],kt=new s["a"],Ht=new n["a"],Yt=new n["a"],Gt=new n["a"],Zt=new n["a"],Xt=new n["a"],Jt=new n["a"],Qt=new n["a"],Kt=new n["a"],$t={direction:new n["a"],right:new n["a"],up:new n["a"]};let ti;function ii(t,i,o,a){const e=Math.abs(n["a"].dot(i,o));return e/a-n["a"].dot(t,o)}function oi(t,i,o,a){const e=t._projection.ellipsoid,r=a?t:$t,s=i.north,c=i.south;let h=i.east;const l=i.west;l>h&&(h+=O["a"].TWO_PI);const d=.5*(l+h);let p;if(c<-O["a"].PI_OVER_TWO+O["a"].RADIANS_PER_DEGREE&&s>O["a"].PI_OVER_TWO-O["a"].RADIANS_PER_DEGREE)p=0;else{const t=qt;t.longitude=d,t.latitude=s,t.height=0;const i=kt;i.longitude=d,i.latitude=c,i.height=0;let o=ti;Object(u["a"])(o)&&o.ellipsoid===e||(ti=o=new m["a"](void 0,void 0,e)),o.setEndPoints(t,i),p=o.interpolateUsingFraction(.5,qt).latitude}const f=qt;f.longitude=d,f.latitude=p,f.height=0;const _=e.cartographicToCartesian(f,Qt),g=qt;g.longitude=h,g.latitude=s;const w=e.cartographicToCartesian(g,Ht);g.longitude=l;const C=e.cartographicToCartesian(g,Gt);g.longitude=d;const T=e.cartographicToCartesian(g,Xt);g.latitude=c;const y=e.cartographicToCartesian(g,Jt);g.longitude=h;const b=e.cartographicToCartesian(g,Zt);g.longitude=l;const j=e.cartographicToCartesian(g,Yt);n["a"].subtract(C,_,C),n["a"].subtract(b,_,b),n["a"].subtract(w,_,w),n["a"].subtract(j,_,j),n["a"].subtract(T,_,T),n["a"].subtract(y,_,y);const I=e.geodeticSurfaceNormal(_,r.direction);n["a"].negate(I,I);const W=n["a"].cross(I,n["a"].UNIT_Z,r.right);n["a"].normalize(W,W);const v=n["a"].cross(W,I,r.up);let P;if(t.frustum instanceof E["a"]){const i=Math.max(n["a"].distance(w,C),n["a"].distance(b,j)),o=Math.max(n["a"].distance(w,b),n["a"].distance(C,j));let a,e;const r=t.frustum._offCenterFrustum.right/t.frustum._offCenterFrustum.top,s=o*r;i>s?(a=i,e=a/r):(e=o,a=s),P=Math.max(a,e)}else{const i=Math.tan(.5*t.frustum.fovy),o=t.frustum.aspectRatio*i;if(P=Math.max(ii(I,v,C,i),ii(I,v,b,i),ii(I,v,w,i),ii(I,v,j,i),ii(I,v,T,i),ii(I,v,y,i),ii(I,W,C,o),ii(I,W,b,o),ii(I,W,w,o),ii(I,W,j,o),ii(I,W,T,o),ii(I,W,y,o)),c<0&&s>0){const t=qt;t.longitude=l,t.latitude=0,t.height=0;let a=e.cartographicToCartesian(t,Kt);n["a"].subtract(a,_,a),P=Math.max(P,ii(I,v,a,i),ii(I,W,a,o)),t.longitude=h,a=e.cartographicToCartesian(t,Kt),n["a"].subtract(a,_,a),P=Math.max(P,ii(I,v,a,i),ii(I,W,a,o))}}return n["a"].add(_,n["a"].multiplyByScalar(I,-P,Kt),o)}const ai=new s["a"],ei=new n["a"],ni=new n["a"];function ri(t,i,o){const a=t._projection;i.west>i.east&&(i=v["a"].MAX_VALUE);const e=t._actualTransform,n=t._actualInvTransform,r=ai;r.longitude=i.east,r.latitude=i.north;const s=a.project(r,ei);y["a"].multiplyByPoint(e,s,s),y["a"].multiplyByPoint(n,s,s),r.longitude=i.west,r.latitude=i.south;const c=a.project(r,ni);if(y["a"].multiplyByPoint(e,c,c),y["a"].multiplyByPoint(n,c,c),o.x=.5*(s.x-c.x)+c.x,o.y=.5*(s.y-c.y)+c.y,Object(u["a"])(t.frustum.fovy)){const i=Math.tan(.5*t.frustum.fovy),a=t.frustum.aspectRatio*i;o.z=.5*Math.max((s.x-c.x)/a,(s.y-c.y)/i)}else{const t=s.x-c.x,i=s.y-c.y;o.z=Math.max(t,i)}return o}const si=new s["a"],ci=new n["a"],ui=new n["a"];function hi(t,i,o){const a=t._projection;let e=i.east;i.west>i.east&&(t._scene.mapMode2D===M["a"].INFINITE_SCROLL?e+=O["a"].TWO_PI:(i=v["a"].MAX_VALUE,e=i.east));let n=si;n.longitude=e,n.latitude=i.north;const r=a.project(n,ci);n.longitude=i.west,n.latitude=i.south;const s=a.project(n,ui),c=.5*Math.abs(r.x-s.x);let u,h,l=.5*Math.abs(r.y-s.y);const d=t.frustum.right/t.frustum.top,m=l*d;return c>m?(u=c,h=u/d):(h=l,u=m),l=Math.max(2*u,2*h),o.x=.5*(r.x-s.x)+s.x,o.y=.5*(r.y-s.y)+s.y,n=a.unproject(o,n),n.height=l,o=a.project(n,o),o}N.prototype.getRectangleCameraCoordinates=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("rectangle is required");const o=this._mode;return Object(u["a"])(i)||(i=new n["a"]),o===S["a"].SCENE3D?oi(this,t,i):o===S["a"].COLUMBUS_VIEW?ri(this,t,i):o===S["a"].SCENE2D?hi(this,t,i):void 0};const li=new W["a"];function di(t,i,o,a){o=Object(c["a"])(o,d["a"].WGS84);const e=t.getPickRay(i,li),n=C["a"].rayEllipsoid(e,o);if(!n)return;const r=n.start>0?n.start:n.stop;return W["a"].getPoint(e,r,a)}const mi=new W["a"];function pi(t,i,o,a){const e=t.getPickRay(i,mi);let r=e.origin;r=n["a"].fromElements(r.y,r.z,0,r);const s=o.unproject(r);if(!(s.latitude<-O["a"].PI_OVER_TWO||s.latitude>O["a"].PI_OVER_TWO))return o.ellipsoid.cartographicToCartesian(s,a)}const fi=new W["a"];function _i(t,i,o,a){const e=t.getPickRay(i,fi),r=-e.origin.x/e.direction.x;W["a"].getPoint(e,r,a);const s=o.unproject(new n["a"](a.y,a.z,0));if(!(s.latitude<-O["a"].PI_OVER_TWO||s.latitude>O["a"].PI_OVER_TWO||s.longitude<-Math.PI||s.longitude>Math.PI))return o.ellipsoid.cartographicToCartesian(s,a)}N.prototype.pickEllipsoid=function(t,i,o){if(!Object(u["a"])(t))throw new h["a"]("windowPosition is required.");const a=this._scene.canvas;if(0!==a.clientWidth&&0!==a.clientHeight){if(Object(u["a"])(o)||(o=new n["a"]),i=Object(c["a"])(i,d["a"].WGS84),this._mode===S["a"].SCENE3D)o=di(this,t,i,o);else if(this._mode===S["a"].SCENE2D)o=pi(this,t,this._projection,o);else{if(this._mode!==S["a"].COLUMBUS_VIEW)return;o=_i(this,t,this._projection,o)}return o}};const gi=new n["a"],wi=new n["a"],Ci=new n["a"];function Oi(t,i,o){const a=t._scene.canvas,e=a.clientWidth,r=a.clientHeight,s=Math.tan(.5*t.frustum.fovy),c=t.frustum.aspectRatio*s,u=t.frustum.near,h=2/e*i.x-1,l=2/r*(r-i.y)-1,d=t.positionWC;n["a"].clone(d,o.origin);const m=n["a"].multiplyByScalar(t.directionWC,u,gi);n["a"].add(d,m,m);const p=n["a"].multiplyByScalar(t.rightWC,h*u*c,wi),f=n["a"].multiplyByScalar(t.upWC,l*u*s,Ci),_=n["a"].add(m,p,o.direction);return n["a"].add(_,f,_),n["a"].subtract(_,d,_),n["a"].normalize(_,_),o}const Ti=new n["a"];function yi(t,i,o){const a=t._scene.canvas,e=a.clientWidth,r=a.clientHeight;let s=t.frustum;Object(u["a"])(s._offCenterFrustum)&&(s=s._offCenterFrustum);let c=2/e*i.x-1;c*=.5*(s.right-s.left);let h=2/r*(r-i.y)-1;h*=.5*(s.top-s.bottom);const l=o.origin;return n["a"].clone(t.position,l),n["a"].multiplyByScalar(t.right,c,Ti),n["a"].add(Ti,l,l),n["a"].multiplyByScalar(t.up,h,Ti),n["a"].add(Ti,l,l),n["a"].clone(t.directionWC,o.direction),t._mode!==S["a"].COLUMBUS_VIEW&&t._mode!==S["a"].SCENE2D||n["a"].fromElements(o.origin.z,o.origin.x,o.origin.y,o.origin),o}N.prototype.getPickRay=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("windowPosition is required.");Object(u["a"])(i)||(i=new W["a"]);const o=this._scene.canvas;if(o.clientWidth<=0||o.clientHeight<=0)return;const a=this.frustum;return Object(u["a"])(a.aspectRatio)&&Object(u["a"])(a.fov)&&Object(u["a"])(a.near)?Oi(this,t,i):yi(this,t,i)};const Ei=new n["a"],bi=new n["a"];N.prototype.distanceToBoundingSphere=function(t){if(!Object(u["a"])(t))throw new h["a"]("boundingSphere is required.");const i=n["a"].subtract(this.positionWC,t.center,Ei),o=n["a"].multiplyByScalar(this.directionWC,n["a"].dot(i,this.directionWC),bi);return Math.max(0,n["a"].magnitude(o)-t.radius)};const ji=new e["a"];function Ii(t,i,o,a,e,r){const s=n["a"].clone(i);function c(o){const a=n["a"].lerp(i,s,o.time,new n["a"]);t.worldToCameraCoordinatesPoint(a,t.position)}return o.y>a?s.y-=o.y-a:o.y<-a&&(s.y+=-a-o.y),o.z>e?s.z-=o.z-e:o.z<-e&&(s.z+=-e-o.z),{easingFunction:l["a"].EXPONENTIAL_OUT,startObject:{time:0},stopObject:{time:1},duration:r,update:c}}N.prototype.getPixelSize=function(t,i,o){if(!Object(u["a"])(t))throw new h["a"]("boundingSphere is required.");if(!Object(u["a"])(i))throw new h["a"]("drawingBufferWidth is required.");if(!Object(u["a"])(o))throw new h["a"]("drawingBufferHeight is required.");const a=this.distanceToBoundingSphere(t),e=this.frustum.getPixelDimensions(i,o,a,this._scene.pixelRatio,ji);return Math.max(e.x,e.y)};const Wi=new n["a"],vi=new n["a"],Pi=new n["a"],xi=new n["a"];function Mi(t,i){let o=t.position;const a=t.direction,e=t.worldToCameraCoordinatesVector(n["a"].UNIT_X,Wi),r=-n["a"].dot(e,o)/n["a"].dot(e,a),s=n["a"].add(o,n["a"].multiplyByScalar(a,r,vi),vi);t.cameraToWorldCoordinatesPoint(s,s),o=t.cameraToWorldCoordinatesPoint(t.position,Pi);const c=Math.tan(.5*t.frustum.fovy),u=t.frustum.aspectRatio*c,h=n["a"].magnitude(n["a"].subtract(o,s,xi)),l=u*h,d=c*h,m=t._maxCoord.x,p=t._maxCoord.y,f=Math.max(l-m,m),_=Math.max(d-p,p);if(o.z<-f||o.z>f||o.y<-_||o.y>_){const a=s.y<-f||s.y>f,e=s.z<-_||s.z>_;if(a||e)return Ii(t,o,s,f,_,i)}}N.prototype.createCorrectPositionTween=function(t){if(!Object(u["a"])(t))throw new h["a"]("duration is required.");if(this._mode===S["a"].COLUMBUS_VIEW)return Mi(this,t)};const Si=new n["a"],Ni={destination:void 0,heading:void 0,pitch:void 0,roll:void 0,duration:void 0,complete:void 0,cancel:void 0,endTransform:void 0,maximumHeight:void 0,easingFunction:void 0};function Ri(t,i){const o=t.frustum,a=Math.tan(.5*o.fovy),e=o.aspectRatio*a;return Math.max(i/e,i/a)}function Di(t,i){let o,a,e=t.frustum;Object(u["a"])(e._offCenterFrustum)&&(e=e._offCenterFrustum);const n=e.right/e.top,r=i*n;return i>r?(o=i,a=o/n):(a=i,o=r),1.5*Math.max(o,a)}N.prototype.cancelFlight=function(){Object(u["a"])(this._currentFlight)&&(this._currentFlight.cancelTween(),this._currentFlight=void 0)},N.prototype.completeFlight=function(){if(Object(u["a"])(this._currentFlight)){this._currentFlight.cancelTween();const t={destination:void 0,orientation:{heading:void 0,pitch:void 0,roll:void 0}};t.destination=Ni.destination,t.orientation.heading=Ni.heading,t.orientation.pitch=Ni.pitch,t.orientation.roll=Ni.roll,this.setView(t),Object(u["a"])(this._currentFlight.complete)&&this._currentFlight.complete(),this._currentFlight=void 0}},N.prototype.flyTo=function(t){t=Object(c["a"])(t,c["a"].EMPTY_OBJECT);let i=t.destination;if(!Object(u["a"])(i))throw new h["a"]("destination is required.");const o=this._mode;if(o===S["a"].MORPHING)return;this.cancelFlight();let a=Object(c["a"])(t.orientation,c["a"].EMPTY_OBJECT);if(Object(u["a"])(a.direction)&&(a=Ct(this,i,a,Ot.orientation)),Object(u["a"])(t.duration)&&t.duration<=0){const i=Ot;return i.destination=t.destination,i.orientation.heading=a.heading,i.orientation.pitch=a.pitch,i.orientation.roll=a.roll,i.convert=t.convert,i.endTransform=t.endTransform,this.setView(i),void("function"===typeof t.complete&&t.complete())}const e=Object(u["a"])(i.west);e&&(i=this.getRectangleCameraCoordinates(i,Si));const n=this;let r;Ni.destination=i,Ni.heading=a.heading,Ni.pitch=a.pitch,Ni.roll=a.roll,Ni.duration=t.duration,Ni.complete=function(){r===n._currentFlight&&(n._currentFlight=void 0),Object(u["a"])(t.complete)&&t.complete()},Ni.cancel=t.cancel,Ni.endTransform=t.endTransform,Ni.convert=!e&&t.convert,Ni.maximumHeight=t.maximumHeight,Ni.pitchAdjustHeight=t.pitchAdjustHeight,Ni.flyOverLongitude=t.flyOverLongitude,Ni.flyOverLongitudeWeight=t.flyOverLongitudeWeight,Ni.easingFunction=t.easingFunction;const s=this._scene,l=x["a"].createTween(s,Ni);if(0===l.duration)return void("function"===typeof l.complete&&l.complete());r=s.tweens.add(l),this._currentFlight=r;let d=this._scene.preloadFlightCamera;this._mode!==S["a"].SCENE2D&&(Object(u["a"])(d)||(d=N.clone(this)),d.setView({destination:i,orientation:a}),this._scene.preloadFlightCullingVolume=d.frustum.computeCullingVolume(d.positionWC,d.directionWC,d.upWC))};const Ai=100;function Fi(t,i,o){o=_["a"].clone(Object(u["a"])(o)?o:N.DEFAULT_OFFSET);const a=t._scene.screenSpaceCameraController.minimumZoomDistance,e=t._scene.screenSpaceCameraController.maximumZoomDistance,n=o.range;if(!Object(u["a"])(n)||0===n){const n=i.radius;0===n?o.range=Ai:t.frustum instanceof E["a"]||t._mode===S["a"].SCENE2D?o.range=Di(t,n):o.range=Ri(t,n),o.range=O["a"].clamp(o.range,a,e)}return o}N.prototype.viewBoundingSphere=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("boundingSphere is required.");if(this._mode===S["a"].MORPHING)throw new h["a"]("viewBoundingSphere is not supported while morphing.");i=Fi(this,t,i),this.lookAt(t.center,i)};const Vi=new y["a"],Bi=new n["a"],Li=new n["a"],zi=new n["a"],Ui=new n["a"],qi=new r["a"],ki=new I["a"],Hi=new T["a"];N.prototype.flyToBoundingSphere=function(t,i){if(!Object(u["a"])(t))throw new h["a"]("boundingSphere is required.");i=Object(c["a"])(i,c["a"].EMPTY_OBJECT);const o=this._mode===S["a"].SCENE2D||this._mode===S["a"].COLUMBUS_VIEW;this._setTransform(y["a"].IDENTITY);const a=Fi(this,t,i.offset);let e;e=o?n["a"].multiplyByScalar(n["a"].UNIT_Z,a.range,Bi):Ut(a.heading,a.pitch,a.range);const r=P["a"].eastNorthUpToFixedFrame(t.center,d["a"].WGS84,Vi);let s,l;if(y["a"].multiplyByPoint(r,e,e),!o){if(s=n["a"].subtract(t.center,e,Li),n["a"].normalize(s,s),l=y["a"].multiplyByPointAsVector(r,n["a"].UNIT_Z,zi),1-Math.abs(n["a"].dot(s,l))<O["a"].EPSILON6){const t=I["a"].fromAxisAngle(s,a.heading,ki),i=T["a"].fromQuaternion(t,Hi);n["a"].fromCartesian4(y["a"].getColumn(r,1,qi),l),T["a"].multiplyByVector(i,l,l)}const i=n["a"].cross(s,l,Ui);n["a"].cross(i,s,l),n["a"].normalize(l,l)}this.flyTo({destination:e,orientation:{direction:s,up:l},duration:i.duration,complete:i.complete,cancel:i.cancel,endTransform:i.endTransform,maximumHeight:i.maximumHeight,easingFunction:i.easingFunction,flyOverLongitude:i.flyOverLongitude,flyOverLongitudeWeight:i.flyOverLongitudeWeight,pitchAdjustHeight:i.pitchAdjustHeight})};const Yi=new n["a"],Gi=new n["a"],Zi=new n["a"],Xi=new n["a"],Ji=[new n["a"],new n["a"],new n["a"],new n["a"]];function Qi(t,i){const o=i.radii,a=t.positionWC,e=n["a"].multiplyComponents(i.oneOverRadii,a,Yi),r=n["a"].magnitude(e),s=n["a"].normalize(e,Gi);let c,u;n["a"].equalsEpsilon(s,n["a"].UNIT_Z,O["a"].EPSILON10)?(c=new n["a"](0,1,0),u=new n["a"](0,0,1)):(c=n["a"].normalize(n["a"].cross(n["a"].UNIT_Z,s,Zi),Zi),u=n["a"].normalize(n["a"].cross(s,c,Xi),Xi));const h=Math.sqrt(n["a"].magnitudeSquared(e)-1),l=n["a"].multiplyByScalar(s,1/r,Yi),d=h/r,m=n["a"].multiplyByScalar(c,d,Gi),p=n["a"].multiplyByScalar(u,d,Zi),f=n["a"].add(l,p,Ji[0]);n["a"].subtract(f,m,f),n["a"].multiplyComponents(o,f,f);const _=n["a"].subtract(l,p,Ji[1]);n["a"].subtract(_,m,_),n["a"].multiplyComponents(o,_,_);const g=n["a"].subtract(l,p,Ji[2]);n["a"].add(g,m,g),n["a"].multiplyComponents(o,g,g);const w=n["a"].add(l,p,Ji[3]);return n["a"].add(w,m,w),n["a"].multiplyComponents(o,w,w),Ji}const Ki=new e["a"],$i=new n["a"],to=[new s["a"],new s["a"],new s["a"],new s["a"]];function io(t,i,o,a,e,n){Ki.x=t,Ki.y=i;const r=a.pickEllipsoid(Ki,e,$i);return Object(u["a"])(r)?(to[o]=e.cartesianToCartographic(r,to[o]),1):(to[o]=e.cartesianToCartographic(n[o],to[o]),0)}N.prototype.computeViewRectangle=function(t,i){t=Object(c["a"])(t,d["a"].WGS84);const o=this.frustum.computeCullingVolume(this.positionWC,this.directionWC,this.upWC),e=new a["a"](n["a"].ZERO,t.maximumRadius),r=o.computeVisibility(e);if(r===w["a"].OUTSIDE)return;const s=this._scene.canvas,u=s.clientWidth,h=s.clientHeight;let l=0;const m=Qi(this,t);if(l+=io(0,0,0,this,t,m),l+=io(0,h,1,this,t,m),l+=io(u,h,2,this,t,m),l+=io(u,0,3,this,t,m),l<2)return v["a"].MAX_VALUE;i=v["a"].fromCartographicArray(to,i);let p=0,f=to[3].longitude;for(let a=0;a<4;++a){const t=to[a].longitude,i=Math.abs(t-f);i>O["a"].PI?p+=O["a"].TWO_PI-i:p+=i,f=t}return O["a"].equalsEpsilon(Math.abs(p),O["a"].TWO_PI,O["a"].EPSILON9)&&(i.west=-O["a"].PI,i.east=O["a"].PI,to[0].latitude>=0?i.north=O["a"].PI_OVER_TWO:i.south=-O["a"].PI_OVER_TWO),i},N.prototype.switchToPerspectiveFrustum=function(){if(this._mode===S["a"].SCENE2D||this.frustum instanceof j["a"])return;const t=this._scene;this.frustum=new j["a"],this.frustum.aspectRatio=t.drawingBufferWidth/t.drawingBufferHeight,this.frustum.fov=O["a"].toRadians(60)},N.prototype.switchToOrthographicFrustum=function(){if(this._mode===S["a"].SCENE2D||this.frustum instanceof E["a"])return;const t=rt(this),i=this._scene;this.frustum=new E["a"],this.frustum.aspectRatio=i.drawingBufferWidth/i.drawingBufferHeight,this.frustum.width=t},N.clone=function(t,i){return Object(u["a"])(i)||(i=new N(t._scene)),n["a"].clone(t.position,i.position),n["a"].clone(t.direction,i.direction),n["a"].clone(t.up,i.up),n["a"].clone(t.right,i.right),y["a"].clone(t._transform,i.transform),i._transformChanged=!0,i.frustum=t.frustum.clone(),i},i["a"]=N}}]);