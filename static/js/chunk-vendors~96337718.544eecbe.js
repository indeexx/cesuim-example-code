(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-vendors~96337718"],{"2c2c":function(t,e,a){"use strict";var n=a("9dc9"),o=a("8656"),r=a("dde0"),i=a("8d54"),s=a("cbf0"),c=a("1a5d"),u=a("c937"),l=a("e2a6"),h=a("e107"),g=a("5a72"),f=a("f3a4"),p=a("0c02"),d=a("e148"),b=a("2642"),O=a("b8b5"),m=a("97ea"),w=a("82ba"),_=a("4a63"),y=a("583e");const A=new o["a"],j=new o["a"],E=new r["a"],P=new _["a"];function v(t,e){const a=t._ellipsoid,n=e.height,o=e.width,r=e.northCap,i=e.southCap;let c=n,u=2,l=0,h=4;r&&(u-=1,c-=1,l+=1,h-=2),i&&(u-=1,c-=1,l+=1,h-=2),l+=u*o+2*c-h;const d=new Float64Array(3*l);let O,m=0,_=0;const A=E;if(r)y["a"].computePosition(e,a,!1,_,0,A),d[m++]=A.x,d[m++]=A.y,d[m++]=A.z;else for(O=0;O<o;O++)y["a"].computePosition(e,a,!1,_,O,A),d[m++]=A.x,d[m++]=A.y,d[m++]=A.z;for(O=o-1,_=1;_<n;_++)y["a"].computePosition(e,a,!1,_,O,A),d[m++]=A.x,d[m++]=A.y,d[m++]=A.z;if(_=n-1,!i)for(O=o-2;O>=0;O--)y["a"].computePosition(e,a,!1,_,O,A),d[m++]=A.x,d[m++]=A.y,d[m++]=A.z;for(O=0,_=n-2;_>0;_--)y["a"].computePosition(e,a,!1,_,O,A),d[m++]=A.x,d[m++]=A.y,d[m++]=A.z;const j=d.length/3*2,P=b["a"].createTypedArray(d.length/3,j);let v=0;for(let s=0;s<d.length/3-1;s++)P[v++]=s,P[v++]=s+1;P[v++]=d.length/3-1,P[v++]=0;const T=new g["a"]({attributes:new p["a"],primitiveType:w["a"].LINES});return T.attributes.position=new f["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:d}),T.indices=P,T}function T(t,e){const a=t._surfaceHeight,n=t._extrudedHeight,o=t._ellipsoid,r=n,i=a,s=v(t,e),c=e.height,u=e.width,l=m["a"].scaleToGeodeticHeight(s.attributes.position.values,i,o,!1);let h=l.length;const g=new Float64Array(2*h);g.set(l);const f=m["a"].scaleToGeodeticHeight(s.attributes.position.values,r,o);g.set(f,h),s.attributes.position.values=g;const p=e.northCap,d=e.southCap;let O=4;p&&(O-=1),d&&(O-=1);const w=2*(g.length/3+O),_=b["a"].createTypedArray(g.length/3,w);h=g.length/6;let y,A=0;for(let b=0;b<h-1;b++)_[A++]=b,_[A++]=b+1,_[A++]=b+h,_[A++]=b+h+1;if(_[A++]=h-1,_[A++]=0,_[A++]=h+h-1,_[A++]=h,_[A++]=0,_[A++]=h,p)y=c-1;else{const t=u-1;_[A++]=t,_[A++]=t+h,y=u+c-2}if(_[A++]=y,_[A++]=y+h,!d){const t=u+y-1;_[A++]=t,_[A]=t+h}return s.indices=_,s}function x(t){t=Object(c["a"])(t,c["a"].EMPTY_OBJECT);const e=t.rectangle,a=Object(c["a"])(t.granularity,O["a"].RADIANS_PER_DEGREE),n=Object(c["a"])(t.ellipsoid,h["a"].WGS84),o=Object(c["a"])(t.rotation,0);if(!Object(u["a"])(e))throw new l["a"]("rectangle is required.");if(_["a"].validate(e),e.north<e.south)throw new l["a"]("options.rectangle.north must be greater than options.rectangle.south");const r=Object(c["a"])(t.height,0),i=Object(c["a"])(t.extrudedHeight,r);this._rectangle=_["a"].clone(e),this._granularity=a,this._ellipsoid=n,this._surfaceHeight=Math.max(r,i),this._rotation=o,this._extrudedHeight=Math.min(r,i),this._offsetAttribute=t.offsetAttribute,this._workerName="createRectangleOutlineGeometry"}x.packedLength=_["a"].packedLength+h["a"].packedLength+5,x.pack=function(t,e,a){if(!Object(u["a"])(t))throw new l["a"]("value is required");if(!Object(u["a"])(e))throw new l["a"]("array is required");return a=Object(c["a"])(a,0),_["a"].pack(t._rectangle,e,a),a+=_["a"].packedLength,h["a"].pack(t._ellipsoid,e,a),a+=h["a"].packedLength,e[a++]=t._granularity,e[a++]=t._surfaceHeight,e[a++]=t._rotation,e[a++]=t._extrudedHeight,e[a]=Object(c["a"])(t._offsetAttribute,-1),e};const M=new _["a"],I=h["a"].clone(h["a"].UNIT_SPHERE),R={rectangle:M,ellipsoid:I,granularity:void 0,height:void 0,rotation:void 0,extrudedHeight:void 0,offsetAttribute:void 0};x.unpack=function(t,e,a){if(!Object(u["a"])(t))throw new l["a"]("array is required");e=Object(c["a"])(e,0);const n=_["a"].unpack(t,e,M);e+=_["a"].packedLength;const o=h["a"].unpack(t,e,I);e+=h["a"].packedLength;const r=t[e++],i=t[e++],s=t[e++],g=t[e++],f=t[e];return Object(u["a"])(a)?(a._rectangle=_["a"].clone(n,a._rectangle),a._ellipsoid=h["a"].clone(o,a._ellipsoid),a._surfaceHeight=i,a._rotation=s,a._extrudedHeight=g,a._offsetAttribute=-1===f?void 0:f,a):(R.granularity=r,R.height=i,R.rotation=s,R.extrudedHeight=g,R.offsetAttribute=-1===f?void 0:f,new x(R))};const L=new i["a"];x.createGeometry=function(t){const e=t._rectangle,a=t._ellipsoid,r=y["a"].computeOptions(e,t._granularity,t._rotation,0,P,L);let i,c;if(O["a"].equalsEpsilon(e.north,e.south,O["a"].EPSILON10)||O["a"].equalsEpsilon(e.east,e.west,O["a"].EPSILON10))return;const l=t._surfaceHeight,h=t._extrudedHeight,p=!O["a"].equalsEpsilon(l,h,0,O["a"].EPSILON2);let b;if(p){if(i=T(t,r),Object(u["a"])(t._offsetAttribute)){const e=i.attributes.position.values.length/3;let a=new Uint8Array(e);t._offsetAttribute===d["a"].TOP?a=Object(n["a"])(a,1,0,e/2):(b=t._offsetAttribute===d["a"].NONE?0:1,a=Object(n["a"])(a,b)),i.attributes.applyOffset=new f["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}const g=o["a"].fromRectangle3D(e,a,l,j),p=o["a"].fromRectangle3D(e,a,h,A);c=o["a"].union(g,p)}else{if(i=v(t,r),i.attributes.position.values=m["a"].scaleToGeodeticHeight(i.attributes.position.values,l,a,!1),Object(u["a"])(t._offsetAttribute)){const e=i.attributes.position.values.length,a=new Uint8Array(e/3);b=t._offsetAttribute===d["a"].NONE?0:1,Object(n["a"])(a,b),i.attributes.applyOffset=new f["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}c=o["a"].fromRectangle3D(e,a,l)}return new g["a"]({attributes:i.attributes,indices:i.indices,primitiveType:w["a"].LINES,boundingSphere:c,offsetAttribute:t._offsetAttribute})},e["a"]=x},"430c":function(t,e,a){"use strict";var n=a("dde0"),o=a("ae9b"),r=a("1a5d"),i=a("c937");function s(t,e){e=n["a"].clone(Object(r["a"])(e,n["a"].ZERO)),n["a"].equals(e,n["a"].ZERO)||n["a"].normalize(e,e),this.origin=n["a"].clone(Object(r["a"])(t,n["a"].ZERO)),this.direction=e}s.clone=function(t,e){if(Object(i["a"])(t))return Object(i["a"])(e)?(e.origin=n["a"].clone(t.origin),e.direction=n["a"].clone(t.direction),e):new s(t.origin,t.direction)},s.getPoint=function(t,e,a){return o["a"].typeOf.object("ray",t),o["a"].typeOf.number("t",e),Object(i["a"])(a)||(a=new n["a"]),a=n["a"].multiplyByScalar(t.direction,e,a),n["a"].add(t.origin,a,a)},e["a"]=s},"4a63":function(t,e,a){"use strict";var n=a("8d54"),o=a("ae9b"),r=a("1a5d"),i=a("c937"),s=a("e107"),c=a("b8b5");function u(t,e,a,n){this.west=Object(r["a"])(t,0),this.south=Object(r["a"])(e,0),this.east=Object(r["a"])(a,0),this.north=Object(r["a"])(n,0)}Object.defineProperties(u.prototype,{width:{get:function(){return u.computeWidth(this)}},height:{get:function(){return u.computeHeight(this)}}}),u.packedLength=4,u.pack=function(t,e,a){return o["a"].typeOf.object("value",t),o["a"].defined("array",e),a=Object(r["a"])(a,0),e[a++]=t.west,e[a++]=t.south,e[a++]=t.east,e[a]=t.north,e},u.unpack=function(t,e,a){return o["a"].defined("array",t),e=Object(r["a"])(e,0),Object(i["a"])(a)||(a=new u),a.west=t[e++],a.south=t[e++],a.east=t[e++],a.north=t[e],a},u.computeWidth=function(t){o["a"].typeOf.object("rectangle",t);let e=t.east;const a=t.west;return e<a&&(e+=c["a"].TWO_PI),e-a},u.computeHeight=function(t){return o["a"].typeOf.object("rectangle",t),t.north-t.south},u.fromDegrees=function(t,e,a,n,o){return t=c["a"].toRadians(Object(r["a"])(t,0)),e=c["a"].toRadians(Object(r["a"])(e,0)),a=c["a"].toRadians(Object(r["a"])(a,0)),n=c["a"].toRadians(Object(r["a"])(n,0)),Object(i["a"])(o)?(o.west=t,o.south=e,o.east=a,o.north=n,o):new u(t,e,a,n)},u.fromRadians=function(t,e,a,n,o){return Object(i["a"])(o)?(o.west=Object(r["a"])(t,0),o.south=Object(r["a"])(e,0),o.east=Object(r["a"])(a,0),o.north=Object(r["a"])(n,0),o):new u(t,e,a,n)},u.fromCartographicArray=function(t,e){o["a"].defined("cartographics",t);let a=Number.MAX_VALUE,n=-Number.MAX_VALUE,r=Number.MAX_VALUE,s=-Number.MAX_VALUE,l=Number.MAX_VALUE,h=-Number.MAX_VALUE;for(let o=0,i=t.length;o<i;o++){const e=t[o];a=Math.min(a,e.longitude),n=Math.max(n,e.longitude),l=Math.min(l,e.latitude),h=Math.max(h,e.latitude);const i=e.longitude>=0?e.longitude:e.longitude+c["a"].TWO_PI;r=Math.min(r,i),s=Math.max(s,i)}return n-a>s-r&&(a=r,n=s,n>c["a"].PI&&(n-=c["a"].TWO_PI),a>c["a"].PI&&(a-=c["a"].TWO_PI)),Object(i["a"])(e)?(e.west=a,e.south=l,e.east=n,e.north=h,e):new u(a,l,n,h)},u.fromCartesianArray=function(t,e,a){o["a"].defined("cartesians",t),e=Object(r["a"])(e,s["a"].WGS84);let n=Number.MAX_VALUE,l=-Number.MAX_VALUE,h=Number.MAX_VALUE,g=-Number.MAX_VALUE,f=Number.MAX_VALUE,p=-Number.MAX_VALUE;for(let o=0,r=t.length;o<r;o++){const a=e.cartesianToCartographic(t[o]);n=Math.min(n,a.longitude),l=Math.max(l,a.longitude),f=Math.min(f,a.latitude),p=Math.max(p,a.latitude);const r=a.longitude>=0?a.longitude:a.longitude+c["a"].TWO_PI;h=Math.min(h,r),g=Math.max(g,r)}return l-n>g-h&&(n=h,l=g,l>c["a"].PI&&(l-=c["a"].TWO_PI),n>c["a"].PI&&(n-=c["a"].TWO_PI)),Object(i["a"])(a)?(a.west=n,a.south=f,a.east=l,a.north=p,a):new u(n,f,l,p)},u.clone=function(t,e){if(Object(i["a"])(t))return Object(i["a"])(e)?(e.west=t.west,e.south=t.south,e.east=t.east,e.north=t.north,e):new u(t.west,t.south,t.east,t.north)},u.equalsEpsilon=function(t,e,a){return a=Object(r["a"])(a,0),t===e||Object(i["a"])(t)&&Object(i["a"])(e)&&Math.abs(t.west-e.west)<=a&&Math.abs(t.south-e.south)<=a&&Math.abs(t.east-e.east)<=a&&Math.abs(t.north-e.north)<=a},u.prototype.clone=function(t){return u.clone(this,t)},u.prototype.equals=function(t){return u.equals(this,t)},u.equals=function(t,e){return t===e||Object(i["a"])(t)&&Object(i["a"])(e)&&t.west===e.west&&t.south===e.south&&t.east===e.east&&t.north===e.north},u.prototype.equalsEpsilon=function(t,e){return u.equalsEpsilon(this,t,e)},u.validate=function(t){o["a"].typeOf.object("rectangle",t);const e=t.north;o["a"].typeOf.number.greaterThanOrEquals("north",e,-c["a"].PI_OVER_TWO),o["a"].typeOf.number.lessThanOrEquals("north",e,c["a"].PI_OVER_TWO);const a=t.south;o["a"].typeOf.number.greaterThanOrEquals("south",a,-c["a"].PI_OVER_TWO),o["a"].typeOf.number.lessThanOrEquals("south",a,c["a"].PI_OVER_TWO);const n=t.west;o["a"].typeOf.number.greaterThanOrEquals("west",n,-Math.PI),o["a"].typeOf.number.lessThanOrEquals("west",n,Math.PI);const r=t.east;o["a"].typeOf.number.greaterThanOrEquals("east",r,-Math.PI),o["a"].typeOf.number.lessThanOrEquals("east",r,Math.PI)},u.southwest=function(t,e){return o["a"].typeOf.object("rectangle",t),Object(i["a"])(e)?(e.longitude=t.west,e.latitude=t.south,e.height=0,e):new n["a"](t.west,t.south)},u.northwest=function(t,e){return o["a"].typeOf.object("rectangle",t),Object(i["a"])(e)?(e.longitude=t.west,e.latitude=t.north,e.height=0,e):new n["a"](t.west,t.north)},u.northeast=function(t,e){return o["a"].typeOf.object("rectangle",t),Object(i["a"])(e)?(e.longitude=t.east,e.latitude=t.north,e.height=0,e):new n["a"](t.east,t.north)},u.southeast=function(t,e){return o["a"].typeOf.object("rectangle",t),Object(i["a"])(e)?(e.longitude=t.east,e.latitude=t.south,e.height=0,e):new n["a"](t.east,t.south)},u.center=function(t,e){o["a"].typeOf.object("rectangle",t);let a=t.east;const r=t.west;a<r&&(a+=c["a"].TWO_PI);const s=c["a"].negativePiToPi(.5*(r+a)),u=.5*(t.south+t.north);return Object(i["a"])(e)?(e.longitude=s,e.latitude=u,e.height=0,e):new n["a"](s,u)},u.intersection=function(t,e,a){o["a"].typeOf.object("rectangle",t),o["a"].typeOf.object("otherRectangle",e);let n=t.east,r=t.west,s=e.east,l=e.west;n<r&&s>0?n+=c["a"].TWO_PI:s<l&&n>0&&(s+=c["a"].TWO_PI),n<r&&l<0?l+=c["a"].TWO_PI:s<l&&r<0&&(r+=c["a"].TWO_PI);const h=c["a"].negativePiToPi(Math.max(r,l)),g=c["a"].negativePiToPi(Math.min(n,s));if((t.west<t.east||e.west<e.east)&&g<=h)return;const f=Math.max(t.south,e.south),p=Math.min(t.north,e.north);return f>=p?void 0:Object(i["a"])(a)?(a.west=h,a.south=f,a.east=g,a.north=p,a):new u(h,f,g,p)},u.simpleIntersection=function(t,e,a){o["a"].typeOf.object("rectangle",t),o["a"].typeOf.object("otherRectangle",e);const n=Math.max(t.west,e.west),r=Math.max(t.south,e.south),s=Math.min(t.east,e.east),c=Math.min(t.north,e.north);if(!(r>=c||n>=s))return Object(i["a"])(a)?(a.west=n,a.south=r,a.east=s,a.north=c,a):new u(n,r,s,c)},u.union=function(t,e,a){o["a"].typeOf.object("rectangle",t),o["a"].typeOf.object("otherRectangle",e),Object(i["a"])(a)||(a=new u);let n=t.east,r=t.west,s=e.east,l=e.west;n<r&&s>0?n+=c["a"].TWO_PI:s<l&&n>0&&(s+=c["a"].TWO_PI),n<r&&l<0?l+=c["a"].TWO_PI:s<l&&r<0&&(r+=c["a"].TWO_PI);const h=c["a"].negativePiToPi(Math.min(r,l)),g=c["a"].negativePiToPi(Math.max(n,s));return a.west=h,a.south=Math.min(t.south,e.south),a.east=g,a.north=Math.max(t.north,e.north),a},u.expand=function(t,e,a){return o["a"].typeOf.object("rectangle",t),o["a"].typeOf.object("cartographic",e),Object(i["a"])(a)||(a=new u),a.west=Math.min(t.west,e.longitude),a.south=Math.min(t.south,e.latitude),a.east=Math.max(t.east,e.longitude),a.north=Math.max(t.north,e.latitude),a},u.contains=function(t,e){o["a"].typeOf.object("rectangle",t),o["a"].typeOf.object("cartographic",e);let a=e.longitude;const n=e.latitude,r=t.west;let i=t.east;return i<r&&(i+=c["a"].TWO_PI,a<0&&(a+=c["a"].TWO_PI)),(a>r||c["a"].equalsEpsilon(a,r,c["a"].EPSILON14))&&(a<i||c["a"].equalsEpsilon(a,i,c["a"].EPSILON14))&&n>=t.south&&n<=t.north};const l=new n["a"];u.subsample=function(t,e,a,n){o["a"].typeOf.object("rectangle",t),e=Object(r["a"])(e,s["a"].WGS84),a=Object(r["a"])(a,0),Object(i["a"])(n)||(n=[]);let h=0;const g=t.north,f=t.south,p=t.east,d=t.west,b=l;b.height=a,b.longitude=d,b.latitude=g,n[h]=e.cartographicToCartesian(b,n[h]),h++,b.longitude=p,n[h]=e.cartographicToCartesian(b,n[h]),h++,b.latitude=f,n[h]=e.cartographicToCartesian(b,n[h]),h++,b.longitude=d,n[h]=e.cartographicToCartesian(b,n[h]),h++,b.latitude=g<0?g:f>0?f:0;for(let o=1;o<8;++o)b.longitude=-Math.PI+o*c["a"].PI_OVER_TWO,u.contains(t,b)&&(n[h]=e.cartographicToCartesian(b,n[h]),h++);return 0===b.latitude&&(b.longitude=d,n[h]=e.cartographicToCartesian(b,n[h]),h++,b.longitude=p,n[h]=e.cartographicToCartesian(b,n[h]),h++),n.length=h,n},u.subsection=function(t,e,a,n,r,s){if(o["a"].typeOf.object("rectangle",t),o["a"].typeOf.number.greaterThanOrEquals("westLerp",e,0),o["a"].typeOf.number.lessThanOrEquals("westLerp",e,1),o["a"].typeOf.number.greaterThanOrEquals("southLerp",a,0),o["a"].typeOf.number.lessThanOrEquals("southLerp",a,1),o["a"].typeOf.number.greaterThanOrEquals("eastLerp",n,0),o["a"].typeOf.number.lessThanOrEquals("eastLerp",n,1),o["a"].typeOf.number.greaterThanOrEquals("northLerp",r,0),o["a"].typeOf.number.lessThanOrEquals("northLerp",r,1),o["a"].typeOf.number.lessThanOrEquals("westLerp",e,n),o["a"].typeOf.number.lessThanOrEquals("southLerp",a,r),Object(i["a"])(s)||(s=new u),t.west<=t.east){const a=t.east-t.west;s.west=t.west+e*a,s.east=t.west+n*a}else{const a=c["a"].TWO_PI+t.east-t.west;s.west=c["a"].negativePiToPi(t.west+e*a),s.east=c["a"].negativePiToPi(t.west+n*a)}const l=t.north-t.south;return s.south=t.south+a*l,s.north=t.south+r*l,1===e&&(s.west=t.east),1===n&&(s.east=t.east),1===a&&(s.south=t.north),1===r&&(s.north=t.north),s},u.MAX_VALUE=Object.freeze(new u(-Math.PI,-c["a"].PI_OVER_TWO,Math.PI,c["a"].PI_OVER_TWO)),e["a"]=u},"583e":function(t,e,a){"use strict";var n=a("dde0"),o=a("8d54"),r=a("c937"),i=a("e2a6"),s=a("1f02"),c=a("b8b5"),u=a("d70f"),l=a("4a63");const h=Math.cos,g=Math.sin,f=Math.sqrt,p={computePosition:function(t,e,a,n,o,i,s){const c=e.radiiSquared,u=t.nwCorner,l=t.boundingRectangle;let p=u.latitude-t.granYCos*n+o*t.granXSin;const d=h(p),b=g(p),O=c.z*b;let m=u.longitude+n*t.granYSin+o*t.granXCos;const w=d*h(m),_=d*g(m),y=c.x*w,A=c.y*_,j=f(y*w+A*_+O*b);if(i.x=y/j,i.y=A/j,i.z=O/j,a){const e=t.stNwCorner;Object(r["a"])(e)?(p=e.latitude-t.stGranYCos*n+o*t.stGranXSin,m=e.longitude+n*t.stGranYSin+o*t.stGranXCos,s.x=(m-t.stWest)*t.lonScalar,s.y=(p-t.stSouth)*t.latScalar):(s.x=(m-l.west)*t.lonScalar,s.y=(p-l.south)*t.latScalar)}}},d=new u["a"];let b=new n["a"];const O=new o["a"];let m=new n["a"];const w=new s["a"];function _(t,e,a,o,r,i,s){const c=Math.cos(e),l=o*c,h=a*c,g=Math.sin(e),f=o*g,p=a*g;b=w.project(t,b),b=n["a"].subtract(b,m,b);const O=u["a"].fromRotation(e,d);b=u["a"].multiplyByVector(O,b,b),b=n["a"].add(b,m,b),t=w.unproject(b,t),i-=1,s-=1;const _=t.latitude,y=_+i*p,A=_-l*s,j=_-l*s+i*p,E=Math.max(_,y,A,j),P=Math.min(_,y,A,j),v=t.longitude,T=v+i*h,x=v+s*f,M=v+s*f+i*h,I=Math.max(v,T,x,M),R=Math.min(v,T,x,M);return{north:E,south:P,east:I,west:R,granYCos:l,granYSin:f,granXCos:h,granXSin:p,nwCorner:t}}p.computeOptions=function(t,e,a,n,o,r,s){let u,h=t.east,g=t.west,f=t.north,p=t.south,d=!1,b=!1;f===c["a"].PI_OVER_TWO&&(d=!0),p===-c["a"].PI_OVER_TWO&&(b=!0);const y=f-p;u=g>h?c["a"].TWO_PI-g+h:h-g;const A=Math.ceil(u/e)+1,j=Math.ceil(y/e)+1,E=u/(A-1),P=y/(j-1),v=l["a"].northwest(t,r),T=l["a"].center(t,O);0===a&&0===n||(T.longitude<v.longitude&&(T.longitude+=c["a"].TWO_PI),m=w.project(T,m));const x=P,M=E,I=0,R=0,L=l["a"].clone(t,o),N={granYCos:x,granYSin:I,granXCos:M,granXSin:R,nwCorner:v,boundingRectangle:L,width:A,height:j,northCap:d,southCap:b};if(0!==a){const t=_(v,a,E,P,T,A,j);if(f=t.north,p=t.south,h=t.east,g=t.west,f<-c["a"].PI_OVER_TWO||f>c["a"].PI_OVER_TWO||p<-c["a"].PI_OVER_TWO||p>c["a"].PI_OVER_TWO)throw new i["a"]("Rotated rectangle is invalid.  It crosses over either the north or south pole.");N.granYCos=t.granYCos,N.granYSin=t.granYSin,N.granXCos=t.granXCos,N.granXSin=t.granXSin,L.north=f,L.south=p,L.east=h,L.west=g}if(0!==n){a-=n;const t=l["a"].northwest(L,s),e=_(t,a,E,P,T,A,j);N.stGranYCos=e.granYCos,N.stGranXCos=e.granXCos,N.stGranYSin=e.granYSin,N.stGranXSin=e.granXSin,N.stNwCorner=t,N.stWest=e.west,N.stSouth=e.south}return N},e["a"]=p},ae40:function(t,e,a){"use strict";var n=a("9dc9"),o=a("8656"),r=a("85b2"),i=a("dde0"),s=a("8d54"),c=a("ae9b"),u=a("cbf0"),l=a("1a5d"),h=a("c937"),g=a("e2a6"),f=a("e107"),p=a("5a72"),d=a("f3a4"),b=a("0c02"),O=a("e8ff"),m=a("e148"),w=a("f6fe"),_=a("2642"),y=a("b8b5"),A=a("d70f"),j=a("d767"),E=a("97ea"),P=a("82ba"),v=a("1b9c"),T=a("4a63"),x=a("583e"),M=a("514d");const I=new i["a"],R=new i["a"],L=new i["a"],N=new i["a"],S=new T["a"],C=new r["a"],q=new o["a"],W=new o["a"];function k(t,e){const a=new p["a"]({attributes:new b["a"],primitiveType:P["a"].TRIANGLES});return a.attributes.position=new d["a"]({componentDatatype:u["a"].DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(a.attributes.normal=new d["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(a.attributes.tangent=new d["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(a.attributes.bitangent=new d["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:e.bitangents})),a}function V(t,e,a,n){const o=t.length,r=e.normal?new Float32Array(o):void 0,s=e.tangent?new Float32Array(o):void 0,c=e.bitangent?new Float32Array(o):void 0;let u=0;const l=N,h=L;let g=R;if(e.normal||e.tangent||e.bitangent)for(let f=0;f<o;f+=3){const o=i["a"].fromArray(t,f,I),p=u+1,d=u+2;g=a.geodeticSurfaceNormal(o,g),(e.tangent||e.bitangent)&&(i["a"].cross(i["a"].UNIT_Z,g,h),j["a"].multiplyByVector(n,h,h),i["a"].normalize(h,h),e.bitangent&&i["a"].normalize(i["a"].cross(g,h,l),l)),e.normal&&(r[u]=g.x,r[p]=g.y,r[d]=g.z),e.tangent&&(s[u]=h.x,s[p]=h.y,s[d]=h.z),e.bitangent&&(c[u]=l.x,c[p]=l.y,c[d]=l.z),u+=3}return k(e,{positions:t,normals:r,tangents:s,bitangents:c})}const F=new i["a"],D=new i["a"];function X(t,e,a){const n=t.length,o=e.normal?new Float32Array(n):void 0,r=e.tangent?new Float32Array(n):void 0,s=e.bitangent?new Float32Array(n):void 0;let c=0,u=0,l=0,h=!0,g=N,f=L,p=R;if(e.normal||e.tangent||e.bitangent)for(let d=0;d<n;d+=6){const b=i["a"].fromArray(t,d,I),O=i["a"].fromArray(t,(d+6)%n,F);if(h){const e=i["a"].fromArray(t,(d+3)%n,D);i["a"].subtract(O,b,O),i["a"].subtract(e,b,e),p=i["a"].normalize(i["a"].cross(e,O,p),p),h=!1}i["a"].equalsEpsilon(O,b,y["a"].EPSILON10)&&(h=!0),(e.tangent||e.bitangent)&&(g=a.geodeticSurfaceNormal(b,g),e.tangent&&(f=i["a"].normalize(i["a"].cross(g,p,f),f))),e.normal&&(o[c++]=p.x,o[c++]=p.y,o[c++]=p.z,o[c++]=p.x,o[c++]=p.y,o[c++]=p.z),e.tangent&&(r[u++]=f.x,r[u++]=f.y,r[u++]=f.z,r[u++]=f.x,r[u++]=f.y,r[u++]=f.z),e.bitangent&&(s[l++]=g.x,s[l++]=g.y,s[l++]=g.z,s[l++]=g.x,s[l++]=g.y,s[l++]=g.z)}return k(e,{positions:t,normals:o,tangents:r,bitangents:s})}function H(t,e){const a=t._vertexFormat,n=t._ellipsoid,o=e.height,r=e.width,i=e.northCap,s=e.southCap;let c=0,l=o,h=o,g=0;i&&(c=1,h-=1,g+=1),s&&(l-=1,h-=1,g+=1),g+=r*h;const f=a.position?new Float64Array(3*g):void 0,p=a.st?new Float32Array(2*g):void 0;let b=0,O=0;const m=I,w=C;let y=Number.MAX_VALUE,A=Number.MAX_VALUE,j=-Number.MAX_VALUE,E=-Number.MAX_VALUE;for(let u=c;u<l;++u)for(let t=0;t<r;++t)x["a"].computePosition(e,n,a.st,u,t,m,w),f[b++]=m.x,f[b++]=m.y,f[b++]=m.z,a.st&&(p[O++]=w.x,p[O++]=w.y,y=Math.min(y,w.x),A=Math.min(A,w.y),j=Math.max(j,w.x),E=Math.max(E,w.y));if(i&&(x["a"].computePosition(e,n,a.st,0,0,m,w),f[b++]=m.x,f[b++]=m.y,f[b++]=m.z,a.st&&(p[O++]=w.x,p[O++]=w.y,y=w.x,A=w.y,j=w.x,E=w.y)),s&&(x["a"].computePosition(e,n,a.st,o-1,0,m,w),f[b++]=m.x,f[b++]=m.y,f[b]=m.z,a.st&&(p[O++]=w.x,p[O]=w.y,y=Math.min(y,w.x),A=Math.min(A,w.y),j=Math.max(j,w.x),E=Math.max(E,w.y))),a.st&&(y<0||A<0||j>1||E>1))for(let u=0;u<p.length;u+=2)p[u]=(p[u]-y)/(j-y),p[u+1]=(p[u+1]-A)/(E-A);const P=V(f,a,n,e.tangentRotationMatrix);let v=6*(r-1)*(h-1);i&&(v+=3*(r-1)),s&&(v+=3*(r-1));const T=_["a"].createTypedArray(g,v);let M,R=0,L=0;for(M=0;M<h-1;++M){for(let t=0;t<r-1;++t){const t=R,e=t+r,a=e+1,n=t+1;T[L++]=t,T[L++]=e,T[L++]=n,T[L++]=n,T[L++]=e,T[L++]=a,++R}++R}if(i||s){let t=g-1;const e=g-1;let a,n;if(i&&s&&(t=g-2),R=0,i)for(M=0;M<r-1;M++)a=R,n=a+1,T[L++]=t,T[L++]=a,T[L++]=n,++R;if(s)for(R=(h-1)*r,M=0;M<r-1;M++)a=R,n=a+1,T[L++]=a,T[L++]=e,T[L++]=n,++R}return P.indices=T,a.st&&(P.attributes.st=new d["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:2,values:p})),P}function U(t,e,a,n,o){return t[e++]=n[a],t[e++]=n[a+1],t[e++]=n[a+2],t[e++]=o[a],t[e++]=o[a+1],t[e]=o[a+2],t}function G(t,e,a,n){return t[e++]=n[a],t[e++]=n[a+1],t[e++]=n[a],t[e]=n[a+1],t}const Y=new M["a"];function z(t,e){const a=t._shadowVolume,o=t._offsetAttribute,r=t._vertexFormat,s=t._extrudedHeight,c=t._surfaceHeight,l=t._ellipsoid,g=e.height,f=e.width;let p;if(a){const e=M["a"].clone(r,Y);e.normal=!0,t._vertexFormat=e}const b=H(t,e);a&&(t._vertexFormat=r);let A=E["a"].scaleToGeodeticHeight(b.attributes.position.values,c,l,!1);A=new Float64Array(A);let j=A.length;const P=2*j,v=new Float64Array(P);v.set(A);const T=E["a"].scaleToGeodeticHeight(b.attributes.position.values,s,l);v.set(T,j),b.attributes.position.values=v;const x=r.normal?new Float32Array(P):void 0,I=r.tangent?new Float32Array(P):void 0,R=r.bitangent?new Float32Array(P):void 0,L=r.st?new Float32Array(P/3*2):void 0;let N,S,C;if(r.normal){for(S=b.attributes.normal.values,x.set(S),p=0;p<j;p++)S[p]=-S[p];x.set(S,j),b.attributes.normal.values=x}if(a){S=b.attributes.normal.values,r.normal||(b.attributes.normal=void 0);const t=new Float32Array(P);for(p=0;p<j;p++)S[p]=-S[p];t.set(S,j),b.attributes.extrudeDirection=new d["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:t})}const q=Object(h["a"])(o);if(q){const t=j/3*2;let e=new Uint8Array(t);o===m["a"].TOP?e=Object(n["a"])(e,1,0,t/2):(C=o===m["a"].NONE?0:1,e=Object(n["a"])(e,C)),b.attributes.applyOffset=new d["a"]({componentDatatype:u["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(r.tangent){const t=b.attributes.tangent.values;for(I.set(t),p=0;p<j;p++)t[p]=-t[p];I.set(t,j),b.attributes.tangent.values=I}if(r.bitangent){const t=b.attributes.bitangent.values;R.set(t),R.set(t,j),b.attributes.bitangent.values=R}r.st&&(N=b.attributes.st.values,L.set(N),L.set(N,j/3*2),b.attributes.st.values=L);const W=b.indices,k=W.length,V=j/3,z=_["a"].createTypedArray(P/3,2*k);for(z.set(W),p=0;p<k;p+=3)z[p+k]=W[p+2]+V,z[p+1+k]=W[p+1]+V,z[p+2+k]=W[p]+V;b.indices=z;const B=e.northCap,J=e.southCap;let Z=g,Q=2,K=0,$=4,tt=4;B&&(Q-=1,Z-=1,K+=1,$-=2,tt-=1),J&&(Q-=1,Z-=1,K+=1,$-=2,tt-=1),K+=Q*f+2*Z-$;const et=2*(K+tt);let at=new Float64Array(3*et);const nt=a?new Float32Array(3*et):void 0;let ot=q?new Uint8Array(et):void 0,rt=r.st?new Float32Array(2*et):void 0;const it=o===m["a"].TOP;q&&!it&&(C=o===m["a"].ALL?1:0,ot=Object(n["a"])(ot,C));let st=0,ct=0,ut=0,lt=0;const ht=f*Z;let gt;for(p=0;p<ht;p+=f)gt=3*p,at=U(at,st,gt,A,T),st+=6,r.st&&(rt=G(rt,ct,2*p,N),ct+=4),a&&(ut+=3,nt[ut++]=S[gt],nt[ut++]=S[gt+1],nt[ut++]=S[gt+2]),it&&(ot[lt++]=1,lt+=1);if(J){const t=B?ht+1:ht;for(gt=3*t,p=0;p<2;p++)at=U(at,st,gt,A,T),st+=6,r.st&&(rt=G(rt,ct,2*t,N),ct+=4),a&&(ut+=3,nt[ut++]=S[gt],nt[ut++]=S[gt+1],nt[ut++]=S[gt+2]),it&&(ot[lt++]=1,lt+=1)}else for(p=ht-f;p<ht;p++)gt=3*p,at=U(at,st,gt,A,T),st+=6,r.st&&(rt=G(rt,ct,2*p,N),ct+=4),a&&(ut+=3,nt[ut++]=S[gt],nt[ut++]=S[gt+1],nt[ut++]=S[gt+2]),it&&(ot[lt++]=1,lt+=1);for(p=ht-1;p>0;p-=f)gt=3*p,at=U(at,st,gt,A,T),st+=6,r.st&&(rt=G(rt,ct,2*p,N),ct+=4),a&&(ut+=3,nt[ut++]=S[gt],nt[ut++]=S[gt+1],nt[ut++]=S[gt+2]),it&&(ot[lt++]=1,lt+=1);if(B){const t=ht;for(gt=3*t,p=0;p<2;p++)at=U(at,st,gt,A,T),st+=6,r.st&&(rt=G(rt,ct,2*t,N),ct+=4),a&&(ut+=3,nt[ut++]=S[gt],nt[ut++]=S[gt+1],nt[ut++]=S[gt+2]),it&&(ot[lt++]=1,lt+=1)}else for(p=f-1;p>=0;p--)gt=3*p,at=U(at,st,gt,A,T),st+=6,r.st&&(rt=G(rt,ct,2*p,N),ct+=4),a&&(ut+=3,nt[ut++]=S[gt],nt[ut++]=S[gt+1],nt[ut++]=S[gt+2]),it&&(ot[lt++]=1,lt+=1);let ft=X(at,r,l);r.st&&(ft.attributes.st=new d["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:2,values:rt})),a&&(ft.attributes.extrudeDirection=new d["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:nt})),q&&(ft.attributes.applyOffset=new d["a"]({componentDatatype:u["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:ot}));const pt=_["a"].createTypedArray(et,6*K);let dt,bt,Ot,mt;j=at.length/3;let wt=0;for(p=0;p<j-1;p+=2){dt=p,mt=(dt+2)%j;const t=i["a"].fromArray(at,3*dt,F),e=i["a"].fromArray(at,3*mt,D);i["a"].equalsEpsilon(t,e,y["a"].EPSILON10)||(bt=(dt+1)%j,Ot=(bt+2)%j,pt[wt++]=dt,pt[wt++]=bt,pt[wt++]=mt,pt[wt++]=mt,pt[wt++]=bt,pt[wt++]=Ot)}return ft.indices=pt,ft=w["a"].combineInstances([new O["a"]({geometry:b}),new O["a"]({geometry:ft})]),ft[0]}const B=[new i["a"],new i["a"],new i["a"],new i["a"]],J=new s["a"],Z=new s["a"];function Q(t,e,a,n,o){if(0===a)return T["a"].clone(t,o);const r=x["a"].computeOptions(t,e,a,0,S,J),i=r.height,s=r.width,c=B;return x["a"].computePosition(r,n,!1,0,0,c[0]),x["a"].computePosition(r,n,!1,0,s-1,c[1]),x["a"].computePosition(r,n,!1,i-1,0,c[2]),x["a"].computePosition(r,n,!1,i-1,s-1,c[3]),T["a"].fromCartesianArray(c,n,o)}function K(t){t=Object(l["a"])(t,l["a"].EMPTY_OBJECT);const e=t.rectangle;if(c["a"].typeOf.object("rectangle",e),T["a"].validate(e),e.north<e.south)throw new g["a"]("options.rectangle.north must be greater than or equal to options.rectangle.south");const a=Object(l["a"])(t.height,0),n=Object(l["a"])(t.extrudedHeight,a);this._rectangle=T["a"].clone(e),this._granularity=Object(l["a"])(t.granularity,y["a"].RADIANS_PER_DEGREE),this._ellipsoid=f["a"].clone(Object(l["a"])(t.ellipsoid,f["a"].WGS84)),this._surfaceHeight=Math.max(a,n),this._rotation=Object(l["a"])(t.rotation,0),this._stRotation=Object(l["a"])(t.stRotation,0),this._vertexFormat=M["a"].clone(Object(l["a"])(t.vertexFormat,M["a"].DEFAULT)),this._extrudedHeight=Math.min(a,n),this._shadowVolume=Object(l["a"])(t.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=t.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}K.packedLength=T["a"].packedLength+f["a"].packedLength+M["a"].packedLength+7,K.pack=function(t,e,a){return c["a"].typeOf.object("value",t),c["a"].defined("array",e),a=Object(l["a"])(a,0),T["a"].pack(t._rectangle,e,a),a+=T["a"].packedLength,f["a"].pack(t._ellipsoid,e,a),a+=f["a"].packedLength,M["a"].pack(t._vertexFormat,e,a),a+=M["a"].packedLength,e[a++]=t._granularity,e[a++]=t._surfaceHeight,e[a++]=t._rotation,e[a++]=t._stRotation,e[a++]=t._extrudedHeight,e[a++]=t._shadowVolume?1:0,e[a]=Object(l["a"])(t._offsetAttribute,-1),e};const $=new T["a"],tt=f["a"].clone(f["a"].UNIT_SPHERE),et={rectangle:$,ellipsoid:tt,vertexFormat:Y,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};K.unpack=function(t,e,a){c["a"].defined("array",t),e=Object(l["a"])(e,0);const n=T["a"].unpack(t,e,$);e+=T["a"].packedLength;const o=f["a"].unpack(t,e,tt);e+=f["a"].packedLength;const r=M["a"].unpack(t,e,Y);e+=M["a"].packedLength;const i=t[e++],s=t[e++],u=t[e++],g=t[e++],p=t[e++],d=1===t[e++],b=t[e];return Object(h["a"])(a)?(a._rectangle=T["a"].clone(n,a._rectangle),a._ellipsoid=f["a"].clone(o,a._ellipsoid),a._vertexFormat=M["a"].clone(r,a._vertexFormat),a._granularity=i,a._surfaceHeight=s,a._rotation=u,a._stRotation=g,a._extrudedHeight=p,a._shadowVolume=d,a._offsetAttribute=-1===b?void 0:b,a):(et.granularity=i,et.height=s,et.rotation=u,et.stRotation=g,et.extrudedHeight=p,et.shadowVolume=d,et.offsetAttribute=-1===b?void 0:b,new K(et))},K.computeRectangle=function(t,e){t=Object(l["a"])(t,l["a"].EMPTY_OBJECT);const a=t.rectangle;if(c["a"].typeOf.object("rectangle",a),T["a"].validate(a),a.north<a.south)throw new g["a"]("options.rectangle.north must be greater than or equal to options.rectangle.south");const n=Object(l["a"])(t.granularity,y["a"].RADIANS_PER_DEGREE),o=Object(l["a"])(t.ellipsoid,f["a"].WGS84),r=Object(l["a"])(t.rotation,0);return Q(a,n,r,o,e)};const at=new j["a"],nt=new v["a"],ot=new s["a"];K.createGeometry=function(t){if(y["a"].equalsEpsilon(t._rectangle.north,t._rectangle.south,y["a"].EPSILON10)||y["a"].equalsEpsilon(t._rectangle.east,t._rectangle.west,y["a"].EPSILON10))return;let e=t._rectangle;const a=t._ellipsoid,r=t._rotation,i=t._stRotation,s=t._vertexFormat,c=x["a"].computeOptions(e,t._granularity,r,i,S,J,Z),l=at;if(0!==i||0!==r){const t=T["a"].center(e,ot),n=a.geodeticSurfaceNormalCartographic(t,F);v["a"].fromAxisAngle(n,-i,nt),j["a"].fromQuaternion(nt,l)}else j["a"].clone(j["a"].IDENTITY,l);const g=t._surfaceHeight,f=t._extrudedHeight,b=!y["a"].equalsEpsilon(g,f,0,y["a"].EPSILON2);let O,w;if(c.lonScalar=1/t._rectangle.width,c.latScalar=1/t._rectangle.height,c.tangentRotationMatrix=l,e=t._rectangle,b){O=z(t,c);const n=o["a"].fromRectangle3D(e,a,g,W),r=o["a"].fromRectangle3D(e,a,f,q);w=o["a"].union(n,r)}else{if(O=H(t,c),O.attributes.position.values=E["a"].scaleToGeodeticHeight(O.attributes.position.values,g,a,!1),Object(h["a"])(t._offsetAttribute)){const e=O.attributes.position.values.length,a=new Uint8Array(e/3),o=t._offsetAttribute===m["a"].NONE?0:1;Object(n["a"])(a,o),O.attributes.applyOffset=new d["a"]({componentDatatype:u["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}w=o["a"].fromRectangle3D(e,a,g)}return s.position||delete O.attributes.position,new p["a"]({attributes:O.attributes,indices:O.indices,primitiveType:O.primitiveType,boundingSphere:w,offsetAttribute:t._offsetAttribute})},K.createShadowVolume=function(t,e,a){const n=t._granularity,o=t._ellipsoid,r=e(n,o),i=a(n,o);return new K({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:o,stRotation:t._stRotation,granularity:n,extrudedHeight:i,height:r,vertexFormat:M["a"].POSITION_ONLY,shadowVolume:!0})};const rt=new T["a"],it=[new r["a"],new r["a"],new r["a"]],st=new A["a"],ct=new s["a"];function ut(t){if(0===t._stRotation)return[0,0,0,1,1,0];const e=T["a"].clone(t._rectangle,rt),a=t._granularity,n=t._ellipsoid,o=t._rotation-t._stRotation,i=Q(e,a,o,n,rt),s=it;s[0].x=i.west,s[0].y=i.south,s[1].x=i.west,s[1].y=i.north,s[2].x=i.east,s[2].y=i.south;const c=t.rectangle,u=A["a"].fromRotation(t._stRotation,st),l=T["a"].center(c,ct);for(let r=0;r<3;++r){const t=s[r];t.x-=l.longitude,t.y-=l.latitude,A["a"].multiplyByVector(u,t,t),t.x+=l.longitude,t.y+=l.latitude,t.x=(t.x-c.west)/c.width,t.y=(t.y-c.south)/c.height}const h=s[0],g=s[1],f=s[2],p=new Array(6);return r["a"].pack(h,p),r["a"].pack(g,p,2),r["a"].pack(f,p,4),p}Object.defineProperties(K.prototype,{rectangle:{get:function(){return Object(h["a"])(this._rotatedRectangle)||(this._rotatedRectangle=Q(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return Object(h["a"])(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=ut(this)),this._textureCoordinateRotationPoints}}}),e["a"]=K},ba67:function(t,e,a){"use strict";var n=a("d36f"),o=a("ae9b");function r(){this._tree=new n["a"]}function i(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.id=""}function s(t,e){return t.id===e.id}i.fromRectangleAndId=function(t,e,a){return a.minX=e.west,a.minY=e.south,a.maxX=e.east,a.maxY=e.north,a.id=t,a},r.prototype.insert=function(t,e){o["a"].typeOf.string("id",t),o["a"].typeOf.object("rectangle",e);const a=i.fromRectangleAndId(t,e,new i);this._tree.insert(a)};const c=new i;r.prototype.remove=function(t,e){o["a"].typeOf.string("id",t),o["a"].typeOf.object("rectangle",e);const a=i.fromRectangleAndId(t,e,c);this._tree.remove(a,s)};const u=new i;r.prototype.collides=function(t){o["a"].typeOf.object("rectangle",t);const e=i.fromRectangleAndId("",t,u);return this._tree.collides(e)},e["a"]=r},d745:function(t,e,a){"use strict";const n={FIXED:0,INERTIAL:1};e["a"]=Object.freeze(n)}}]);