(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-vendors~fd507232"],{"233a":function(e,t,a){"use strict";var n=a("e2a6");function o(){n["a"].throwInstantiationError()}o.prototype.getURL=n["a"].throwInstantiationError},"2c95":function(e,t,a){"use strict";var n=a("dde0"),o=a("8d54"),r=a("1a5d"),i=a("c937"),s=a("e2a6"),c=a("e107"),l=a("c993"),u=a("2039"),p=a("7f05"),h=a("b8b5"),d=a("722e"),g=a("a7b2");const f={numberOfPoints:function(e,t,a){const o=n["a"].distance(e,t);return Math.ceil(o/a)},numberOfPointsRhumbLine:function(e,t,a){const n=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(n/(a*a))))}},y=new o["a"];f.extractHeights=function(e,t){const a=e.length,n=new Array(a);for(let o=0;o<a;o++){const a=e[o];n[o]=t.cartesianToCartographic(a,y).height}return n};const m=new d["a"],b=new n["a"],w=new n["a"],O=new g["a"](n["a"].UNIT_X,0),_=new n["a"],T=new g["a"](n["a"].UNIT_X,0),E=new n["a"],A=new n["a"],P=[];function v(e,t,a){const n=P;let o;if(n.length=e,t===a){for(o=0;o<e;o++)n[o]=t;return n}const r=a-t,i=r/e;for(o=0;o<e;o++){const e=t+o*i;n[o]=e}return n}const j=new o["a"],I=new o["a"],L=new n["a"],x=new n["a"],S=new n["a"],N=new l["a"];let D=new u["a"];function R(e,t,a,o,r,i,s,c){const l=o.scaleToGeodeticSurface(e,x),u=o.scaleToGeodeticSurface(t,S),p=f.numberOfPoints(e,t,a),h=o.cartesianToCartographic(l,j),d=o.cartesianToCartographic(u,I),g=v(p,r,i);N.setEndPoints(h,d);const y=N.surfaceDistance/p;let m=c;h.height=r;let b=o.cartographicToCartesian(h,L);n["a"].pack(b,s,m),m+=3;for(let f=1;f<p;f++){const e=N.interpolateUsingSurfaceDistance(f*y,I);e.height=g[f],b=o.cartographicToCartesian(e,L),n["a"].pack(b,s,m),m+=3}return m}function k(e,t,a,o,r,i,s,c){const l=o.cartesianToCartographic(e,j),p=o.cartesianToCartographic(t,I),h=f.numberOfPointsRhumbLine(l,p,a);l.height=0,p.height=0;const d=v(h,r,i);D.ellipsoid.equals(o)||(D=new u["a"](void 0,void 0,o)),D.setEndPoints(l,p);const g=D.surfaceDistance/h;let y=c;l.height=r;let m=o.cartographicToCartesian(l,L);n["a"].pack(m,s,y),y+=3;for(let u=1;u<h;u++){const e=D.interpolateUsingSurfaceDistance(u*g,I);e.height=d[u],m=o.cartographicToCartesian(e,L),n["a"].pack(m,s,y),y+=3}return y}f.wrapLongitude=function(e,t){const a=[],o=[];if(Object(i["a"])(e)&&e.length>0){t=Object(r["a"])(t,d["a"].IDENTITY);const s=d["a"].inverseTransformation(t,m),c=d["a"].multiplyByPoint(s,n["a"].ZERO,b),l=n["a"].normalize(d["a"].multiplyByPointAsVector(s,n["a"].UNIT_Y,w),w),u=g["a"].fromPointNormal(c,l,O),h=n["a"].normalize(d["a"].multiplyByPointAsVector(s,n["a"].UNIT_X,_),_),f=g["a"].fromPointNormal(c,h,T);let y=1;a.push(n["a"].clone(e[0]));let P=a[0];const v=e.length;for(let t=1;t<v;++t){const r=e[t];if(g["a"].getPointDistance(f,P)<0||g["a"].getPointDistance(f,r)<0){const e=p["a"].lineSegmentPlane(P,r,u,E);if(Object(i["a"])(e)){const t=n["a"].multiplyByScalar(l,5e-9,A);g["a"].getPointDistance(u,P)<0&&n["a"].negate(t,t),a.push(n["a"].add(e,t,new n["a"])),o.push(y+1),n["a"].negate(t,t),a.push(n["a"].add(e,t,new n["a"])),y=1}}a.push(n["a"].clone(e[t])),y++,P=r}o.push(y)}return{positions:a,lengths:o}},f.generateArc=function(e){Object(i["a"])(e)||(e={});const t=e.positions;if(!Object(i["a"])(t))throw new s["a"]("options.positions is required.");const a=t.length,o=Object(r["a"])(e.ellipsoid,c["a"].WGS84);let l=Object(r["a"])(e.height,0);const u=Array.isArray(l);if(a<1)return[];if(1===a){const e=o.scaleToGeodeticSurface(t[0],x);if(l=u?l[0]:l,0!==l){const t=o.geodeticSurfaceNormal(e,L);n["a"].multiplyByScalar(t,l,t),n["a"].add(e,t,e)}return[e.x,e.y,e.z]}let p=e.minDistance;if(!Object(i["a"])(p)){const t=Object(r["a"])(e.granularity,h["a"].RADIANS_PER_DEGREE);p=h["a"].chordLength(t,o.maximumRadius)}let d,g=0;for(d=0;d<a-1;d++)g+=f.numberOfPoints(t[d],t[d+1],p);const y=3*(g+1),m=new Array(y);let b=0;for(d=0;d<a-1;d++){const e=t[d],a=t[d+1],n=u?l[d]:l,r=u?l[d+1]:l;b=R(e,a,p,o,n,r,m,b)}P.length=0;const w=t[a-1],O=o.cartesianToCartographic(w,j);O.height=u?l[a-1]:l;const _=o.cartographicToCartesian(O,L);return n["a"].pack(_,m,y-3),m};const H=new o["a"],G=new o["a"];f.generateRhumbArc=function(e){Object(i["a"])(e)||(e={});const t=e.positions;if(!Object(i["a"])(t))throw new s["a"]("options.positions is required.");const a=t.length,l=Object(r["a"])(e.ellipsoid,c["a"].WGS84);let u=Object(r["a"])(e.height,0);const p=Array.isArray(u);if(a<1)return[];if(1===a){const e=l.scaleToGeodeticSurface(t[0],x);if(u=p?u[0]:u,0!==u){const t=l.geodeticSurfaceNormal(e,L);n["a"].multiplyByScalar(t,u,t),n["a"].add(e,t,e)}return[e.x,e.y,e.z]}const d=Object(r["a"])(e.granularity,h["a"].RADIANS_PER_DEGREE);let g,y,m=0,b=l.cartesianToCartographic(t[0],H);for(g=0;g<a-1;g++)y=l.cartesianToCartographic(t[g+1],G),m+=f.numberOfPointsRhumbLine(b,y,d),b=o["a"].clone(y,H);const w=3*(m+1),O=new Array(w);let _=0;for(g=0;g<a-1;g++){const e=t[g],a=t[g+1],n=p?u[g]:u,o=p?u[g+1]:u;_=k(e,a,d,l,n,o,O,_)}P.length=0;const T=t[a-1],E=l.cartesianToCartographic(T,j);E.height=p?u[a-1]:u;const A=l.cartographicToCartesian(E,L);return n["a"].pack(A,O,w-3),O},f.generateCartesianArc=function(e){const t=f.generateArc(e),a=t.length/3,o=new Array(a);for(let r=0;r<a;r++)o[r]=n["a"].unpack(t,3*r);return o},f.generateCartesianRhumbArc=function(e){const t=f.generateRhumbArc(e),a=t.length/3,o=new Array(a);for(let r=0;r<a;r++)o[r]=n["a"].unpack(t,3*r);return o},t["a"]=f},3155:function(e,t,a){"use strict";var n=a("8656"),o=a("dde0"),r=a("ae9b"),i=a("cbf0"),s=a("1a5d"),c=a("c937"),l=a("5a72"),u=a("f3a4"),p=a("0c02"),h=a("82ba"),d=a("514d");function g(e){e=Object(s["a"])(e,s["a"].EMPTY_OBJECT);const t=Object(s["a"])(e.vertexFormat,d["a"].DEFAULT);this._vertexFormat=t,this._workerName="createPlaneGeometry"}g.packedLength=d["a"].packedLength,g.pack=function(e,t,a){return r["a"].typeOf.object("value",e),r["a"].defined("array",t),a=Object(s["a"])(a,0),d["a"].pack(e._vertexFormat,t,a),t};const f=new d["a"],y={vertexFormat:f};g.unpack=function(e,t,a){r["a"].defined("array",e),t=Object(s["a"])(t,0);const n=d["a"].unpack(e,t,f);return Object(c["a"])(a)?(a._vertexFormat=d["a"].clone(n,a._vertexFormat),a):new g(y)};const m=new o["a"](-.5,-.5,0),b=new o["a"](.5,.5,0);g.createGeometry=function(e){const t=e._vertexFormat,a=new p["a"];let r,s;if(t.position){if(s=new Float64Array(12),s[0]=m.x,s[1]=m.y,s[2]=0,s[3]=b.x,s[4]=m.y,s[5]=0,s[6]=b.x,s[7]=b.y,s[8]=0,s[9]=m.x,s[10]=b.y,s[11]=0,a.position=new u["a"]({componentDatatype:i["a"].DOUBLE,componentsPerAttribute:3,values:s}),t.normal){const e=new Float32Array(12);e[0]=0,e[1]=0,e[2]=1,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=1,e[9]=0,e[10]=0,e[11]=1,a.normal=new u["a"]({componentDatatype:i["a"].FLOAT,componentsPerAttribute:3,values:e})}if(t.st){const e=new Float32Array(8);e[0]=0,e[1]=0,e[2]=1,e[3]=0,e[4]=1,e[5]=1,e[6]=0,e[7]=1,a.st=new u["a"]({componentDatatype:i["a"].FLOAT,componentsPerAttribute:2,values:e})}if(t.tangent){const e=new Float32Array(12);e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e[6]=1,e[7]=0,e[8]=0,e[9]=1,e[10]=0,e[11]=0,a.tangent=new u["a"]({componentDatatype:i["a"].FLOAT,componentsPerAttribute:3,values:e})}if(t.bitangent){const e=new Float32Array(12);e[0]=0,e[1]=1,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=1,e[8]=0,e[9]=0,e[10]=1,e[11]=0,a.bitangent=new u["a"]({componentDatatype:i["a"].FLOAT,componentsPerAttribute:3,values:e})}r=new Uint16Array(6),r[0]=0,r[1]=1,r[2]=2,r[3]=0,r[4]=2,r[5]=3}return new l["a"]({attributes:a,indices:r,primitiveType:h["a"].TRIANGLES,boundingSphere:new n["a"](o["a"].ZERO,Math.sqrt(2))})},t["a"]=g},"345a":function(e,t,a){"use strict";var n=a("0e04"),o=a("9dc9"),r=a("8656"),i=a("ae9b"),s=a("cbf0"),c=a("1a5d"),l=a("c937"),u=a("e2a6"),p=a("e107"),h=a("7e56"),d=a("5a72"),g=a("f3a4"),f=a("0c02"),y=a("e8ff"),m=a("e148"),b=a("f6fe"),w=a("2642"),O=a("b8b5"),_=a("7def"),T=a("97ea"),E=a("82ba"),A=a("f59e");const P=[],v=[];function j(e,t,a,o,r){const i=h["a"].fromPoints(t,e),c=i.projectPointsOntoPlane(t,P),l=T["a"].computeWindingOrder2D(c);let u,p;l===A["a"].CLOCKWISE&&(c.reverse(),t=t.slice().reverse());let m=t.length,b=0;if(o)for(u=new Float64Array(2*m*3),p=0;p<m;p++){const e=t[p],a=t[(p+1)%m];u[b++]=e.x,u[b++]=e.y,u[b++]=e.z,u[b++]=a.x,u[b++]=a.y,u[b++]=a.z}else{let o=0;if(r===n["a"].GEODESIC)for(p=0;p<m;p++)o+=_["a"].subdivideLineCount(t[p],t[(p+1)%m],a);else if(r===n["a"].RHUMB)for(p=0;p<m;p++)o+=_["a"].subdivideRhumbLineCount(e,t[p],t[(p+1)%m],a);for(u=new Float64Array(3*o),p=0;p<m;p++){let o;r===n["a"].GEODESIC?o=_["a"].subdivideLine(t[p],t[(p+1)%m],a,v):r===n["a"].RHUMB&&(o=_["a"].subdivideRhumbLine(e,t[p],t[(p+1)%m],a,v));const i=o.length;for(let e=0;e<i;++e)u[b++]=o[e]}}m=u.length/3;const O=2*m,j=w["a"].createTypedArray(m,O);for(b=0,p=0;p<m-1;p++)j[b++]=p,j[b++]=p+1;return j[b++]=m-1,j[b++]=0,new y["a"]({geometry:new d["a"]({attributes:new f["a"]({position:new g["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:u})}),indices:j,primitiveType:E["a"].LINES})})}function I(e,t,a,o,r){const i=h["a"].fromPoints(t,e),c=i.projectPointsOntoPlane(t,P),l=T["a"].computeWindingOrder2D(c);let u,p;l===A["a"].CLOCKWISE&&(c.reverse(),t=t.slice().reverse());let m=t.length;const b=new Array(m);let O=0;if(o)for(u=new Float64Array(2*m*3*2),p=0;p<m;++p){b[p]=O/3;const e=t[p],a=t[(p+1)%m];u[O++]=e.x,u[O++]=e.y,u[O++]=e.z,u[O++]=a.x,u[O++]=a.y,u[O++]=a.z}else{let o=0;if(r===n["a"].GEODESIC)for(p=0;p<m;p++)o+=_["a"].subdivideLineCount(t[p],t[(p+1)%m],a);else if(r===n["a"].RHUMB)for(p=0;p<m;p++)o+=_["a"].subdivideRhumbLineCount(e,t[p],t[(p+1)%m],a);for(u=new Float64Array(3*o*2),p=0;p<m;++p){let o;b[p]=O/3,r===n["a"].GEODESIC?o=_["a"].subdivideLine(t[p],t[(p+1)%m],a,v):r===n["a"].RHUMB&&(o=_["a"].subdivideRhumbLine(e,t[p],t[(p+1)%m],a,v));const i=o.length;for(let e=0;e<i;++e)u[O++]=o[e]}}m=u.length/6;const j=b.length,I=2*(2*m+j),L=w["a"].createTypedArray(m+j,I);for(O=0,p=0;p<m;++p)L[O++]=p,L[O++]=(p+1)%m,L[O++]=p+m,L[O++]=(p+1)%m+m;for(p=0;p<j;p++){const e=b[p];L[O++]=e,L[O++]=e+m}return new y["a"]({geometry:new d["a"]({attributes:new f["a"]({position:new g["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:u})}),indices:L,primitiveType:E["a"].LINES})})}function L(e){if(i["a"].typeOf.object("options",e),i["a"].typeOf.object("options.polygonHierarchy",e.polygonHierarchy),e.perPositionHeight&&Object(l["a"])(e.height))throw new u["a"]("Cannot use both options.perPositionHeight and options.height");if(Object(l["a"])(e.arcType)&&e.arcType!==n["a"].GEODESIC&&e.arcType!==n["a"].RHUMB)throw new u["a"]("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const t=e.polygonHierarchy,a=Object(c["a"])(e.ellipsoid,p["a"].WGS84),o=Object(c["a"])(e.granularity,O["a"].RADIANS_PER_DEGREE),r=Object(c["a"])(e.perPositionHeight,!1),s=r&&Object(l["a"])(e.extrudedHeight),h=Object(c["a"])(e.arcType,n["a"].GEODESIC);let d=Object(c["a"])(e.height,0),g=Object(c["a"])(e.extrudedHeight,d);if(!s){const e=Math.max(d,g);g=Math.min(d,g),d=e}this._ellipsoid=p["a"].clone(a),this._granularity=o,this._height=d,this._extrudedHeight=g,this._arcType=h,this._polygonHierarchy=t,this._perPositionHeight=r,this._perPositionHeightExtrude=s,this._offsetAttribute=e.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=_["a"].computeHierarchyPackedLength(t)+p["a"].packedLength+8}L.pack=function(e,t,a){return i["a"].typeOf.object("value",e),i["a"].defined("array",t),a=Object(c["a"])(a,0),a=_["a"].packPolygonHierarchy(e._polygonHierarchy,t,a),p["a"].pack(e._ellipsoid,t,a),a+=p["a"].packedLength,t[a++]=e._height,t[a++]=e._extrudedHeight,t[a++]=e._granularity,t[a++]=e._perPositionHeightExtrude?1:0,t[a++]=e._perPositionHeight?1:0,t[a++]=e._arcType,t[a++]=Object(c["a"])(e._offsetAttribute,-1),t[a]=e.packedLength,t};const x=p["a"].clone(p["a"].UNIT_SPHERE),S={polygonHierarchy:{}};L.unpack=function(e,t,a){i["a"].defined("array",e),t=Object(c["a"])(t,0);const n=_["a"].unpackPolygonHierarchy(e,t);t=n.startingIndex,delete n.startingIndex;const o=p["a"].unpack(e,t,x);t+=p["a"].packedLength;const r=e[t++],s=e[t++],u=e[t++],h=1===e[t++],d=1===e[t++],g=e[t++],f=e[t++],y=e[t];return Object(l["a"])(a)||(a=new L(S)),a._polygonHierarchy=n,a._ellipsoid=p["a"].clone(o,a._ellipsoid),a._height=r,a._extrudedHeight=s,a._granularity=u,a._perPositionHeight=d,a._perPositionHeightExtrude=h,a._arcType=g,a._offsetAttribute=-1===f?void 0:f,a.packedLength=y,a},L.fromPositions=function(e){e=Object(c["a"])(e,c["a"].EMPTY_OBJECT),i["a"].defined("options.positions",e.positions);const t={polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,arcType:e.arcType,offsetAttribute:e.offsetAttribute};return new L(t)},L.createGeometry=function(e){const t=e._ellipsoid,a=e._granularity,n=e._polygonHierarchy,i=e._perPositionHeight,c=e._arcType,u=_["a"].polygonOutlinesFromHierarchy(n,!i,t);if(0===u.length)return;let p;const h=[],f=O["a"].chordLength(a,t.maximumRadius),y=e._height,w=e._extrudedHeight,E=e._perPositionHeightExtrude||!O["a"].equalsEpsilon(y,w,0,O["a"].EPSILON2);let A,P;if(E)for(P=0;P<u.length;P++){if(p=I(t,u[P],f,i,c),p.geometry=_["a"].scaleToGeodeticHeightExtruded(p.geometry,y,w,t,i),Object(l["a"])(e._offsetAttribute)){const t=p.geometry.attributes.position.values.length/3;let a=new Uint8Array(t);e._offsetAttribute===m["a"].TOP?a=Object(o["a"])(a,1,0,t/2):(A=e._offsetAttribute===m["a"].NONE?0:1,a=Object(o["a"])(a,A)),p.geometry.attributes.applyOffset=new g["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}h.push(p)}else for(P=0;P<u.length;P++){if(p=j(t,u[P],f,i,c),p.geometry.attributes.position.values=T["a"].scaleToGeodeticHeight(p.geometry.attributes.position.values,y,t,!i),Object(l["a"])(e._offsetAttribute)){const t=p.geometry.attributes.position.values.length,a=new Uint8Array(t/3);A=e._offsetAttribute===m["a"].NONE?0:1,Object(o["a"])(a,A),p.geometry.attributes.applyOffset=new g["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}h.push(p)}const v=b["a"].combineInstances(h)[0],L=r["a"].fromVertices(v.attributes.position.values);return new d["a"]({attributes:v.attributes,indices:v.indices,primitiveType:v.primitiveType,boundingSphere:L,offsetAttribute:e._offsetAttribute})},t["a"]=L},"5be3":function(e,t,a){"use strict";var n=a("554f"),o=a("6af0"),r=a("8656"),i=a("85b2"),s=a("dde0"),c=a("cbf0"),l=a("4b0b"),u=a("1a5d"),p=a("c937"),h=a("e2a6"),d=a("e107"),g=a("5a72"),f=a("f3a4"),y=a("0c02"),m=a("2642"),b=a("b8b5"),w=a("97ea"),O=a("9d76"),_=a("82ba"),T=a("f59e");function E(e,t){const a=new y["a"];a.position=new f["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:e});const n=t.length,o=a.position.values.length/3,i=e.length/3,s=i/n,l=m["a"].createTypedArray(o,2*n*(s+1));let u,p,h=0;u=0;let d=u*n;for(p=0;p<n-1;p++)l[h++]=p+d,l[h++]=p+d+1;for(l[h++]=n-1+d,l[h++]=d,u=s-1,d=u*n,p=0;p<n-1;p++)l[h++]=p+d,l[h++]=p+d+1;for(l[h++]=n-1+d,l[h++]=d,u=0;u<s-1;u++){const e=n*u,t=e+n;for(p=0;p<n;p++)l[h++]=p+e,l[h++]=p+t}const b=new g["a"]({attributes:a,indices:m["a"].createTypedArray(o,l),boundingSphere:r["a"].fromVertices(e),primitiveType:_["a"].LINES});return b}function A(e){e=Object(u["a"])(e,u["a"].EMPTY_OBJECT);const t=e.polylinePositions,a=e.shapePositions;if(!Object(p["a"])(t))throw new h["a"]("options.polylinePositions is required.");if(!Object(p["a"])(a))throw new h["a"]("options.shapePositions is required.");this._positions=t,this._shape=a,this._ellipsoid=d["a"].clone(Object(u["a"])(e.ellipsoid,d["a"].WGS84)),this._cornerType=Object(u["a"])(e.cornerType,l["a"].ROUNDED),this._granularity=Object(u["a"])(e.granularity,b["a"].RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeOutlineGeometry";let n=1+t.length*s["a"].packedLength;n+=1+a.length*i["a"].packedLength,this.packedLength=n+d["a"].packedLength+2}A.pack=function(e,t,a){if(!Object(p["a"])(e))throw new h["a"]("value is required");if(!Object(p["a"])(t))throw new h["a"]("array is required");let n;a=Object(u["a"])(a,0);const o=e._positions;let r=o.length;for(t[a++]=r,n=0;n<r;++n,a+=s["a"].packedLength)s["a"].pack(o[n],t,a);const c=e._shape;for(r=c.length,t[a++]=r,n=0;n<r;++n,a+=i["a"].packedLength)i["a"].pack(c[n],t,a);return d["a"].pack(e._ellipsoid,t,a),a+=d["a"].packedLength,t[a++]=e._cornerType,t[a]=e._granularity,t};const P=d["a"].clone(d["a"].UNIT_SPHERE),v={polylinePositions:void 0,shapePositions:void 0,ellipsoid:P,height:void 0,cornerType:void 0,granularity:void 0};A.unpack=function(e,t,a){if(!Object(p["a"])(e))throw new h["a"]("array is required");let n;t=Object(u["a"])(t,0);let o=e[t++];const r=new Array(o);for(n=0;n<o;++n,t+=s["a"].packedLength)r[n]=s["a"].unpack(e,t);o=e[t++];const c=new Array(o);for(n=0;n<o;++n,t+=i["a"].packedLength)c[n]=i["a"].unpack(e,t);const l=d["a"].unpack(e,t,P);t+=d["a"].packedLength;const g=e[t++],f=e[t];return Object(p["a"])(a)?(a._positions=r,a._shape=c,a._ellipsoid=d["a"].clone(l,a._ellipsoid),a._cornerType=g,a._granularity=f,a):(v.polylinePositions=r,v.shapePositions=c,v.cornerType=g,v.granularity=f,new A(v))};const j=new o["a"];A.createGeometry=function(e){const t=e._positions,a=Object(n["a"])(t,s["a"].equalsEpsilon);let r=e._shape;if(r=O["a"].removeDuplicatesFromShape(r),a.length<2||r.length<3)return;w["a"].computeWindingOrder2D(r)===T["a"].CLOCKWISE&&r.reverse();const i=o["a"].fromPoints(r,j),c=O["a"].computePositions(a,r,i,e,!1);return E(c,r)},t["a"]=A},"68a5":function(e,t,a){"use strict";var n=a("554f"),o=a("6af0"),r=a("8656"),i=a("85b2"),s=a("dde0"),c=a("cbf0"),l=a("4b0b"),u=a("1a5d"),p=a("c937"),h=a("e2a6"),d=a("e107"),g=a("5a72"),f=a("f3a4"),y=a("0c02"),m=a("f6fe"),b=a("2642"),w=a("b8b5"),O=a("e47d"),_=a("97ea"),T=a("9d76"),E=a("82ba"),A=a("514d"),P=a("f59e");function v(e,t,a,n){const o=new y["a"];n.position&&(o.position=new f["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:e}));const i=t.length,s=e.length/3,l=(s-2*i)/(2*i),u=_["a"].triangulate(t),p=(l-1)*i*6+2*u.length,h=b["a"].createTypedArray(s,p);let d,w,T,A,P,v;const j=2*i;let I=0;for(d=0;d<l-1;d++){for(w=0;w<i-1;w++)T=2*w+d*i*2,v=T+j,A=T+1,P=A+j,h[I++]=A,h[I++]=T,h[I++]=P,h[I++]=P,h[I++]=T,h[I++]=v;T=2*i-2+d*i*2,A=T+1,P=A+j,v=T+j,h[I++]=A,h[I++]=T,h[I++]=P,h[I++]=P,h[I++]=T,h[I++]=v}if(n.st||n.tangent||n.bitangent){const e=new Float32Array(2*s),n=1/(l-1),r=1/a.height,u=a.height/2;let p,h,g=0;for(d=0;d<l;d++){for(p=d*n,h=r*(t[0].y+u),e[g++]=p,e[g++]=h,w=1;w<i;w++)h=r*(t[w].y+u),e[g++]=p,e[g++]=h,e[g++]=p,e[g++]=h;h=r*(t[0].y+u),e[g++]=p,e[g++]=h}for(w=0;w<i;w++)p=0,h=r*(t[w].y+u),e[g++]=p,e[g++]=h;for(w=0;w<i;w++)p=(l-1)*n,h=r*(t[w].y+u),e[g++]=p,e[g++]=h;o.st=new f["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const L=s-2*i;for(d=0;d<u.length;d+=3){const e=u[d]+L,t=u[d+1]+L,a=u[d+2]+L;h[I++]=e,h[I++]=t,h[I++]=a,h[I++]=a+i,h[I++]=t+i,h[I++]=e+i}let x=new g["a"]({attributes:o,indices:h,boundingSphere:r["a"].fromVertices(e),primitiveType:E["a"].TRIANGLES});if(n.normal&&(x=m["a"].computeNormal(x)),n.tangent||n.bitangent){try{x=m["a"].computeTangentAndBitangent(x)}catch(S){Object(O["a"])("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}n.tangent||(x.attributes.tangent=void 0),n.bitangent||(x.attributes.bitangent=void 0),n.st||(x.attributes.st=void 0)}return x}function j(e){e=Object(u["a"])(e,u["a"].EMPTY_OBJECT);const t=e.polylinePositions,a=e.shapePositions;if(!Object(p["a"])(t))throw new h["a"]("options.polylinePositions is required.");if(!Object(p["a"])(a))throw new h["a"]("options.shapePositions is required.");this._positions=t,this._shape=a,this._ellipsoid=d["a"].clone(Object(u["a"])(e.ellipsoid,d["a"].WGS84)),this._cornerType=Object(u["a"])(e.cornerType,l["a"].ROUNDED),this._vertexFormat=A["a"].clone(Object(u["a"])(e.vertexFormat,A["a"].DEFAULT)),this._granularity=Object(u["a"])(e.granularity,w["a"].RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let n=1+t.length*s["a"].packedLength;n+=1+a.length*i["a"].packedLength,this.packedLength=n+d["a"].packedLength+A["a"].packedLength+2}j.pack=function(e,t,a){if(!Object(p["a"])(e))throw new h["a"]("value is required");if(!Object(p["a"])(t))throw new h["a"]("array is required");let n;a=Object(u["a"])(a,0);const o=e._positions;let r=o.length;for(t[a++]=r,n=0;n<r;++n,a+=s["a"].packedLength)s["a"].pack(o[n],t,a);const c=e._shape;for(r=c.length,t[a++]=r,n=0;n<r;++n,a+=i["a"].packedLength)i["a"].pack(c[n],t,a);return d["a"].pack(e._ellipsoid,t,a),a+=d["a"].packedLength,A["a"].pack(e._vertexFormat,t,a),a+=A["a"].packedLength,t[a++]=e._cornerType,t[a]=e._granularity,t};const I=d["a"].clone(d["a"].UNIT_SPHERE),L=new A["a"],x={polylinePositions:void 0,shapePositions:void 0,ellipsoid:I,vertexFormat:L,cornerType:void 0,granularity:void 0};j.unpack=function(e,t,a){if(!Object(p["a"])(e))throw new h["a"]("array is required");let n;t=Object(u["a"])(t,0);let o=e[t++];const r=new Array(o);for(n=0;n<o;++n,t+=s["a"].packedLength)r[n]=s["a"].unpack(e,t);o=e[t++];const c=new Array(o);for(n=0;n<o;++n,t+=i["a"].packedLength)c[n]=i["a"].unpack(e,t);const l=d["a"].unpack(e,t,I);t+=d["a"].packedLength;const g=A["a"].unpack(e,t,L);t+=A["a"].packedLength;const f=e[t++],y=e[t];return Object(p["a"])(a)?(a._positions=r,a._shape=c,a._ellipsoid=d["a"].clone(l,a._ellipsoid),a._vertexFormat=A["a"].clone(g,a._vertexFormat),a._cornerType=f,a._granularity=y,a):(x.polylinePositions=r,x.shapePositions=c,x.cornerType=f,x.granularity=y,new j(x))};const S=new o["a"];j.createGeometry=function(e){const t=e._positions,a=Object(n["a"])(t,s["a"].equalsEpsilon);let r=e._shape;if(r=T["a"].removeDuplicatesFromShape(r),a.length<2||r.length<3)return;_["a"].computeWindingOrder2D(r)===P["a"].CLOCKWISE&&r.reverse();const i=o["a"].fromPoints(r,S),c=T["a"].computePositions(a,r,i,e,!0);return v(c,r,i,e._vertexFormat)},t["a"]=j},7860:function(e,t,a){"use strict";var n=a("c937");function o(e,t){this.positions=Object(n["a"])(e)?e:[],this.holes=Object(n["a"])(t)?t:[]}t["a"]=o},"7def":function(e,t,a){"use strict";var n=a("0e04"),o=a("554f"),r=a("85b2"),i=a("dde0"),s=a("8d54"),c=a("cbf0"),l=a("1a5d"),u=a("c937"),p=a("e107"),h=a("2039"),d=a("5a72"),g=a("f3a4"),f=a("0c02"),y=a("f6fe"),m=a("2642"),b=a("b8b5"),w=a("d767"),O=a("97ea"),_=a("82ba"),T=a("1b9c"),E=a("a5ef"),A=a("f59e");const P={computeHierarchyPackedLength:function(e){let t=0;const a=[e];while(a.length>0){const e=a.pop();if(!Object(u["a"])(e))continue;t+=2;const n=e.positions,o=e.holes;if(Object(u["a"])(n)&&(t+=n.length*i["a"].packedLength),Object(u["a"])(o)){const e=o.length;for(let t=0;t<e;++t)a.push(o[t])}}return t},packPolygonHierarchy:function(e,t,a){const n=[e];while(n.length>0){const e=n.pop();if(!Object(u["a"])(e))continue;const o=e.positions,r=e.holes;if(t[a++]=Object(u["a"])(o)?o.length:0,t[a++]=Object(u["a"])(r)?r.length:0,Object(u["a"])(o)){const e=o.length;for(let n=0;n<e;++n,a+=3)i["a"].pack(o[n],t,a)}if(Object(u["a"])(r)){const e=r.length;for(let t=0;t<e;++t)n.push(r[t])}}return a},unpackPolygonHierarchy:function(e,t){const a=e[t++],n=e[t++],o=new Array(a),r=n>0?new Array(n):void 0;for(let s=0;s<a;++s,t+=i["a"].packedLength)o[s]=i["a"].unpack(e,t);for(let i=0;i<n;++i)r[i]=P.unpackPolygonHierarchy(e,t),t=r[i].startingIndex,delete r[i].startingIndex;return{positions:o,holes:r,startingIndex:t}}},v=new i["a"];function j(e,t,a,n){return i["a"].subtract(t,e,v),i["a"].multiplyByScalar(v,a/n,v),i["a"].add(e,v,v),[v.x,v.y,v.z]}P.subdivideLineCount=function(e,t,a){const n=i["a"].distance(e,t),o=n/a,r=Math.max(0,Math.ceil(b["a"].log2(o)));return Math.pow(2,r)};const I=new s["a"],L=new s["a"],x=new s["a"],S=new i["a"];P.subdivideRhumbLineCount=function(e,t,a,n){const o=e.cartesianToCartographic(t,I),r=e.cartesianToCartographic(a,L),i=new h["a"](o,r,e),s=i.surfaceDistance/n,c=Math.max(0,Math.ceil(b["a"].log2(s)));return Math.pow(2,c)},P.subdivideLine=function(e,t,a,n){const o=P.subdivideLineCount(e,t,a),r=i["a"].distance(e,t),s=r/o;Object(u["a"])(n)||(n=[]);const c=n;c.length=3*o;let l=0;for(let i=0;i<o;i++){const a=j(e,t,i*s,r);c[l++]=a[0],c[l++]=a[1],c[l++]=a[2]}return c},P.subdivideRhumbLine=function(e,t,a,n,o){const r=e.cartesianToCartographic(t,I),i=e.cartesianToCartographic(a,L),s=new h["a"](r,i,e),c=s.surfaceDistance/n,l=Math.max(0,Math.ceil(b["a"].log2(c))),p=Math.pow(2,l),d=s.surfaceDistance/p;Object(u["a"])(o)||(o=[]);const g=o;g.length=3*p;let f=0;for(let u=0;u<p;u++){const t=s.interpolateUsingSurfaceDistance(u*d,x),a=e.cartographicToCartesian(t,S);g[f++]=a.x,g[f++]=a.y,g[f++]=a.z}return g};const N=new i["a"],D=new i["a"],R=new i["a"],k=new i["a"];P.scaleToGeodeticHeightExtruded=function(e,t,a,n,o){n=Object(l["a"])(n,p["a"].WGS84);const r=N;let s=D;const c=R;let h=k;if(Object(u["a"])(e)&&Object(u["a"])(e.attributes)&&Object(u["a"])(e.attributes.position)){const l=e.attributes.position.values,u=l.length/2;for(let e=0;e<u;e+=3)i["a"].fromArray(l,e,c),n.geodeticSurfaceNormal(c,r),h=n.scaleToGeodeticSurface(c,h),s=i["a"].multiplyByScalar(r,a,s),s=i["a"].add(h,s,s),l[e+u]=s.x,l[e+1+u]=s.y,l[e+2+u]=s.z,o&&(h=i["a"].clone(c,h)),s=i["a"].multiplyByScalar(r,t,s),s=i["a"].add(h,s,s),l[e]=s.x,l[e+1]=s.y,l[e+2]=s.z}return e},P.polygonOutlinesFromHierarchy=function(e,t,a){const n=[],r=new E["a"];let s,c,l;r.enqueue(e);while(0!==r.length){const e=r.dequeue();let p=e.positions;if(t)for(l=p.length,s=0;s<l;s++)a.scaleToGeodeticSurface(p[s],p[s]);if(p=Object(o["a"])(p,i["a"].equalsEpsilon,!0),p.length<3)continue;const h=e.holes?e.holes.length:0;for(s=0;s<h;s++){const p=e.holes[s];let h=p.positions;if(t)for(l=h.length,c=0;c<l;++c)a.scaleToGeodeticSurface(h[c],h[c]);if(h=Object(o["a"])(h,i["a"].equalsEpsilon,!0),h.length<3)continue;n.push(h);let d=0;for(Object(u["a"])(p.holes)&&(d=p.holes.length),c=0;c<d;c++)r.enqueue(p.holes[c])}n.push(p)}return n},P.polygonsFromHierarchy=function(e,t,a,n){const r=[],s=[],c=new E["a"];c.enqueue(e);while(0!==c.length){const e=c.dequeue();let l=e.positions;const p=e.holes;let h,d;if(a)for(d=l.length,h=0;h<d;h++)n.scaleToGeodeticSurface(l[h],l[h]);if(l=Object(o["a"])(l,i["a"].equalsEpsilon,!0),l.length<3)continue;let g=t(l);if(!Object(u["a"])(g))continue;const f=[];let y=O["a"].computeWindingOrder2D(g);y===A["a"].CLOCKWISE&&(g.reverse(),l=l.slice().reverse());let m=l.slice();const b=Object(u["a"])(p)?p.length:0,w=[];let _;for(h=0;h<b;h++){const e=p[h];let r=e.positions;if(a)for(d=r.length,_=0;_<d;++_)n.scaleToGeodeticSurface(r[_],r[_]);if(r=Object(o["a"])(r,i["a"].equalsEpsilon,!0),r.length<3)continue;const s=t(r);if(!Object(u["a"])(s))continue;y=O["a"].computeWindingOrder2D(s),y===A["a"].CLOCKWISE&&(s.reverse(),r=r.slice().reverse()),w.push(r),f.push(m.length),m=m.concat(r),g=g.concat(s);let l=0;for(Object(u["a"])(e.holes)&&(l=e.holes.length),_=0;_<l;_++)c.enqueue(e.holes[_])}r.push({outerRing:l,holes:w}),s.push({positions:m,positions2D:g,holes:f})}return{hierarchy:r,polygons:s}};const H=new r["a"],G=new i["a"],C=new T["a"],F=new w["a"];P.computeBoundingRectangle=function(e,t,a,n,o){const r=T["a"].fromAxisAngle(e,n,C),s=w["a"].fromQuaternion(r,F);let c=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,p=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY;const d=a.length;for(let g=0;g<d;++g){const e=i["a"].clone(a[g],G);w["a"].multiplyByVector(s,e,e);const n=t(e,H);Object(u["a"])(n)&&(c=Math.min(c,n.x),l=Math.max(l,n.x),p=Math.min(p,n.y),h=Math.max(h,n.y))}return o.x=c,o.y=p,o.width=l-c,o.height=h-p,o},P.createGeometryFromPositions=function(e,t,a,o,r,i){let s=O["a"].triangulate(t.positions2D,t.holes);s.length<3&&(s=[0,1,2]);const l=t.positions;if(o){const e=l.length,t=new Array(3*e);let a=0;for(let o=0;o<e;o++){const e=l[o];t[a++]=e.x,t[a++]=e.y,t[a++]=e.z}const n=new d["a"]({attributes:{position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:t})},indices:s,primitiveType:_["a"].TRIANGLES});return r.normal?y["a"].computeNormal(n):n}return i===n["a"].GEODESIC?O["a"].computeSubdivision(e,l,s,a):i===n["a"].RHUMB?O["a"].computeRhumbLineSubdivision(e,l,s,a):void 0};const B=[],z=new i["a"],U=new i["a"];P.computeWallGeometry=function(e,t,a,o,r){let s,l,u,p,h,y=e.length,w=0;if(o)for(l=3*y*2,s=new Array(2*l),u=0;u<y;u++)p=e[u],h=e[(u+1)%y],s[w]=s[w+l]=p.x,++w,s[w]=s[w+l]=p.y,++w,s[w]=s[w+l]=p.z,++w,s[w]=s[w+l]=h.x,++w,s[w]=s[w+l]=h.y,++w,s[w]=s[w+l]=h.z,++w;else{const o=b["a"].chordLength(a,t.maximumRadius);let i=0;if(r===n["a"].GEODESIC)for(u=0;u<y;u++)i+=P.subdivideLineCount(e[u],e[(u+1)%y],o);else if(r===n["a"].RHUMB)for(u=0;u<y;u++)i+=P.subdivideRhumbLineCount(t,e[u],e[(u+1)%y],o);for(l=3*(i+y),s=new Array(2*l),u=0;u<y;u++){let a;p=e[u],h=e[(u+1)%y],r===n["a"].GEODESIC?a=P.subdivideLine(p,h,o,B):r===n["a"].RHUMB&&(a=P.subdivideRhumbLine(t,p,h,o,B));const i=a.length;for(let e=0;e<i;++e,++w)s[w]=a[e],s[w+l]=a[e];s[w]=h.x,s[w+l]=h.x,++w,s[w]=h.y,s[w+l]=h.y,++w,s[w]=h.z,s[w+l]=h.z,++w}}y=s.length;const O=m["a"].createTypedArray(y/3,y-6*e.length);let T=0;for(y/=6,u=0;u<y;u++){const e=u,t=e+1,a=e+y,n=a+1;p=i["a"].fromArray(s,3*e,z),h=i["a"].fromArray(s,3*t,U),i["a"].equalsEpsilon(p,h,b["a"].EPSILON10,b["a"].EPSILON10)||(O[T++]=e,O[T++]=a,O[T++]=t,O[T++]=t,O[T++]=a,O[T++]=n)}return new d["a"]({attributes:new f["a"]({position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:s})}),indices:O,primitiveType:_["a"].TRIANGLES})},t["a"]=P},"82ba":function(e,t,a){"use strict";var n=a("cedf");const o={POINTS:n["a"].POINTS,LINES:n["a"].LINES,LINE_LOOP:n["a"].LINE_LOOP,LINE_STRIP:n["a"].LINE_STRIP,TRIANGLES:n["a"].TRIANGLES,TRIANGLE_STRIP:n["a"].TRIANGLE_STRIP,TRIANGLE_FAN:n["a"].TRIANGLE_FAN,validate:function(e){return e===o.POINTS||e===o.LINES||e===o.LINE_LOOP||e===o.LINE_STRIP||e===o.TRIANGLES||e===o.TRIANGLE_STRIP||e===o.TRIANGLE_FAN}};t["a"]=Object.freeze(o)},"97ea":function(e,t,a){"use strict";var n=a("e865"),o=a("85b2"),r=a("dde0"),i=a("8d54"),s=a("ae9b"),c=a("cbf0"),l=a("1a5d"),u=a("c937"),p=a("e107"),h=a("2039"),d=a("5a72"),g=a("f3a4"),f=a("b8b5"),y=a("82ba"),m=a("f59e");const b=new r["a"],w=new r["a"],O={computeArea2D:function(e){s["a"].defined("positions",e),s["a"].typeOf.number.greaterThanOrEquals("positions.length",e.length,3);const t=e.length;let a=0;for(let n=t-1,o=0;o<t;n=o++){const t=e[n],r=e[o];a+=t.x*r.y-r.x*t.y}return.5*a},computeWindingOrder2D:function(e){const t=O.computeArea2D(e);return t>0?m["a"].COUNTER_CLOCKWISE:m["a"].CLOCKWISE},triangulate:function(e,t){s["a"].defined("positions",e);const a=o["a"].packArray(e);return Object(n["a"])(a,t,2)}},_=new r["a"],T=new r["a"],E=new r["a"],A=new r["a"],P=new r["a"],v=new r["a"],j=new r["a"];O.computeSubdivision=function(e,t,a,n){n=Object(l["a"])(n,f["a"].RADIANS_PER_DEGREE),s["a"].typeOf.object("ellipsoid",e),s["a"].defined("positions",t),s["a"].defined("indices",a),s["a"].typeOf.number.greaterThanOrEquals("indices.length",a.length,3),s["a"].typeOf.number.equals("indices.length % 3","0",a.length%3,0),s["a"].typeOf.number.greaterThan("granularity",n,0);const o=a.slice(0);let i;const p=t.length,h=new Array(3*p);let m=0;for(i=0;i<p;i++){const e=t[i];h[m++]=e.x,h[m++]=e.y,h[m++]=e.z}const b=[],w={},O=e.maximumRadius,I=f["a"].chordLength(n,O),L=I*I;while(o.length>0){const e=o.pop(),t=o.pop(),a=o.pop(),n=r["a"].fromArray(h,3*a,_),s=r["a"].fromArray(h,3*t,T),c=r["a"].fromArray(h,3*e,E),l=r["a"].multiplyByScalar(r["a"].normalize(n,A),O,A),p=r["a"].multiplyByScalar(r["a"].normalize(s,P),O,P),d=r["a"].multiplyByScalar(r["a"].normalize(c,v),O,v),g=r["a"].magnitudeSquared(r["a"].subtract(l,p,j)),f=r["a"].magnitudeSquared(r["a"].subtract(p,d,j)),y=r["a"].magnitudeSquared(r["a"].subtract(d,l,j)),m=Math.max(g,f,y);let I,x;m>L?g===m?(I=`${Math.min(a,t)} ${Math.max(a,t)}`,i=w[I],Object(u["a"])(i)||(x=r["a"].add(n,s,j),r["a"].multiplyByScalar(x,.5,x),h.push(x.x,x.y,x.z),i=h.length/3-1,w[I]=i),o.push(a,i,e),o.push(i,t,e)):f===m?(I=`${Math.min(t,e)} ${Math.max(t,e)}`,i=w[I],Object(u["a"])(i)||(x=r["a"].add(s,c,j),r["a"].multiplyByScalar(x,.5,x),h.push(x.x,x.y,x.z),i=h.length/3-1,w[I]=i),o.push(t,i,a),o.push(i,e,a)):y===m&&(I=`${Math.min(e,a)} ${Math.max(e,a)}`,i=w[I],Object(u["a"])(i)||(x=r["a"].add(c,n,j),r["a"].multiplyByScalar(x,.5,x),h.push(x.x,x.y,x.z),i=h.length/3-1,w[I]=i),o.push(e,i,t),o.push(i,a,t)):(b.push(a),b.push(t),b.push(e))}return new d["a"]({attributes:{position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:h})},indices:b,primitiveType:y["a"].TRIANGLES})};const I=new i["a"],L=new i["a"],x=new i["a"],S=new i["a"];O.computeRhumbLineSubdivision=function(e,t,a,n){n=Object(l["a"])(n,f["a"].RADIANS_PER_DEGREE),s["a"].typeOf.object("ellipsoid",e),s["a"].defined("positions",t),s["a"].defined("indices",a),s["a"].typeOf.number.greaterThanOrEquals("indices.length",a.length,3),s["a"].typeOf.number.equals("indices.length % 3","0",a.length%3,0),s["a"].typeOf.number.greaterThan("granularity",n,0);const o=a.slice(0);let i;const p=t.length,m=new Array(3*p);let b=0;for(i=0;i<p;i++){const e=t[i];m[b++]=e.x,m[b++]=e.y,m[b++]=e.z}const w=[],O={},A=e.maximumRadius,P=f["a"].chordLength(n,A),v=new h["a"](void 0,void 0,e),N=new h["a"](void 0,void 0,e),D=new h["a"](void 0,void 0,e);while(o.length>0){const t=o.pop(),a=o.pop(),n=o.pop(),s=r["a"].fromArray(m,3*n,_),c=r["a"].fromArray(m,3*a,T),l=r["a"].fromArray(m,3*t,E),p=e.cartesianToCartographic(s,I),h=e.cartesianToCartographic(c,L),d=e.cartesianToCartographic(l,x);v.setEndPoints(p,h);const g=v.surfaceDistance;N.setEndPoints(h,d);const f=N.surfaceDistance;D.setEndPoints(d,p);const y=D.surfaceDistance,b=Math.max(g,f,y);let A,R,k,H;b>P?g===b?(A=`${Math.min(n,a)} ${Math.max(n,a)}`,i=O[A],Object(u["a"])(i)||(R=v.interpolateUsingFraction(.5,S),k=.5*(p.height+h.height),H=r["a"].fromRadians(R.longitude,R.latitude,k,e,j),m.push(H.x,H.y,H.z),i=m.length/3-1,O[A]=i),o.push(n,i,t),o.push(i,a,t)):f===b?(A=`${Math.min(a,t)} ${Math.max(a,t)}`,i=O[A],Object(u["a"])(i)||(R=N.interpolateUsingFraction(.5,S),k=.5*(h.height+d.height),H=r["a"].fromRadians(R.longitude,R.latitude,k,e,j),m.push(H.x,H.y,H.z),i=m.length/3-1,O[A]=i),o.push(a,i,n),o.push(i,t,n)):y===b&&(A=`${Math.min(t,n)} ${Math.max(t,n)}`,i=O[A],Object(u["a"])(i)||(R=D.interpolateUsingFraction(.5,S),k=.5*(d.height+p.height),H=r["a"].fromRadians(R.longitude,R.latitude,k,e,j),m.push(H.x,H.y,H.z),i=m.length/3-1,O[A]=i),o.push(t,i,a),o.push(i,n,a)):(w.push(n),w.push(a),w.push(t))}return new d["a"]({attributes:{position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:m})},indices:w,primitiveType:y["a"].TRIANGLES})},O.scaleToGeodeticHeight=function(e,t,a,n){a=Object(l["a"])(a,p["a"].WGS84);let o=b,i=w;if(t=Object(l["a"])(t,0),n=Object(l["a"])(n,!0),Object(u["a"])(e)){const s=e.length;for(let c=0;c<s;c+=3)r["a"].fromArray(e,c,i),n&&(i=a.scaleToGeodeticSurface(i,i)),0!==t&&(o=a.geodeticSurfaceNormal(i,o),r["a"].multiplyByScalar(o,t,o),r["a"].add(i,o,i)),e[c]=i.x,e[c+1]=i.y,e[c+2]=i.z}return e},t["a"]=O},"9d76":function(e,t,a){"use strict";var n=a("85b2"),o=a("dde0"),r=a("6b82"),i=a("8d54"),s=a("4b0b"),c=a("7e56"),l=a("b8b5"),u=a("d767"),p=a("722e"),h=a("2c95"),d=a("1b9c"),g=a("6f7c"),f=a("e47d");const y=[new o["a"],new o["a"]],m=new o["a"],b=new o["a"],w=new o["a"],O=new o["a"],_=new o["a"],T=new o["a"],E=new o["a"],A=new o["a"],P=new o["a"],v=new o["a"],j=new o["a"],I={};let L=new i["a"];function x(e,t){const a=new Array(e.length);for(let n=0;n<e.length;n++){const o=e[n];L=t.cartesianToCartographic(o,L),a[n]=L.height,e[n]=t.scaleToGeodeticSurface(o,o)}return a}function S(e,t,a,n){const r=e[0],i=e[1],s=o["a"].angleBetween(r,i),c=Math.ceil(s/n),l=new Array(c);let u;if(t===a){for(u=0;u<c;u++)l[u]=t;return l.push(a),l}const p=a-t,h=p/c;for(u=1;u<c;u++){const e=t+u*h;l[u]=e}return l[0]=t,l.push(a),l}const N=new o["a"],D=new o["a"];function R(e,t,a,r){const i=new c["a"](a,r),s=i.projectPointOntoPlane(o["a"].add(a,e,N),N),l=i.projectPointOntoPlane(o["a"].add(a,t,D),D),u=n["a"].angleBetween(s,l);return l.x*s.y-l.y*s.x>=0?-u:u}const k=new o["a"](-1,0,0);let H=new p["a"];const G=new p["a"];let C=new u["a"];const F=u["a"].IDENTITY.clone(),B=new o["a"],z=new r["a"],U=new o["a"];function M(e,t,a,n,r,i,s,c){let l=B,h=z;H=g["a"].eastNorthUpToFixedFrame(e,r,H),l=p["a"].multiplyByPointAsVector(H,k,l),l=o["a"].normalize(l,l);const d=R(l,t,e,r);C=u["a"].fromRotationZ(d,C),U.z=i,H=p["a"].multiplyTransformation(H,p["a"].fromRotationTranslation(C,U,G),H);const f=F;f[0]=s;for(let g=0;g<c;g++)for(let e=0;e<a.length;e+=3)h=o["a"].fromArray(a,e,h),h=u["a"].multiplyByVector(f,h,h),h=p["a"].multiplyByPoint(H,h,h),n.push(h.x,h.y,h.z);return n}const q=new o["a"];function V(e,t,a,n,r,i,s){for(let c=0;c<e.length;c+=3){const l=o["a"].fromArray(e,c,q);n=M(l,t,a,n,r,i[c/3],s,1)}return n}function W(e,t){const a=e.length,n=new Array(6*a);let o=0;const r=t.x+t.width/2,i=t.y+t.height/2;let s=e[0];n[o++]=s.x-r,n[o++]=0,n[o++]=s.y-i;for(let c=1;c<a;c++){s=e[c];const t=s.x-r,a=s.y-i;n[o++]=t,n[o++]=0,n[o++]=a,n[o++]=t,n[o++]=0,n[o++]=a}return s=e[0],n[o++]=s.x-r,n[o++]=0,n[o++]=s.y-i,n}function Y(e,t){const a=e.length,n=new Array(3*a);let o=0;const r=t.x+t.width/2,i=t.y+t.height/2;for(let s=0;s<a;s++)n[o++]=e[s].x-r,n[o++]=0,n[o++]=e[s].y-i;return n}const $=new d["a"],K=new o["a"],Z=new u["a"];function J(e,t,a,n,r,i,c,p,h,g){const f=o["a"].angleBetween(o["a"].subtract(t,e,v),o["a"].subtract(a,e,j)),y=n===s["a"].BEVELED?0:Math.ceil(f/l["a"].toRadians(5));let m,b,w;if(m=r?u["a"].fromQuaternion(d["a"].fromAxisAngle(o["a"].negate(e,v),f/(y+1),$),Z):u["a"].fromQuaternion(d["a"].fromAxisAngle(e,f/(y+1),$),Z),t=o["a"].clone(t,K),y>0){const a=g?2:1;for(let n=0;n<y;n++)t=u["a"].multiplyByVector(m,t,t),b=o["a"].subtract(t,e,v),b=o["a"].normalize(b,b),r||(b=o["a"].negate(b,b)),w=i.scaleToGeodeticSurface(t,j),c=M(w,b,p,c,i,h,1,a)}else b=o["a"].subtract(t,e,v),b=o["a"].normalize(b,b),r||(b=o["a"].negate(b,b)),w=i.scaleToGeodeticSurface(t,j),c=M(w,b,p,c,i,h,1,1),a=o["a"].clone(a,K),b=o["a"].subtract(a,e,v),b=o["a"].normalize(b,b),r||(b=o["a"].negate(b,b)),w=i.scaleToGeodeticSurface(a,j),c=M(w,b,p,c,i,h,1,1);return c}I.removeDuplicatesFromShape=function(e){const t=e.length,a=[];for(let o=t-1,r=0;r<t;o=r++){const t=e[o],i=e[r];n["a"].equals(t,i)||a.push(i)}return a},I.angleIsGreaterThanPi=function(e,t,a,n){const r=new c["a"](a,n),i=r.projectPointOntoPlane(o["a"].add(a,e,N),N),s=r.projectPointOntoPlane(o["a"].add(a,t,D),D);return s.x*i.y-s.y*i.x>=0};const X=new o["a"],Q=new o["a"];I.computePositions=function(e,t,a,n,r){const i=n._ellipsoid,c=x(e,i),u=n._granularity,p=n._cornerType,d=r?W(t,a):Y(t,a),g=r?Y(t,a):void 0,j=a.height/2,L=a.width/2;let N=e.length,D=[],R=r?[]:void 0,k=m,H=b,G=w,C=O,F=_,B=T,z=E,U=A,q=P,$=e[0],K=e[1];C=i.geodeticSurfaceNormal($,C),k=o["a"].subtract(K,$,k),k=o["a"].normalize(k,k),U=o["a"].cross(C,k,U),U=o["a"].normalize(U,U);let Z,ee,te=c[0],ae=c[1];r&&(R=M($,U,g,R,i,te+j,1,1)),q=o["a"].clone($,q),$=K,H=o["a"].negate(k,H);for(let m=1;m<N-1;m++){const t=r?2:1;if(K=e[m+1],$.equals(K)){Object(f["a"])("Positions are too close and are considered equivalent with rounding error.");continue}k=o["a"].subtract(K,$,k),k=o["a"].normalize(k,k),G=o["a"].add(k,H,G),G=o["a"].normalize(G,G),C=i.geodeticSurfaceNormal($,C);const a=o["a"].multiplyByScalar(C,o["a"].dot(k,C),X);o["a"].subtract(k,a,a),o["a"].normalize(a,a);const n=o["a"].multiplyByScalar(C,o["a"].dot(H,C),Q);o["a"].subtract(H,n,n),o["a"].normalize(n,n);const g=!l["a"].equalsEpsilon(Math.abs(o["a"].dot(a,n)),1,l["a"].EPSILON7);if(g){G=o["a"].cross(G,C,G),G=o["a"].cross(C,G,G),G=o["a"].normalize(G,G);const e=1/Math.max(.25,o["a"].magnitude(o["a"].cross(G,H,v))),a=I.angleIsGreaterThanPi(k,H,$,i);a?(F=o["a"].add($,o["a"].multiplyByScalar(G,e*L,G),F),B=o["a"].add(F,o["a"].multiplyByScalar(U,L,B),B),y[0]=o["a"].clone(q,y[0]),y[1]=o["a"].clone(B,y[1]),Z=S(y,te+j,ae+j,u),ee=h["a"].generateArc({positions:y,granularity:u,ellipsoid:i}),D=V(ee,U,d,D,i,Z,1),U=o["a"].cross(C,k,U),U=o["a"].normalize(U,U),z=o["a"].add(F,o["a"].multiplyByScalar(U,L,z),z),p===s["a"].ROUNDED||p===s["a"].BEVELED?J(F,B,z,p,a,i,D,d,ae+j,r):(G=o["a"].negate(G,G),D=M($,G,d,D,i,ae+j,e,t)),q=o["a"].clone(z,q)):(F=o["a"].add($,o["a"].multiplyByScalar(G,e*L,G),F),B=o["a"].add(F,o["a"].multiplyByScalar(U,-L,B),B),y[0]=o["a"].clone(q,y[0]),y[1]=o["a"].clone(B,y[1]),Z=S(y,te+j,ae+j,u),ee=h["a"].generateArc({positions:y,granularity:u,ellipsoid:i}),D=V(ee,U,d,D,i,Z,1),U=o["a"].cross(C,k,U),U=o["a"].normalize(U,U),z=o["a"].add(F,o["a"].multiplyByScalar(U,-L,z),z),p===s["a"].ROUNDED||p===s["a"].BEVELED?J(F,B,z,p,a,i,D,d,ae+j,r):D=M($,G,d,D,i,ae+j,e,t),q=o["a"].clone(z,q)),H=o["a"].negate(k,H)}else D=M(q,U,d,D,i,te+j,1,1),q=$;te=ae,ae=c[m+1],$=K}y[0]=o["a"].clone(q,y[0]),y[1]=o["a"].clone($,y[1]),Z=S(y,te+j,ae+j,u),ee=h["a"].generateArc({positions:y,granularity:u,ellipsoid:i}),D=V(ee,U,d,D,i,Z,1),r&&(R=M($,U,g,R,i,ae+j,1,1)),N=D.length;const ne=r?N+R.length:N,oe=new Float64Array(ne);return oe.set(D),r&&oe.set(R,N),oe},t["a"]=I},a7b2:function(e,t,a){"use strict";var n=a("dde0"),o=a("6b82"),r=a("ae9b"),i=a("c937"),s=a("e2a6"),c=a("b8b5"),l=a("722e");function u(e,t){if(r["a"].typeOf.object("normal",e),!c["a"].equalsEpsilon(n["a"].magnitude(e),1,c["a"].EPSILON6))throw new s["a"]("normal must be normalized.");r["a"].typeOf.number("distance",t),this.normal=n["a"].clone(e),this.distance=t}u.fromPointNormal=function(e,t,a){if(r["a"].typeOf.object("point",e),r["a"].typeOf.object("normal",t),!c["a"].equalsEpsilon(n["a"].magnitude(t),1,c["a"].EPSILON6))throw new s["a"]("normal must be normalized.");const o=-n["a"].dot(t,e);return Object(i["a"])(a)?(n["a"].clone(t,a.normal),a.distance=o,a):new u(t,o)};const p=new n["a"];u.fromCartesian4=function(e,t){r["a"].typeOf.object("coefficients",e);const a=n["a"].fromCartesian4(e,p),o=e.w;if(!c["a"].equalsEpsilon(n["a"].magnitude(a),1,c["a"].EPSILON6))throw new s["a"]("normal must be normalized.");return Object(i["a"])(t)?(n["a"].clone(a,t.normal),t.distance=o,t):new u(a,o)},u.getPointDistance=function(e,t){return r["a"].typeOf.object("plane",e),r["a"].typeOf.object("point",t),n["a"].dot(e.normal,t)+e.distance};const h=new n["a"];u.projectPointOntoPlane=function(e,t,a){r["a"].typeOf.object("plane",e),r["a"].typeOf.object("point",t),Object(i["a"])(a)||(a=new n["a"]);const o=u.getPointDistance(e,t),s=n["a"].multiplyByScalar(e.normal,o,h);return n["a"].subtract(t,s,a)};const d=new l["a"],g=new o["a"],f=new n["a"];u.transform=function(e,t,a){r["a"].typeOf.object("plane",e),r["a"].typeOf.object("transform",t);const i=e.normal,s=e.distance,c=l["a"].inverseTranspose(t,d);let p=o["a"].fromElements(i.x,i.y,i.z,s,g);p=l["a"].multiplyByVector(c,p,p);const h=n["a"].fromCartesian4(p,f);return p=o["a"].divideByScalar(p,n["a"].magnitude(h),p),u.fromCartesian4(p,a)},u.clone=function(e,t){return r["a"].typeOf.object("plane",e),Object(i["a"])(t)?(n["a"].clone(e.normal,t.normal),t.distance=e.distance,t):new u(e.normal,e.distance)},u.equals=function(e,t){return r["a"].typeOf.object("left",e),r["a"].typeOf.object("right",t),e.distance===t.distance&&n["a"].equals(e.normal,t.normal)},u.ORIGIN_XY_PLANE=Object.freeze(new u(n["a"].UNIT_Z,0)),u.ORIGIN_YZ_PLANE=Object.freeze(new u(n["a"].UNIT_X,0)),u.ORIGIN_ZX_PLANE=Object.freeze(new u(n["a"].UNIT_Y,0)),t["a"]=u},c1cb:function(e,t,a){"use strict";var n=a("0e04"),o=a("554f"),r=a("8656"),i=a("dde0"),s=a("4051"),c=a("cbf0"),l=a("1a5d"),u=a("c937"),p=a("e2a6"),h=a("e107"),d=a("5a72"),g=a("f3a4"),f=a("0c02"),y=a("bd7a"),m=a("2642"),b=a("b8b5"),w=a("2c95"),O=a("82ba"),_=a("514d");const T=[];function E(e,t,a,n,o){const r=T;let i;r.length=o;const c=a.red,l=a.green,u=a.blue,p=a.alpha,h=n.red,d=n.green,g=n.blue,f=n.alpha;if(s["a"].equals(a,n)){for(i=0;i<o;i++)r[i]=s["a"].clone(a);return r}const y=(h-c)/o,m=(d-l)/o,b=(g-u)/o,w=(f-p)/o;for(i=0;i<o;i++)r[i]=new s["a"](c+i*y,l+i*m,u+i*b,p+i*w);return r}function A(e){e=Object(l["a"])(e,l["a"].EMPTY_OBJECT);const t=e.positions,a=e.colors,o=Object(l["a"])(e.width,1),r=Object(l["a"])(e.colorsPerVertex,!1);if(!Object(u["a"])(t)||t.length<2)throw new p["a"]("At least two positions are required.");if("number"!==typeof o)throw new p["a"]("width must be a number");if(Object(u["a"])(a)&&(r&&a.length<t.length||!r&&a.length<t.length-1))throw new p["a"]("colors has an invalid length.");this._positions=t,this._colors=a,this._width=o,this._colorsPerVertex=r,this._vertexFormat=_["a"].clone(Object(l["a"])(e.vertexFormat,_["a"].DEFAULT)),this._arcType=Object(l["a"])(e.arcType,n["a"].GEODESIC),this._granularity=Object(l["a"])(e.granularity,b["a"].RADIANS_PER_DEGREE),this._ellipsoid=h["a"].clone(Object(l["a"])(e.ellipsoid,h["a"].WGS84)),this._workerName="createPolylineGeometry";let c=1+t.length*i["a"].packedLength;c+=Object(u["a"])(a)?1+a.length*s["a"].packedLength:1,this.packedLength=c+h["a"].packedLength+_["a"].packedLength+4}A.pack=function(e,t,a){if(!Object(u["a"])(e))throw new p["a"]("value is required");if(!Object(u["a"])(t))throw new p["a"]("array is required");let n;a=Object(l["a"])(a,0);const o=e._positions;let r=o.length;for(t[a++]=r,n=0;n<r;++n,a+=i["a"].packedLength)i["a"].pack(o[n],t,a);const c=e._colors;for(r=Object(u["a"])(c)?c.length:0,t[a++]=r,n=0;n<r;++n,a+=s["a"].packedLength)s["a"].pack(c[n],t,a);return h["a"].pack(e._ellipsoid,t,a),a+=h["a"].packedLength,_["a"].pack(e._vertexFormat,t,a),a+=_["a"].packedLength,t[a++]=e._width,t[a++]=e._colorsPerVertex?1:0,t[a++]=e._arcType,t[a]=e._granularity,t};const P=h["a"].clone(h["a"].UNIT_SPHERE),v=new _["a"],j={positions:void 0,colors:void 0,ellipsoid:P,vertexFormat:v,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};A.unpack=function(e,t,a){if(!Object(u["a"])(e))throw new p["a"]("array is required");let n;t=Object(l["a"])(t,0);let o=e[t++];const r=new Array(o);for(n=0;n<o;++n,t+=i["a"].packedLength)r[n]=i["a"].unpack(e,t);o=e[t++];const c=o>0?new Array(o):void 0;for(n=0;n<o;++n,t+=s["a"].packedLength)c[n]=s["a"].unpack(e,t);const d=h["a"].unpack(e,t,P);t+=h["a"].packedLength;const g=_["a"].unpack(e,t,v);t+=_["a"].packedLength;const f=e[t++],y=1===e[t++],m=e[t++],b=e[t];return Object(u["a"])(a)?(a._positions=r,a._colors=c,a._ellipsoid=h["a"].clone(d,a._ellipsoid),a._vertexFormat=_["a"].clone(g,a._vertexFormat),a._width=f,a._colorsPerVertex=y,a._arcType=m,a._granularity=b,a):(j.positions=r,j.colors=c,j.width=f,j.colorsPerVertex=y,j.arcType=m,j.granularity=b,new A(j))};const I=new i["a"],L=new i["a"],x=new i["a"],S=new i["a"];A.createGeometry=function(e){const t=e._width,a=e._vertexFormat;let l=e._colors;const p=e._colorsPerVertex,h=e._arcType,_=e._granularity,A=e._ellipsoid;let P,v,j;const N=[];let D=Object(o["a"])(e._positions,i["a"].equalsEpsilon,!1,N);if(Object(u["a"])(l)&&N.length>0){let e=0,t=N[0];l=l.filter((function(a,n){let o=!1;return o=p?n===t||0===n&&1===t:n+1===t,!o||(e++,t=N[e],!1)}))}let R=D.length;if(R<2||t<=0)return;if(h===n["a"].GEODESIC||h===n["a"].RHUMB){let e,t;h===n["a"].GEODESIC?(e=b["a"].chordLength(_,A.maximumRadius),t=w["a"].numberOfPoints):(e=_,t=w["a"].numberOfPointsRhumbLine);const a=w["a"].extractHeights(D,A);if(Object(u["a"])(l)){let a=1;for(P=0;P<R-1;++P)a+=t(D[P],D[P+1],e);const n=new Array(a);let o=0;for(P=0;P<R-1;++P){const r=D[P],i=D[P+1],c=l[P],u=t(r,i,e);if(p&&P<a){const e=l[P+1],t=E(r,i,c,e,u),a=t.length;for(v=0;v<a;++v)n[o++]=t[v]}else for(v=0;v<u;++v)n[o++]=s["a"].clone(c)}n[o]=s["a"].clone(l[l.length-1]),l=n,T.length=0}D=h===n["a"].GEODESIC?w["a"].generateCartesianArc({positions:D,minDistance:e,ellipsoid:A,height:a}):w["a"].generateCartesianRhumbArc({positions:D,granularity:e,ellipsoid:A,height:a})}R=D.length;const k=4*R-4,H=new Float64Array(3*k),G=new Float64Array(3*k),C=new Float64Array(3*k),F=new Float32Array(2*k),B=a.st?new Float32Array(2*k):void 0,z=Object(u["a"])(l)?new Uint8Array(4*k):void 0;let U,M=0,q=0,V=0,W=0;for(v=0;v<R;++v){let e,n;0===v?(U=I,i["a"].subtract(D[0],D[1],U),i["a"].add(D[0],U,U)):U=D[v-1],i["a"].clone(U,x),i["a"].clone(D[v],L),v===R-1?(U=I,i["a"].subtract(D[R-1],D[R-2],U),i["a"].add(D[R-1],U,U)):U=D[v+1],i["a"].clone(U,S),Object(u["a"])(z)&&(e=0===v||p?l[v]:l[v-1],v!==R-1&&(n=l[v]));const o=0===v?2:0,r=v===R-1?2:4;for(j=o;j<r;++j){i["a"].pack(L,H,M),i["a"].pack(x,G,M),i["a"].pack(S,C,M),M+=3;const o=j-2<0?-1:1;if(F[q++]=j%2*2-1,F[q++]=o*t,a.st&&(B[V++]=v/(R-1),B[V++]=Math.max(F[q-2],0)),Object(u["a"])(z)){const t=j<2?e:n;z[W++]=s["a"].floatToByte(t.red),z[W++]=s["a"].floatToByte(t.green),z[W++]=s["a"].floatToByte(t.blue),z[W++]=s["a"].floatToByte(t.alpha)}}}const Y=new f["a"];Y.position=new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:H}),Y.prevPosition=new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:G}),Y.nextPosition=new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:C}),Y.expandAndWidth=new g["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:F}),a.st&&(Y.st=new g["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:B})),Object(u["a"])(z)&&(Y.color=new g["a"]({componentDatatype:c["a"].UNSIGNED_BYTE,componentsPerAttribute:4,values:z,normalize:!0}));const $=m["a"].createTypedArray(k,6*R-6);let K=0,Z=0;const J=R-1;for(v=0;v<J;++v)$[Z++]=K,$[Z++]=K+2,$[Z++]=K+1,$[Z++]=K+1,$[Z++]=K+2,$[Z++]=K+3,K+=4;return new d["a"]({attributes:Y,indices:$,primitiveType:O["a"].TRIANGLES,boundingSphere:r["a"].fromPoints(D),geometryType:y["a"].POLYLINES})},t["a"]=A},fb3f:function(e,t,a){"use strict";var n=a("8656"),o=a("dde0"),r=a("ae9b"),i=a("cbf0"),s=a("c937"),c=a("5a72"),l=a("f3a4"),u=a("0c02"),p=a("82ba");function h(){this._workerName="createPlaneOutlineGeometry"}h.packedLength=0,h.pack=function(e,t){return r["a"].defined("value",e),r["a"].defined("array",t),t},h.unpack=function(e,t,a){return r["a"].defined("array",e),Object(s["a"])(a)?a:new h};const d=new o["a"](-.5,-.5,0),g=new o["a"](.5,.5,0);h.createGeometry=function(){const e=new u["a"],t=new Uint16Array(8),a=new Float64Array(12);return a[0]=d.x,a[1]=d.y,a[2]=d.z,a[3]=g.x,a[4]=d.y,a[5]=d.z,a[6]=g.x,a[7]=g.y,a[8]=d.z,a[9]=d.x,a[10]=g.y,a[11]=d.z,e.position=new l["a"]({componentDatatype:i["a"].DOUBLE,componentsPerAttribute:3,values:a}),t[0]=0,t[1]=1,t[2]=1,t[3]=2,t[4]=2,t[5]=3,t[6]=3,t[7]=0,new c["a"]({attributes:e,indices:t,primitiveType:p["a"].LINES,boundingSphere:new n["a"](o["a"].ZERO,Math.sqrt(2))})},t["a"]=h},fd3e:function(e,t,a){"use strict";var n=a("0e04"),o=a("9dc9"),r=a("6af0"),i=a("8656"),s=a("85b2"),c=a("dde0"),l=a("8d54"),u=a("ae9b"),p=a("cbf0"),h=a("1a5d"),d=a("c937"),g=a("e2a6"),f=a("e107"),y=a("c993"),m=a("7e56"),b=a("5a72"),w=a("f3a4"),O=a("e8ff"),_=a("e148"),T=a("f6fe"),E=a("2642"),A=a("b8b5"),P=a("d767"),v=a("7def"),j=a("97ea"),I=a("1b9c"),L=a("4a63"),x=a("514d"),S=a("f59e");const N=new l["a"],D=new l["a"];function R(e,t,a,n){const o=n.cartesianToCartographic(e,N),r=o.height,i=n.cartesianToCartographic(t,D);i.height=r,n.cartographicToCartesian(i,t);const s=n.cartesianToCartographic(a,D);s.height=r-100,n.cartographicToCartesian(s,a)}const k=new r["a"],H=new c["a"],G=new c["a"],C=new c["a"],F=new c["a"],B=new c["a"],z=new c["a"];let U=new c["a"],M=new c["a"],q=new c["a"];const V=new s["a"],W=new s["a"],Y=new c["a"],$=new I["a"],K=new P["a"],Z=new P["a"];function J(e){const t=e.vertexFormat,a=e.geometry,n=e.shadowVolume,r=a.attributes.position.values;let i=r.length;const l=e.wall,u=e.top||l,h=e.bottom||l;if(t.st||t.normal||t.tangent||t.bitangent||n){const o=e.boundingRectangle,d=e.tangentPlane,g=e.ellipsoid,f=e.stRotation,y=e.perPositionHeight,m=V;m.x=o.x,m.y=o.y;const b=t.st?new Float32Array(i/3*2):void 0;let O;t.normal&&(O=y&&u&&!l?a.attributes.normal.values:new Float32Array(i));const _=t.tangent?new Float32Array(i):void 0,T=t.bitangent?new Float32Array(i):void 0,E=n?new Float32Array(i):void 0;let v=0,j=0,L=G,x=C,S=F,N=!0,D=K,k=Z;if(0!==f){let e=I["a"].fromAxisAngle(d._plane.normal,f,$);D=P["a"].fromQuaternion(e,D),e=I["a"].fromAxisAngle(d._plane.normal,-f,$),k=P["a"].fromQuaternion(e,k)}else D=P["a"].clone(P["a"].IDENTITY,D),k=P["a"].clone(P["a"].IDENTITY,k);let J=0,X=0;u&&h&&(J=i/2,X=i/3,i/=2);for(let a=0;a<i;a+=3){const p=c["a"].fromArray(r,a,Y);if(t.st){let e=P["a"].multiplyByVector(D,p,H);e=g.scaleToGeodeticSurface(e,e);const t=d.projectPointOntoPlane(e,W);s["a"].subtract(t,m,t);const a=A["a"].clamp(t.x/o.width,0,1),n=A["a"].clamp(t.y/o.height,0,1);h&&(b[v+X]=a,b[v+1+X]=n),u&&(b[v]=a,b[v+1]=n),v+=2}if(t.normal||t.tangent||t.bitangent||n){const o=j+1,s=j+2;if(l){if(a+3<i){const e=c["a"].fromArray(r,a+3,B);if(N){const t=c["a"].fromArray(r,a+i,z);y&&R(p,e,t,g),c["a"].subtract(e,p,e),c["a"].subtract(t,p,t),L=c["a"].normalize(c["a"].cross(t,e,L),L),N=!1}c["a"].equalsEpsilon(e,p,A["a"].EPSILON10)&&(N=!0)}(t.tangent||t.bitangent)&&(S=g.geodeticSurfaceNormal(p,S),t.tangent&&(x=c["a"].normalize(c["a"].cross(S,L,x),x)))}else L=g.geodeticSurfaceNormal(p,L),(t.tangent||t.bitangent)&&(y&&(U=c["a"].fromArray(O,j,U),M=c["a"].cross(c["a"].UNIT_Z,U,M),M=c["a"].normalize(P["a"].multiplyByVector(k,M,M),M),t.bitangent&&(q=c["a"].normalize(c["a"].cross(U,M,q),q))),x=c["a"].cross(c["a"].UNIT_Z,L,x),x=c["a"].normalize(P["a"].multiplyByVector(k,x,x),x),t.bitangent&&(S=c["a"].normalize(c["a"].cross(L,x,S),S)));t.normal&&(e.wall?(O[j+J]=L.x,O[o+J]=L.y,O[s+J]=L.z):h&&(O[j+J]=-L.x,O[o+J]=-L.y,O[s+J]=-L.z),(u&&!y||l)&&(O[j]=L.x,O[o]=L.y,O[s]=L.z)),n&&(l&&(L=g.geodeticSurfaceNormal(p,L)),E[j+J]=-L.x,E[o+J]=-L.y,E[s+J]=-L.z),t.tangent&&(e.wall?(_[j+J]=x.x,_[o+J]=x.y,_[s+J]=x.z):h&&(_[j+J]=-x.x,_[o+J]=-x.y,_[s+J]=-x.z),u&&(y?(_[j]=M.x,_[o]=M.y,_[s]=M.z):(_[j]=x.x,_[o]=x.y,_[s]=x.z))),t.bitangent&&(h&&(T[j+J]=S.x,T[o+J]=S.y,T[s+J]=S.z),u&&(y?(T[j]=q.x,T[o]=q.y,T[s]=q.z):(T[j]=S.x,T[o]=S.y,T[s]=S.z))),j+=3}}t.st&&(a.attributes.st=new w["a"]({componentDatatype:p["a"].FLOAT,componentsPerAttribute:2,values:b})),t.normal&&(a.attributes.normal=new w["a"]({componentDatatype:p["a"].FLOAT,componentsPerAttribute:3,values:O})),t.tangent&&(a.attributes.tangent=new w["a"]({componentDatatype:p["a"].FLOAT,componentsPerAttribute:3,values:_})),t.bitangent&&(a.attributes.bitangent=new w["a"]({componentDatatype:p["a"].FLOAT,componentsPerAttribute:3,values:T})),n&&(a.attributes.extrudeDirection=new w["a"]({componentDatatype:p["a"].FLOAT,componentsPerAttribute:3,values:E}))}if(e.extrude&&Object(d["a"])(e.offsetAttribute)){const t=r.length/3;let n=new Uint8Array(t);if(e.offsetAttribute===_["a"].TOP)u&&h||l?n=Object(o["a"])(n,1,0,t/2):u&&(n=Object(o["a"])(n,1));else{const t=e.offsetAttribute===_["a"].NONE?0:1;n=Object(o["a"])(n,t)}a.attributes.applyOffset=new w["a"]({componentDatatype:p["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return a}const X=new l["a"],Q=new l["a"],ee={westOverIDL:0,eastOverIDL:0};let te=new y["a"];function ae(e,t,a,o,r){if(r=Object(h["a"])(r,new L["a"]),!Object(d["a"])(e)||e.length<3)return r.west=0,r.north=0,r.south=0,r.east=0,r;if(a===n["a"].RHUMB)return L["a"].fromCartesianArray(e,t,r);te.ellipsoid.equals(t)||(te=new y["a"](void 0,void 0,t)),r.west=Number.POSITIVE_INFINITY,r.east=Number.NEGATIVE_INFINITY,r.south=Number.POSITIVE_INFINITY,r.north=Number.NEGATIVE_INFINITY,ee.westOverIDL=Number.POSITIVE_INFINITY,ee.eastOverIDL=Number.NEGATIVE_INFINITY;const i=1/A["a"].chordLength(o,t.maximumRadius),s=e.length;let c,l=t.cartesianToCartographic(e[0],Q),u=X;for(let n=1;n<s;n++)c=u,u=l,l=t.cartesianToCartographic(e[n],c),te.setEndPoints(u,l),oe(te,i,r,ee);return c=u,u=l,l=t.cartesianToCartographic(e[0],c),te.setEndPoints(u,l),oe(te,i,r,ee),r.east-r.west>ee.eastOverIDL-ee.westOverIDL&&(r.west=ee.westOverIDL,r.east=ee.eastOverIDL,r.east>A["a"].PI&&(r.east=r.east-A["a"].TWO_PI),r.west>A["a"].PI&&(r.west=r.west-A["a"].TWO_PI)),r}const ne=new l["a"];function oe(e,t,a,n){const o=e.surfaceDistance,r=Math.ceil(o*t),i=r>0?o/(r-1):Number.POSITIVE_INFINITY;let s=0;for(let c=0;c<r;c++){const t=e.interpolateUsingSurfaceDistance(s,ne);s+=i;const o=t.longitude,r=t.latitude;a.west=Math.min(a.west,o),a.east=Math.max(a.east,o),a.south=Math.min(a.south,r),a.north=Math.max(a.north,r);const c=o>=0?o:o+A["a"].TWO_PI;n.westOverIDL=Math.min(n.westOverIDL,c),n.eastOverIDL=Math.max(n.eastOverIDL,c)}}const re=[];function ie(e,t,a,n,o,r,i,s,c){const l={walls:[]};let u;if(r||i){const n=v["a"].createGeometryFromPositions(e,t,a,o,s,c),p=n.attributes.position.values,h=n.indices;let d,g;if(r&&i){const e=p.concat(p);d=e.length/3,g=E["a"].createTypedArray(d,2*h.length),g.set(h);const t=h.length,a=d/2;for(u=0;u<t;u+=3){const e=g[u]+a,n=g[u+1]+a,o=g[u+2]+a;g[u+t]=o,g[u+1+t]=n,g[u+2+t]=e}if(n.attributes.position.values=e,o&&s.normal){const t=n.attributes.normal.values;n.attributes.normal.values=new Float32Array(e.length),n.attributes.normal.values.set(t)}n.indices=g}else if(i){for(d=p.length/3,g=E["a"].createTypedArray(d,h.length),u=0;u<h.length;u+=3)g[u]=h[u+2],g[u+1]=h[u+1],g[u+2]=h[u];n.indices=g}l.topAndBottom=new O["a"]({geometry:n})}let p=n.outerRing,h=m["a"].fromPoints(p,e),d=h.projectPointsOntoPlane(p,re),g=j["a"].computeWindingOrder2D(d);g===S["a"].CLOCKWISE&&(p=p.slice().reverse());let f=v["a"].computeWallGeometry(p,e,a,o,c);l.walls.push(new O["a"]({geometry:f}));const y=n.holes;for(u=0;u<y.length;u++){let t=y[u];h=m["a"].fromPoints(t,e),d=h.projectPointsOntoPlane(t,re),g=j["a"].computeWindingOrder2D(d),g===S["a"].COUNTER_CLOCKWISE&&(t=t.slice().reverse()),f=v["a"].computeWallGeometry(t,e,a,o,c),l.walls.push(new O["a"]({geometry:f}))}return l}function se(e){if(u["a"].typeOf.object("options",e),u["a"].typeOf.object("options.polygonHierarchy",e.polygonHierarchy),Object(d["a"])(e.perPositionHeight)&&e.perPositionHeight&&Object(d["a"])(e.height))throw new g["a"]("Cannot use both options.perPositionHeight and options.height");if(Object(d["a"])(e.arcType)&&e.arcType!==n["a"].GEODESIC&&e.arcType!==n["a"].RHUMB)throw new g["a"]("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const t=e.polygonHierarchy,a=Object(h["a"])(e.vertexFormat,x["a"].DEFAULT),o=Object(h["a"])(e.ellipsoid,f["a"].WGS84),r=Object(h["a"])(e.granularity,A["a"].RADIANS_PER_DEGREE),i=Object(h["a"])(e.stRotation,0),s=Object(h["a"])(e.perPositionHeight,!1),c=s&&Object(d["a"])(e.extrudedHeight);let l=Object(h["a"])(e.height,0),p=Object(h["a"])(e.extrudedHeight,l);if(!c){const e=Math.max(l,p);p=Math.min(l,p),l=e}this._vertexFormat=x["a"].clone(a),this._ellipsoid=f["a"].clone(o),this._granularity=r,this._stRotation=i,this._height=l,this._extrudedHeight=p,this._closeTop=Object(h["a"])(e.closeTop,!0),this._closeBottom=Object(h["a"])(e.closeBottom,!0),this._polygonHierarchy=t,this._perPositionHeight=s,this._perPositionHeightExtrude=c,this._shadowVolume=Object(h["a"])(e.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=e.offsetAttribute,this._arcType=Object(h["a"])(e.arcType,n["a"].GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this.packedLength=v["a"].computeHierarchyPackedLength(t)+f["a"].packedLength+x["a"].packedLength+12}se.fromPositions=function(e){e=Object(h["a"])(e,h["a"].EMPTY_OBJECT),u["a"].defined("options.positions",e.positions);const t={polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,closeTop:e.closeTop,closeBottom:e.closeBottom,offsetAttribute:e.offsetAttribute,arcType:e.arcType};return new se(t)},se.pack=function(e,t,a){return u["a"].typeOf.object("value",e),u["a"].defined("array",t),a=Object(h["a"])(a,0),a=v["a"].packPolygonHierarchy(e._polygonHierarchy,t,a),f["a"].pack(e._ellipsoid,t,a),a+=f["a"].packedLength,x["a"].pack(e._vertexFormat,t,a),a+=x["a"].packedLength,t[a++]=e._height,t[a++]=e._extrudedHeight,t[a++]=e._granularity,t[a++]=e._stRotation,t[a++]=e._perPositionHeightExtrude?1:0,t[a++]=e._perPositionHeight?1:0,t[a++]=e._closeTop?1:0,t[a++]=e._closeBottom?1:0,t[a++]=e._shadowVolume?1:0,t[a++]=Object(h["a"])(e._offsetAttribute,-1),t[a++]=e._arcType,t[a]=e.packedLength,t};const ce=f["a"].clone(f["a"].UNIT_SPHERE),le=new x["a"],ue={polygonHierarchy:{}};function pe(e){const t=-e._stRotation;if(0===t)return[0,0,0,1,1,0];const a=e._ellipsoid,n=e._polygonHierarchy.positions,o=e.rectangle;return b["a"]._textureCoordinateRotationPoints(n,t,a,o)}se.unpack=function(e,t,a){u["a"].defined("array",e),t=Object(h["a"])(t,0);const n=v["a"].unpackPolygonHierarchy(e,t);t=n.startingIndex,delete n.startingIndex;const o=f["a"].unpack(e,t,ce);t+=f["a"].packedLength;const r=x["a"].unpack(e,t,le);t+=x["a"].packedLength;const i=e[t++],s=e[t++],c=e[t++],l=e[t++],p=1===e[t++],g=1===e[t++],y=1===e[t++],m=1===e[t++],b=1===e[t++],w=e[t++],O=e[t++],_=e[t];return Object(d["a"])(a)||(a=new se(ue)),a._polygonHierarchy=n,a._ellipsoid=f["a"].clone(o,a._ellipsoid),a._vertexFormat=x["a"].clone(r,a._vertexFormat),a._height=i,a._extrudedHeight=s,a._granularity=c,a._stRotation=l,a._perPositionHeightExtrude=p,a._perPositionHeight=g,a._closeTop=y,a._closeBottom=m,a._shadowVolume=b,a._offsetAttribute=-1===w?void 0:w,a._arcType=O,a.packedLength=_,a},se.computeRectangle=function(e,t){u["a"].typeOf.object("options",e),u["a"].typeOf.object("options.polygonHierarchy",e.polygonHierarchy);const a=Object(h["a"])(e.granularity,A["a"].RADIANS_PER_DEGREE),o=Object(h["a"])(e.arcType,n["a"].GEODESIC);if(o!==n["a"].GEODESIC&&o!==n["a"].RHUMB)throw new g["a"]("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const r=e.polygonHierarchy,i=Object(h["a"])(e.ellipsoid,f["a"].WGS84);return ae(r.positions,i,o,a,t)},se.createGeometry=function(e){const t=e._vertexFormat,a=e._ellipsoid,n=e._granularity,r=e._stRotation,s=e._polygonHierarchy,c=e._perPositionHeight,l=e._closeTop,u=e._closeBottom,h=e._arcType;let g=s.positions;if(g.length<3)return;const f=m["a"].fromPoints(g,a),y=v["a"].polygonsFromHierarchy(s,f.projectPointsOntoPlane.bind(f),!c,a),P=y.hierarchy,I=y.polygons;if(0===P.length)return;g=P[0].outerRing;const L=v["a"].computeBoundingRectangle(f.plane.normal,f.projectPointOntoPlane.bind(f),g,r,k),x=[],S=e._height,N=e._extrudedHeight,D=e._perPositionHeightExtrude||!A["a"].equalsEpsilon(S,N,0,A["a"].EPSILON2),R={perPositionHeight:c,vertexFormat:t,geometry:void 0,tangentPlane:f,boundingRectangle:L,ellipsoid:a,stRotation:r,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:h};let H;if(D)for(R.extrude=!0,R.top=l,R.bottom=u,R.shadowVolume=e._shadowVolume,R.offsetAttribute=e._offsetAttribute,H=0;H<I.length;H++){const e=ie(a,I[H],n,P[H],c,l,u,t,h);let o;l&&u?(o=e.topAndBottom,R.geometry=v["a"].scaleToGeodeticHeightExtruded(o.geometry,S,N,a,c)):l?(o=e.topAndBottom,o.geometry.attributes.position.values=j["a"].scaleToGeodeticHeight(o.geometry.attributes.position.values,S,a,!c),R.geometry=o.geometry):u&&(o=e.topAndBottom,o.geometry.attributes.position.values=j["a"].scaleToGeodeticHeight(o.geometry.attributes.position.values,N,a,!0),R.geometry=o.geometry),(l||u)&&(R.wall=!1,o.geometry=J(R),x.push(o));const r=e.walls;R.wall=!0;for(let t=0;t<r.length;t++){const e=r[t];R.geometry=v["a"].scaleToGeodeticHeightExtruded(e.geometry,S,N,a,c),e.geometry=J(R),x.push(e)}}else for(H=0;H<I.length;H++){const r=new O["a"]({geometry:v["a"].createGeometryFromPositions(a,I[H],n,c,t,h)});if(r.geometry.attributes.position.values=j["a"].scaleToGeodeticHeight(r.geometry.attributes.position.values,S,a,!c),R.geometry=r.geometry,r.geometry=J(R),Object(d["a"])(e._offsetAttribute)){const t=r.geometry.attributes.position.values.length,a=new Uint8Array(t/3),n=e._offsetAttribute===_["a"].NONE?0:1;Object(o["a"])(a,n),r.geometry.attributes.applyOffset=new w["a"]({componentDatatype:p["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}x.push(r)}const G=T["a"].combineInstances(x)[0];G.attributes.position.values=new Float64Array(G.attributes.position.values),G.indices=E["a"].createTypedArray(G.attributes.position.values.length/3,G.indices);const C=G.attributes,F=i["a"].fromVertices(C.position.values);return t.position||delete C.position,new b["a"]({attributes:C,indices:G.indices,primitiveType:G.primitiveType,boundingSphere:F,offsetAttribute:e._offsetAttribute})},se.createShadowVolume=function(e,t,a){const n=e._granularity,o=e._ellipsoid,r=t(n,o),i=a(n,o);return new se({polygonHierarchy:e._polygonHierarchy,ellipsoid:o,stRotation:e._stRotation,granularity:n,perPositionHeight:!1,extrudedHeight:r,height:i,vertexFormat:x["a"].POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(se.prototype,{rectangle:{get:function(){if(!Object(d["a"])(this._rectangle)){const e=this._polygonHierarchy.positions;this._rectangle=ae(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return Object(d["a"])(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=pe(this)),this._textureCoordinateRotationPoints}}}),t["a"]=se}}]);