(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-vendors~f7e90ea8"],{"0050":function(t,e,a){"use strict";var n=a("ae9b"),i=a("3736"),o=a("1a5d"),r=a("c937"),s=a("e107"),c=a("f7b5"),u=a("2dd3"),f=a("b869"),b=a("5df2");function l(t){t=Object(o["a"])(t,o["a"].EMPTY_OBJECT),n["a"].defined("options.callback",t.callback),n["a"].defined("options.width",t.width),n["a"].defined("options.height",t.height),this._callback=t.callback,this._tilingScheme=t.tilingScheme,Object(r["a"])(this._tilingScheme)||(this._tilingScheme=new u["a"]({ellipsoid:Object(o["a"])(t.ellipsoid,s["a"].WGS84)})),this._width=t.width,this._height=t.height;const e=Math.max(this._width,this._height);this._levelZeroMaximumGeometricError=b["a"].getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid,e,this._tilingScheme.getNumberOfXTilesAtLevel(0)),this._errorEvent=new c["a"];let a=t.credit;"string"===typeof a&&(a=new i["a"](a)),this._credit=a,this._readyPromise=Promise.resolve(!0)}Object.defineProperties(l.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){return this._credit}},tilingScheme:{get:function(){return this._tilingScheme}},ready:{get:function(){return!0}},readyPromise:{get:function(){return this._readyPromise}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},width:{get:function(){return this._width}},height:{get:function(){return this._height}}}),l.prototype.requestTileGeometry=function(t,e,a,n){const i=this._callback(t,e,a);if(!Object(r["a"])(i))return;const o=this._width,s=this._height;return Promise.resolve(i).then((function(t){let e=t;return Array.isArray(e)&&(e=new Float64Array(e)),new f["a"]({buffer:e,width:o,height:s})}))},l.prototype.getLevelMaximumGeometricError=function(t){return this._levelZeroMaximumGeometricError/(1<<t)},l.prototype.getTileDataAvailable=function(t,e,a){},l.prototype.loadTileDataAvailability=function(t,e,a){}},"10a0":function(t,e,a){"use strict";var n=a("e2a6"),i=a("8b8d");const o={};function r(t,e,a,n){const i=t,o=e/3,r=a/3,s=n,c=i*r,u=o*s,f=o*o,b=r*r,l=i*r-f,h=i*s-o*r,d=o*s-b,m=4*l*d-h*h;let p,w;if(m<0){let t,e,a;f*u>=c*b?(t=i,e=l,a=-2*o*l+i*h):(t=s,e=d,a=-s*h+2*r*d);const n=a<0?-1:1,_=-n*Math.abs(t)*Math.sqrt(-m);w=-a+_;const g=w/2,y=g<0?-Math.pow(-g,1/3):Math.pow(g,1/3),O=w===_?-y:-e/y;return p=e<=0?y+O:-a/(y*y+O*O+e),f*u>=c*b?[(p-o)/i]:[-s/(p+r)]}const _=l,g=-2*o*l+i*h,y=d,O=-s*h+2*r*d,A=Math.sqrt(m),v=Math.sqrt(3)/2;let M=Math.abs(Math.atan2(i*A,-g)/3);p=2*Math.sqrt(-_);let R=Math.cos(M);w=p*R;let T=p*(-R/2-v*Math.sin(M));const E=w+T>2*o?w-o:T-o,j=i,S=E/j;M=Math.abs(Math.atan2(s*A,-O)/3),p=2*Math.sqrt(-y),R=Math.cos(M),w=p*R,T=p*(-R/2-v*Math.sin(M));const I=-s,N=w+T<2*r?w+r:T+r,x=I/N,P=j*N,D=-E*N-j*I,L=E*I,k=(r*D-o*L)/(-o*D+r*P);return S<=k?S<=x?k<=x?[S,k,x]:[S,x,k]:[x,S,k]:S<=x?[k,S,x]:k<=x?[k,x,S]:[x,k,S]}o.computeDiscriminant=function(t,e,a,i){if("number"!==typeof t)throw new n["a"]("a is a required number.");if("number"!==typeof e)throw new n["a"]("b is a required number.");if("number"!==typeof a)throw new n["a"]("c is a required number.");if("number"!==typeof i)throw new n["a"]("d is a required number.");const o=t*t,r=e*e,s=a*a,c=i*i,u=18*t*e*a*i+r*s-27*o*c-4*(t*s*a+r*e*i);return u},o.computeRealRoots=function(t,e,a,o){if("number"!==typeof t)throw new n["a"]("a is a required number.");if("number"!==typeof e)throw new n["a"]("b is a required number.");if("number"!==typeof a)throw new n["a"]("c is a required number.");if("number"!==typeof o)throw new n["a"]("d is a required number.");let s,c;if(0===t)return i["a"].computeRealRoots(e,a,o);if(0===e){if(0===a){if(0===o)return[0,0,0];c=-o/t;const e=c<0?-Math.pow(-c,1/3):Math.pow(c,1/3);return[e,e,e]}return 0===o?(s=i["a"].computeRealRoots(t,0,a),0===s.Length?[0]:[s[0],0,s[1]]):r(t,0,a,o)}return 0===a?0===o?(c=-e/t,c<0?[c,0,0]:[0,0,c]):r(t,e,0,o):0===o?(s=i["a"].computeRealRoots(t,e,a),0===s.length?[0]:s[1]<=0?[s[0],s[1],0]:s[0]>=0?[0,s[0],s[1]]:[s[0],0,s[1]]):r(t,e,a,o)},e["a"]=o},"2b27":function(t,e,a){"use strict";var n=a("b8b5");const i={computePositions:function(t,e,a,i,o){const r=.5*t,s=-r,c=i+i,u=o?2*c:c,f=new Float64Array(3*u);let b,l=0,h=0;const d=o?3*c:0,m=o?3*(c+i):3*i;for(b=0;b<i;b++){const t=b/i*n["a"].TWO_PI,c=Math.cos(t),u=Math.sin(t),p=c*a,w=u*a,_=c*e,g=u*e;f[h+d]=p,f[h+d+1]=w,f[h+d+2]=s,f[h+m]=_,f[h+m+1]=g,f[h+m+2]=r,h+=3,o&&(f[l++]=p,f[l++]=w,f[l++]=s,f[l++]=_,f[l++]=g,f[l++]=r)}return f}};e["a"]=i},bb30:function(t,e,a){"use strict";var n=a("9dc9"),i=a("8656"),o=a("85b2"),r=a("dde0"),s=a("ae9b"),c=a("cbf0"),u=a("2b27"),f=a("1a5d"),b=a("c937"),l=a("e2a6"),h=a("5a72"),d=a("f3a4"),m=a("0c02"),p=a("e148"),w=a("2642"),_=a("82ba");const g=new o["a"];function y(t){t=Object(f["a"])(t,f["a"].EMPTY_OBJECT);const e=t.length,a=t.topRadius,n=t.bottomRadius,i=Object(f["a"])(t.slices,128),o=Math.max(Object(f["a"])(t.numberOfVerticalLines,16),0);if(s["a"].typeOf.number("options.positions",e),s["a"].typeOf.number("options.topRadius",a),s["a"].typeOf.number("options.bottomRadius",n),s["a"].typeOf.number.greaterThanOrEquals("options.slices",i,3),Object(b["a"])(t.offsetAttribute)&&t.offsetAttribute===p["a"].TOP)throw new l["a"]("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=e,this._topRadius=a,this._bottomRadius=n,this._slices=i,this._numberOfVerticalLines=o,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderOutlineGeometry"}y.packedLength=6,y.pack=function(t,e,a){return s["a"].typeOf.object("value",t),s["a"].defined("array",e),a=Object(f["a"])(a,0),e[a++]=t._length,e[a++]=t._topRadius,e[a++]=t._bottomRadius,e[a++]=t._slices,e[a++]=t._numberOfVerticalLines,e[a]=Object(f["a"])(t._offsetAttribute,-1),e};const O={length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};y.unpack=function(t,e,a){s["a"].defined("array",t),e=Object(f["a"])(e,0);const n=t[e++],i=t[e++],o=t[e++],r=t[e++],c=t[e++],u=t[e];return Object(b["a"])(a)?(a._length=n,a._topRadius=i,a._bottomRadius=o,a._slices=r,a._numberOfVerticalLines=c,a._offsetAttribute=-1===u?void 0:u,a):(O.length=n,O.topRadius=i,O.bottomRadius=o,O.slices=r,O.numberOfVerticalLines=c,O.offsetAttribute=-1===u?void 0:u,new y(O))},y.createGeometry=function(t){let e=t._length;const a=t._topRadius,s=t._bottomRadius,f=t._slices,l=t._numberOfVerticalLines;if(e<=0||a<0||s<0||0===a&&0===s)return;const y=2*f,O=u["a"].computePositions(e,a,s,f,!1);let A,v=2*f;if(l>0){const t=Math.min(l,f);A=Math.round(f/t),v+=t}const M=w["a"].createTypedArray(y,2*v);let R,T=0;for(R=0;R<f-1;R++)M[T++]=R,M[T++]=R+1,M[T++]=R+f,M[T++]=R+1+f;if(M[T++]=f-1,M[T++]=0,M[T++]=f+f-1,M[T++]=f,l>0)for(R=0;R<f;R+=A)M[T++]=R,M[T++]=R+f;const E=new m["a"];E.position=new d["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:O}),g.x=.5*e,g.y=Math.max(s,a);const j=new i["a"](r["a"].ZERO,o["a"].magnitude(g));if(Object(b["a"])(t._offsetAttribute)){e=O.length;const a=new Uint8Array(e/3),i=t._offsetAttribute===p["a"].NONE?0:1;Object(n["a"])(a,i),E.applyOffset=new d["a"]({componentDatatype:c["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new h["a"]({attributes:E,indices:M,primitiveType:_["a"].LINES,boundingSphere:j,offsetAttribute:t._offsetAttribute})},e["a"]=y},c76f:function(t,e,a){"use strict";var n=a("dde0"),i=a("6b82"),o=a("1a5d"),r=a("c937"),s=a("e2a6"),c=a("a61d"),u=a("a7b2");function f(t){this.planes=Object(o["a"])(t,[])}const b=[new n["a"],new n["a"],new n["a"]];n["a"].clone(n["a"].UNIT_X,b[0]),n["a"].clone(n["a"].UNIT_Y,b[1]),n["a"].clone(n["a"].UNIT_Z,b[2]);const l=new n["a"],h=new n["a"],d=new u["a"](new n["a"](1,0,0),0);f.fromBoundingSphere=function(t,e){if(!Object(r["a"])(t))throw new s["a"]("boundingSphere is required.");Object(r["a"])(e)||(e=new f);const a=b.length,o=e.planes;o.length=2*a;const c=t.center,u=t.radius;let d=0;for(let s=0;s<a;++s){const t=b[s];let e=o[d],a=o[d+1];Object(r["a"])(e)||(e=o[d]=new i["a"]),Object(r["a"])(a)||(a=o[d+1]=new i["a"]),n["a"].multiplyByScalar(t,-u,l),n["a"].add(c,l,l),e.x=t.x,e.y=t.y,e.z=t.z,e.w=-n["a"].dot(t,l),n["a"].multiplyByScalar(t,u,l),n["a"].add(c,l,l),a.x=-t.x,a.y=-t.y,a.z=-t.z,a.w=-n["a"].dot(n["a"].negate(t,h),l),d+=2}return e},f.prototype.computeVisibility=function(t){if(!Object(r["a"])(t))throw new s["a"]("boundingVolume is required.");const e=this.planes;let a=!1;for(let n=0,i=e.length;n<i;++n){const i=t.intersectPlane(u["a"].fromCartesian4(e[n],d));if(i===c["a"].OUTSIDE)return c["a"].OUTSIDE;i===c["a"].INTERSECTING&&(a=!0)}return a?c["a"].INTERSECTING:c["a"].INSIDE},f.prototype.computeVisibilityWithPlaneMask=function(t,e){if(!Object(r["a"])(t))throw new s["a"]("boundingVolume is required.");if(!Object(r["a"])(e))throw new s["a"]("parentPlaneMask is required.");if(e===f.MASK_OUTSIDE||e===f.MASK_INSIDE)return e;let a=f.MASK_INSIDE;const n=this.planes;for(let i=0,o=n.length;i<o;++i){const o=i<31?1<<i:0;if(i<31&&0===(e&o))continue;const r=t.intersectPlane(u["a"].fromCartesian4(n[i],d));if(r===c["a"].OUTSIDE)return f.MASK_OUTSIDE;r===c["a"].INTERSECTING&&(a|=o)}return a},f.MASK_OUTSIDE=4294967295,f.MASK_INSIDE=0,f.MASK_INDETERMINATE=2147483647,e["a"]=f},f32b:function(t,e,a){"use strict";var n=a("9dc9"),i=a("8656"),o=a("85b2"),r=a("dde0"),s=a("cbf0"),c=a("2b27"),u=a("1a5d"),f=a("c937"),b=a("e2a6"),l=a("5a72"),h=a("f3a4"),d=a("0c02"),m=a("e148"),p=a("2642"),w=a("b8b5"),_=a("82ba"),g=a("514d");const y=new o["a"],O=new r["a"],A=new r["a"],v=new r["a"],M=new r["a"];function R(t){t=Object(u["a"])(t,u["a"].EMPTY_OBJECT);const e=t.length,a=t.topRadius,n=t.bottomRadius,i=Object(u["a"])(t.vertexFormat,g["a"].DEFAULT),o=Object(u["a"])(t.slices,128);if(!Object(f["a"])(e))throw new b["a"]("options.length must be defined.");if(!Object(f["a"])(a))throw new b["a"]("options.topRadius must be defined.");if(!Object(f["a"])(n))throw new b["a"]("options.bottomRadius must be defined.");if(o<3)throw new b["a"]("options.slices must be greater than or equal to 3.");if(Object(f["a"])(t.offsetAttribute)&&t.offsetAttribute===m["a"].TOP)throw new b["a"]("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=e,this._topRadius=a,this._bottomRadius=n,this._vertexFormat=g["a"].clone(i),this._slices=o,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}R.packedLength=g["a"].packedLength+5,R.pack=function(t,e,a){if(!Object(f["a"])(t))throw new b["a"]("value is required");if(!Object(f["a"])(e))throw new b["a"]("array is required");return a=Object(u["a"])(a,0),g["a"].pack(t._vertexFormat,e,a),a+=g["a"].packedLength,e[a++]=t._length,e[a++]=t._topRadius,e[a++]=t._bottomRadius,e[a++]=t._slices,e[a]=Object(u["a"])(t._offsetAttribute,-1),e};const T=new g["a"],E={vertexFormat:T,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let j;R.unpack=function(t,e,a){if(!Object(f["a"])(t))throw new b["a"]("array is required");e=Object(u["a"])(e,0);const n=g["a"].unpack(t,e,T);e+=g["a"].packedLength;const i=t[e++],o=t[e++],r=t[e++],s=t[e++],c=t[e];return Object(f["a"])(a)?(a._vertexFormat=g["a"].clone(n,a._vertexFormat),a._length=i,a._topRadius=o,a._bottomRadius=r,a._slices=s,a._offsetAttribute=-1===c?void 0:c,a):(E.length=i,E.topRadius=o,E.bottomRadius=r,E.slices=s,E.offsetAttribute=-1===c?void 0:c,new R(E))},R.createGeometry=function(t){let e=t._length;const a=t._topRadius,u=t._bottomRadius,b=t._vertexFormat,g=t._slices;if(e<=0||a<0||u<0||0===a&&0===u)return;const R=g+g,T=g+R,E=R+R,j=c["a"].computePositions(e,a,u,g,!0),S=b.st?new Float32Array(2*E):void 0,I=b.normal?new Float32Array(3*E):void 0,N=b.tangent?new Float32Array(3*E):void 0,x=b.bitangent?new Float32Array(3*E):void 0;let P;const D=b.normal||b.tangent||b.bitangent;if(D){const t=b.tangent||b.bitangent;let n=0,i=0,o=0;const s=Math.atan2(u-a,e),c=O;c.z=Math.sin(s);const f=Math.cos(s);let l=v,h=A;for(P=0;P<g;P++){const e=P/g*w["a"].TWO_PI,a=f*Math.cos(e),s=f*Math.sin(e);D&&(c.x=a,c.y=s,t&&(l=r["a"].normalize(r["a"].cross(r["a"].UNIT_Z,c,l),l)),b.normal&&(I[n++]=c.x,I[n++]=c.y,I[n++]=c.z,I[n++]=c.x,I[n++]=c.y,I[n++]=c.z),b.tangent&&(N[i++]=l.x,N[i++]=l.y,N[i++]=l.z,N[i++]=l.x,N[i++]=l.y,N[i++]=l.z),b.bitangent&&(h=r["a"].normalize(r["a"].cross(c,l,h),h),x[o++]=h.x,x[o++]=h.y,x[o++]=h.z,x[o++]=h.x,x[o++]=h.y,x[o++]=h.z))}for(P=0;P<g;P++)b.normal&&(I[n++]=0,I[n++]=0,I[n++]=-1),b.tangent&&(N[i++]=1,N[i++]=0,N[i++]=0),b.bitangent&&(x[o++]=0,x[o++]=-1,x[o++]=0);for(P=0;P<g;P++)b.normal&&(I[n++]=0,I[n++]=0,I[n++]=1),b.tangent&&(N[i++]=1,N[i++]=0,N[i++]=0),b.bitangent&&(x[o++]=0,x[o++]=1,x[o++]=0)}const L=12*g-12,k=p["a"].createTypedArray(E,L);let q=0,F=0;for(P=0;P<g-1;P++)k[q++]=F,k[q++]=F+2,k[q++]=F+3,k[q++]=F,k[q++]=F+3,k[q++]=F+1,F+=2;for(k[q++]=R-2,k[q++]=0,k[q++]=1,k[q++]=R-2,k[q++]=1,k[q++]=R-1,P=1;P<g-1;P++)k[q++]=R+P+1,k[q++]=R+P,k[q++]=R;for(P=1;P<g-1;P++)k[q++]=T,k[q++]=T+P,k[q++]=T+P+1;let G=0;if(b.st){const t=Math.max(a,u);for(P=0;P<E;P++){const e=r["a"].fromArray(j,3*P,M);S[G++]=(e.x+t)/(2*t),S[G++]=(e.y+t)/(2*t)}}const U=new d["a"];b.position&&(U.position=new h["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:j})),b.normal&&(U.normal=new h["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:I})),b.tangent&&(U.tangent=new h["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:N})),b.bitangent&&(U.bitangent=new h["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:x})),b.st&&(U.st=new h["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:2,values:S})),y.x=.5*e,y.y=Math.max(u,a);const z=new i["a"](r["a"].ZERO,o["a"].magnitude(y));if(Object(f["a"])(t._offsetAttribute)){e=j.length;const a=new Uint8Array(e/3),i=t._offsetAttribute===m["a"].NONE?0:1;Object(n["a"])(a,i),U.applyOffset=new h["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new l["a"]({attributes:U,indices:k,primitiveType:_["a"].TRIANGLES,boundingSphere:z,offsetAttribute:t._offsetAttribute})},R.getUnitCylinder=function(){return Object(f["a"])(j)||(j=R.createGeometry(new R({topRadius:1,bottomRadius:1,length:1,vertexFormat:g["a"].POSITION_ONLY}))),j},e["a"]=R}}]);