(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-vendors~c10e0f34"],{"0e04":function(e,t,i){"use strict";const r={NONE:0,GEODESIC:1,RHUMB:2};t["a"]=Object.freeze(r)},"573c":function(e,t,i){"use strict";var r=i("85b2"),a=i("3736"),n=i("1a5d"),o=i("c937"),s=i("e2a6"),l=i("e107"),c=i("f7b5"),u=i("2dd3"),d=i("bf0c"),h=i("b869"),f=i("4a63"),m=i("035e"),g=i("06d8"),b=i("bb9e"),_=i("9f38"),v=i("e2aa"),y=i("5df2"),w=i("38ed"),p=i("3242"),x=i("c7de");const A=15;function T(e){if(!Object(o["a"])(e)||!Object(o["a"])(e.url))throw new s["a"]("options.url is required.");this._resource=void 0,this._credit=void 0,this._tilingScheme=void 0,this._levelZeroMaximumGeometricError=void 0,this._maxLevel=void 0,this._terrainDataStructure=void 0,this._ready=!1,this._width=void 0,this._height=void 0,this._encoding=void 0;const t=e.token;this._hasAvailability=!1,this._tilesAvailable=void 0,this._tilesAvailablityLoaded=void 0,this._availableCache={};const i=this,h=Object(n["a"])(e.ellipsoid,l["a"].WGS84);this._readyPromise=Promise.resolve(e.url).then((function(e){let r=_["a"].createIfNeeded(e);r.appendForwardSlash(),Object(o["a"])(t)&&(r=r.getDerivedResource({queryParameters:{token:t}})),i._resource=r;const a=r.getDerivedResource({queryParameters:{f:"pjson"}});return a.fetchJson()})).then((function(e){const t=e.copyrightText;Object(o["a"])(t)&&(i._credit=new a["a"](t));const s=e.spatialReference,l=Object(n["a"])(s.latestWkid,s.wkid),c=e.extent,m={ellipsoid:h};if(4326===l)m.rectangle=f["a"].fromDegrees(c.xmin,c.ymin,c.xmax,c.ymax),i._tilingScheme=new u["a"](m);else{if(3857!==l)return Promise.reject(new v["a"]("Invalid spatial reference"));m.rectangleSouthwestInMeters=new r["a"](c.xmin,c.ymin),m.rectangleNortheastInMeters=new r["a"](c.xmax,c.ymax),i._tilingScheme=new x["a"](m)}const g=e.tileInfo;if(!Object(o["a"])(g))return Promise.reject(new v["a"]("tileInfo is required"));i._width=g.rows+1,i._height=g.cols+1,i._encoding="LERC"===g.format?d["a"].LERC:d["a"].NONE,i._lodCount=g.lods.length-1;const b=i._hasAvailability=-1!==e.capabilities.indexOf("Tilemap");return b&&(i._tilesAvailable=new w["a"](i._tilingScheme,i._lodCount),i._tilesAvailable.addAvailableTileRange(0,0,0,i._tilingScheme.getNumberOfXTilesAtLevel(0),i._tilingScheme.getNumberOfYTilesAtLevel(0)),i._tilesAvailablityLoaded=new w["a"](i._tilingScheme,i._lodCount)),i._levelZeroMaximumGeometricError=y["a"].getEstimatedLevelZeroGeometricErrorForAHeightmap(i._tilingScheme.ellipsoid,i._width,i._tilingScheme.getNumberOfXTilesAtLevel(0)),e.bandCount>1&&console.log("ArcGISTiledElevationTerrainProvider: Terrain data has more than 1 band. Using the first one."),i._terrainDataStructure={elementMultiplier:1,lowestEncodedHeight:e.minValues[0],highestEncodedHeight:e.maxValues[0]},i._ready=!0,!0})).catch((function(e){const t=`An error occurred while accessing ${i._resource.url}.`;return p["a"].handleError(void 0,i,i._errorEvent,t),Promise.reject(e)})),this._errorEvent=new c["a"]}function j(e,t,i,r){if(!e._hasAvailability)return;const a=e._tilesAvailablityLoaded,n=e._tilesAvailable;return!(t>e._lodCount)&&(!!n.isTileAvailable(t,i,r)||!a.isTileAvailable(t,i,r)&&void 0)}function O(e,t,i,a){const n=t-1,o=i-1,s=a[e.y*t+e.x],l=[],c={startX:e.x,startY:e.y,endX:0,endY:0},u=new r["a"](e.x+1,e.y+1);let d=!1,h=!1;while(!d||!h){let i=u.x;const f=h?u.y+1:u.y;if(!d){for(let i=e.y;i<f;++i)if(a[i*t+u.x]!==s){d=!0;break}d?(l.push(new r["a"](u.x,e.y)),--u.x,--i,c.endX=u.x):u.x===n?(c.endX=u.x,d=!0):++u.x}if(!h){const n=u.y*t;for(let t=e.x;t<=i;++t)if(a[n+t]!==s){h=!0;break}h?(l.push(new r["a"](e.x,u.y)),--u.y,c.endY=u.y):u.y===o?(c.endY=u.y,h=!0):++u.y}}return{endingIndices:l,range:c,value:s}}function M(e,t,i,a,n){const o=[],s=n.every((function(e){return e===n[0]}));if(s)return 1===n[0]&&o.push({startX:e,startY:t,endX:e+i-1,endY:t+a-1}),o;let l=[new r["a"](0,0)];while(l.length>0){const r=l.pop(),s=O(r,i,a,n);if(1===s.value){const i=s.range;i.startX+=e,i.endX+=e,i.startY+=t,i.endY+=t,o.push(i)}const c=s.endingIndices;c.length>0&&(l=l.concat(c))}return o}function E(e,t,i,r){if(!e._hasAvailability)return{};const a=128*Math.floor(i/128),n=128*Math.floor(r/128),s=Math.min(1<<t,128),l=`tilemap/${t}/${n}/${a}/${s}/${s}`,c=e._availableCache;if(Object(o["a"])(c[l]))return c[l];const u=new m["a"]({throttle:!1,throttleByServer:!0,type:b["a"].TERRAIN}),d=e._resource.getDerivedResource({url:l,request:u});let h=d.fetchJson();return Object(o["a"])(h)?(h=h.then((function(o){const l=M(a,n,s,s,o.data);e._tilesAvailablityLoaded.addAvailableTileRange(t,a,n,a+s,n+s);const c=e._tilesAvailable;for(let e=0;e<l.length;++e){const i=l[e];c.addAvailableTileRange(t,i.startX,i.startY,i.endX,i.endY)}return j(e,t,i,r)})),c[l]={promise:h,request:u},h=h.finally((function(e){return delete c[l],e})),{promise:h,request:u}):{}}Object.defineProperties(T.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){if(!this.ready)throw new s["a"]("credit must not be called before ready returns true.");return this._credit}},tilingScheme:{get:function(){if(!this.ready)throw new s["a"]("tilingScheme must not be called before ready returns true.");return this._tilingScheme}},ready:{get:function(){return this._ready}},readyPromise:{get:function(){return this._readyPromise}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){if(!this._ready)throw new s["a"]("availability must not be called before the terrain provider is ready.");return this._tilesAvailable}}}),T.prototype.requestTileGeometry=function(e,t,i,r){if(!this._ready)throw new s["a"]("requestTileGeometry must not be called before the terrain provider is ready.");const a=this._resource.getDerivedResource({url:`tile/${i}/${t}/${e}`,request:r}),n=this._hasAvailability;let l,c=Promise.resolve(!0);if(n&&!Object(o["a"])(j(this,i+1,2*e,2*t))){const r=E(this,i+1,2*e,2*t);c=r.promise,l=r.request}const u=a.fetchArrayBuffer();if(!Object(o["a"])(u)||!Object(o["a"])(c))return;const d=this,f=this._tilesAvailable;return Promise.all([u,c]).then((function(r){return new h["a"]({buffer:r[0],width:d._width,height:d._height,childTileMask:n?f.computeChildMaskForTile(i,e,t):A,structure:d._terrainDataStructure,encoding:d._encoding})})).catch((function(e){return Object(o["a"])(l)&&l.state===g["a"].CANCELLED?(r.cancel(),r.deferred.promise.finally((function(){return r.state=g["a"].CANCELLED,Promise.reject(e)}))):Promise.reject(e)}))},T.prototype.getLevelMaximumGeometricError=function(e){if(!this.ready)throw new s["a"]("getLevelMaximumGeometricError must not be called before ready returns true.");return this._levelZeroMaximumGeometricError/(1<<e)},T.prototype.getTileDataAvailable=function(e,t,i){if(!this._hasAvailability)return;const r=j(this,i,e,t);if(Object(o["a"])(r))return r;E(this,i,e,t)},T.prototype.loadTileDataAvailability=function(e,t,i){}},"5c8a":function(e,t,i){"use strict";var r=i("8656"),a=i("1924"),n=i("85b2"),o=i("dde0"),s=i("8d54"),l=i("ae9b"),c=i("1a5d"),u=i("c937"),d=i("e2a6"),h=i("e107"),f=i("2dd3"),m=i("4a63"),g=i("9f38");const b=new o["a"],_=new o["a"],v=new s["a"],y=new o["a"],w=new o["a"],p=new r["a"],x=new f["a"],A=[new s["a"],new s["a"],new s["a"],new s["a"]],T=new n["a"],j={};function O(e){s["a"].fromRadians(e.east,e.north,0,A[0]),s["a"].fromRadians(e.west,e.north,0,A[1]),s["a"].fromRadians(e.east,e.south,0,A[2]),s["a"].fromRadians(e.west,e.south,0,A[3]);let t=0,i=0,r=0,a=0;const n=j._terrainHeightsMaxLevel;let o;for(o=0;o<=n;++o){let e=!1;for(let t=0;t<4;++t){const i=A[t];if(x.positionToTileXY(i,o,T),0===t)r=T.x,a=T.y;else if(r!==T.x||a!==T.y){e=!0;break}}if(e)break;t=r,i=a}if(0!==o)return{x:t,y:i,level:o>n?n:o-1}}j.initialize=function(){let e=j._initPromise;return Object(u["a"])(e)||(e=g["a"].fetchJson(Object(a["a"])("Assets/approximateTerrainHeights.json")).then((function(e){j._terrainHeights=e})),j._initPromise=e),e},j.getMinimumMaximumHeights=function(e,t){if(l["a"].defined("rectangle",e),!Object(u["a"])(j._terrainHeights))throw new d["a"]("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");t=Object(c["a"])(t,h["a"].WGS84);const i=O(e);let r=j._defaultMinTerrainHeight,a=j._defaultMaxTerrainHeight;if(Object(u["a"])(i)){const n=`${i.level}-${i.x}-${i.y}`,s=j._terrainHeights[n];Object(u["a"])(s)&&(r=s[0],a=s[1]),t.cartographicToCartesian(m["a"].northeast(e,v),b),t.cartographicToCartesian(m["a"].southwest(e,v),_),o["a"].midpoint(_,b,y);const l=t.scaleToGeodeticSurface(y,w);if(Object(u["a"])(l)){const e=o["a"].distance(y,l);r=Math.min(r,-e)}else r=j._defaultMinTerrainHeight}return r=Math.max(j._defaultMinTerrainHeight,r),{minimumTerrainHeight:r,maximumTerrainHeight:a}},j.getBoundingSphere=function(e,t){if(l["a"].defined("rectangle",e),!Object(u["a"])(j._terrainHeights))throw new d["a"]("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");t=Object(c["a"])(t,h["a"].WGS84);const i=O(e);let a=j._defaultMaxTerrainHeight;if(Object(u["a"])(i)){const e=`${i.level}-${i.x}-${i.y}`,t=j._terrainHeights[e];Object(u["a"])(t)&&(a=t[1])}const n=r["a"].fromRectangle3D(e,t,0);return r["a"].fromRectangle3D(e,t,a,p),r["a"].union(n,p,n)},j._terrainHeightsMaxLevel=6,j._defaultMaxTerrainHeight=9e3,j._defaultMinTerrainHeight=-1e5,j._terrainHeights=void 0,j._initPromise=void 0,Object.defineProperties(j,{initialized:{get:function(){return Object(u["a"])(j._terrainHeights)}}}),t["a"]=j}}]);