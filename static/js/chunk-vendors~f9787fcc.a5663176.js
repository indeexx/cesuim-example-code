(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-vendors~f9787fcc"],{"0161":function(e,t,n){"use strict";var a=n("1a5d"),r=n("c937"),o=n("e2a6");function i(e){if(e=Object(a["a"])(e,a["a"].EMPTY_OBJECT),!Object(r["a"])(e.componentDatatype))throw new o["a"]("options.componentDatatype is required.");if(!Object(r["a"])(e.componentsPerAttribute))throw new o["a"]("options.componentsPerAttribute is required.");if(e.componentsPerAttribute<1||e.componentsPerAttribute>4)throw new o["a"]("options.componentsPerAttribute must be between 1 and 4.");if(!Object(r["a"])(e.value))throw new o["a"]("options.value is required.");this.componentDatatype=e.componentDatatype,this.componentsPerAttribute=e.componentsPerAttribute,this.normalize=Object(a["a"])(e.normalize,!1),this.value=e.value}t["a"]=i},"0c02":function(e,t,n){"use strict";var a=n("1a5d");function r(e){e=Object(a["a"])(e,a["a"].EMPTY_OBJECT),this.position=e.position,this.normal=e.normal,this.st=e.st,this.bitangent=e.bitangent,this.tangent=e.tangent,this.color=e.color}t["a"]=r},"1f02":function(e,t,n){"use strict";var a=n("dde0"),r=n("8d54"),o=n("1a5d"),i=n("c937"),s=n("e2a6"),c=n("e107");function u(e){this._ellipsoid=Object(o["a"])(e,c["a"].WGS84),this._semimajorAxis=this._ellipsoid.maximumRadius,this._oneOverSemimajorAxis=1/this._semimajorAxis}Object.defineProperties(u.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}}),u.prototype.project=function(e,t){const n=this._semimajorAxis,r=e.longitude*n,o=e.latitude*n,s=e.height;return Object(i["a"])(t)?(t.x=r,t.y=o,t.z=s,t):new a["a"](r,o,s)},u.prototype.unproject=function(e,t){if(!Object(i["a"])(e))throw new s["a"]("cartesian is required");const n=this._oneOverSemimajorAxis,a=e.x*n,o=e.y*n,c=e.z;return Object(i["a"])(t)?(t.longitude=a,t.latitude=o,t.height=c,t):new r["a"](a,o,c)},t["a"]=u},"2dd3":function(e,t,n){"use strict";var a=n("85b2"),r=n("ae9b"),o=n("1a5d"),i=n("c937"),s=n("e107"),c=n("1f02"),u=n("b8b5"),l=n("4a63");function p(e){e=Object(o["a"])(e,o["a"].EMPTY_OBJECT),this._ellipsoid=Object(o["a"])(e.ellipsoid,s["a"].WGS84),this._rectangle=Object(o["a"])(e.rectangle,l["a"].MAX_VALUE),this._projection=new c["a"](this._ellipsoid),this._numberOfLevelZeroTilesX=Object(o["a"])(e.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=Object(o["a"])(e.numberOfLevelZeroTilesY,1)}Object.defineProperties(p.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),p.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},p.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},p.prototype.rectangleToNativeRectangle=function(e,t){r["a"].defined("rectangle",e);const n=u["a"].toDegrees(e.west),a=u["a"].toDegrees(e.south),o=u["a"].toDegrees(e.east),s=u["a"].toDegrees(e.north);return Object(i["a"])(t)?(t.west=n,t.south=a,t.east=o,t.north=s,t):new l["a"](n,a,o,s)},p.prototype.tileXYToNativeRectangle=function(e,t,n,a){const r=this.tileXYToRectangle(e,t,n,a);return r.west=u["a"].toDegrees(r.west),r.south=u["a"].toDegrees(r.south),r.east=u["a"].toDegrees(r.east),r.north=u["a"].toDegrees(r.north),r},p.prototype.tileXYToRectangle=function(e,t,n,a){const r=this._rectangle,o=this.getNumberOfXTilesAtLevel(n),s=this.getNumberOfYTilesAtLevel(n),c=r.width/o,u=e*c+r.west,p=(e+1)*c+r.west,f=r.height/s,b=r.north-t*f,m=r.north-(t+1)*f;return Object(i["a"])(a)||(a=new l["a"](u,m,p,b)),a.west=u,a.south=m,a.east=p,a.north=b,a},p.prototype.positionToTileXY=function(e,t,n){const r=this._rectangle;if(!l["a"].contains(r,e))return;const o=this.getNumberOfXTilesAtLevel(t),s=this.getNumberOfYTilesAtLevel(t),c=r.width/o,p=r.height/s;let f=e.longitude;r.east<r.west&&(f+=u["a"].TWO_PI);let b=(f-r.west)/c|0;b>=o&&(b=o-1);let m=(r.north-e.latitude)/p|0;return m>=s&&(m=s-1),Object(i["a"])(n)?(n.x=b,n.y=m,n):new a["a"](b,m)},t["a"]=p},"41cd":function(e,t,n){"use strict";var a=n("8656"),r=n("dde0"),o=n("ae9b"),i=n("cbf0"),s=n("1a5d"),c=n("c937"),u=n("7828"),l=n("5a72"),p=n("f3a4"),f=n("0c02"),b=n("ec1a"),m=n("3f87"),y=n("82ba"),d=n("1b9c");const h=0,g=1;function w(e){o["a"].typeOf.object("options",e),o["a"].typeOf.object("options.frustum",e.frustum),o["a"].typeOf.object("options.origin",e.origin),o["a"].typeOf.object("options.orientation",e.orientation);const t=e.frustum,n=e.orientation,a=e.origin,i=Object(s["a"])(e._drawNearPlane,!0);let c,u;t instanceof m["a"]?(c=h,u=m["a"].packedLength):t instanceof b["a"]&&(c=g,u=b["a"].packedLength),this._frustumType=c,this._frustum=t.clone(),this._origin=r["a"].clone(a),this._orientation=d["a"].clone(n),this._drawNearPlane=i,this._workerName="createFrustumOutlineGeometry",this.packedLength=2+u+r["a"].packedLength+d["a"].packedLength}w.pack=function(e,t,n){o["a"].typeOf.object("value",e),o["a"].defined("array",t),n=Object(s["a"])(n,0);const a=e._frustumType,i=e._frustum;return t[n++]=a,a===h?(m["a"].pack(i,t,n),n+=m["a"].packedLength):(b["a"].pack(i,t,n),n+=b["a"].packedLength),r["a"].pack(e._origin,t,n),n+=r["a"].packedLength,d["a"].pack(e._orientation,t,n),n+=d["a"].packedLength,t[n]=e._drawNearPlane?1:0,t};const O=new m["a"],v=new b["a"],A=new d["a"],j=new r["a"];w.unpack=function(e,t,n){o["a"].defined("array",e),t=Object(s["a"])(t,0);const a=e[t++];let i;a===h?(i=m["a"].unpack(e,t,O),t+=m["a"].packedLength):(i=b["a"].unpack(e,t,v),t+=b["a"].packedLength);const u=r["a"].unpack(e,t,j);t+=r["a"].packedLength;const l=d["a"].unpack(e,t,A);t+=d["a"].packedLength;const p=1===e[t];if(!Object(c["a"])(n))return new w({frustum:i,origin:u,orientation:l,_drawNearPlane:p});const f=a===n._frustumType?n._frustum:void 0;return n._frustum=i.clone(f),n._frustumType=a,n._origin=r["a"].clone(u,n._origin),n._orientation=d["a"].clone(l,n._orientation),n._drawNearPlane=p,n},w.createGeometry=function(e){const t=e._frustumType,n=e._frustum,r=e._origin,o=e._orientation,s=e._drawNearPlane,c=new Float64Array(24);u["a"]._computeNearFarPlanes(r,o,t,n,c);const b=new f["a"]({position:new p["a"]({componentDatatype:i["a"].DOUBLE,componentsPerAttribute:3,values:c})});let m,d;const h=s?2:1,g=new Uint16Array(8*(h+1));let w=s?0:1;for(;w<2;++w)m=s?8*w:0,d=4*w,g[m]=d,g[m+1]=d+1,g[m+2]=d+1,g[m+3]=d+2,g[m+4]=d+2,g[m+5]=d+3,g[m+6]=d+3,g[m+7]=d;for(w=0;w<2;++w)m=8*(h+w),d=4*w,g[m]=d,g[m+1]=d+4,g[m+2]=d+1,g[m+3]=d+5,g[m+4]=d+2,g[m+5]=d+6,g[m+6]=d+3,g[m+7]=d+7;return new l["a"]({attributes:b,indices:g,primitiveType:y["a"].LINES,boundingSphere:a["a"].fromVertices(c)})},t["a"]=w},"455b":function(e,t,n){"use strict";var a=n("e2a6");function r(){}r.prototype.geocode=a["a"].throwInstantiationError},4601:function(e,t,n){"use strict";const a={NONE:0,HOLD:1,EXTRAPOLATE:2};t["a"]=Object.freeze(a)},"5a72":function(e,t,n){"use strict";var a=n("85b2"),r=n("dde0"),o=n("8d54"),i=n("ae9b"),s=n("1a5d"),c=n("c937"),u=n("e2a6"),l=n("bd7a"),p=n("d70f"),f=n("d767"),b=n("722e"),m=n("82ba"),y=n("1b9c"),d=n("4a63"),h=n("6f7c");function g(e){e=Object(s["a"])(e,s["a"].EMPTY_OBJECT),i["a"].typeOf.object("options.attributes",e.attributes),this.attributes=e.attributes,this.indices=e.indices,this.primitiveType=Object(s["a"])(e.primitiveType,m["a"].TRIANGLES),this.boundingSphere=e.boundingSphere,this.geometryType=Object(s["a"])(e.geometryType,l["a"].NONE),this.boundingSphereCV=e.boundingSphereCV,this.offsetAttribute=e.offsetAttribute}g.computeNumberOfVertices=function(e){i["a"].typeOf.object("geometry",e);let t=-1;for(const n in e.attributes)if(e.attributes.hasOwnProperty(n)&&Object(c["a"])(e.attributes[n])&&Object(c["a"])(e.attributes[n].values)){const a=e.attributes[n],r=a.values.length/a.componentsPerAttribute;if(t!==r&&-1!==t)throw new u["a"]("All attribute lists must have the same number of attributes.");t=r}return t};const w=new o["a"],O=new r["a"],v=new b["a"],A=[new o["a"],new o["a"],new o["a"]],j=[new a["a"],new a["a"],new a["a"]],T=[new a["a"],new a["a"],new a["a"]],x=new r["a"],P=new y["a"],E=new b["a"],N=new p["a"];g._textureCoordinateRotationPoints=function(e,t,n,i){let s;const c=d["a"].center(i,w),u=o["a"].toCartesian(c,n,O),l=h["a"].eastNorthUpToFixedFrame(u,n,v),m=b["a"].inverse(l,v),g=j,L=A;L[0].longitude=i.west,L[0].latitude=i.south,L[1].longitude=i.west,L[1].latitude=i.north,L[2].longitude=i.east,L[2].latitude=i.south;let _=x;for(s=0;s<3;s++)o["a"].toCartesian(L[s],n,_),_=b["a"].multiplyByPointAsVector(m,_,_),g[s].x=_.x,g[s].y=_.y;const I=y["a"].fromAxisAngle(r["a"].UNIT_Z,-t,P),S=f["a"].fromQuaternion(I,E),F=e.length;let k=Number.POSITIVE_INFINITY,z=Number.POSITIVE_INFINITY,D=Number.NEGATIVE_INFINITY,q=Number.NEGATIVE_INFINITY;for(s=0;s<F;s++)_=b["a"].multiplyByPointAsVector(m,e[s],_),_=f["a"].multiplyByVector(S,_,_),k=Math.min(k,_.x),z=Math.min(z,_.y),D=Math.max(D,_.x),q=Math.max(q,_.y);const R=p["a"].fromRotation(t,N),B=T;B[0].x=k,B[0].y=z,B[1].x=k,B[1].y=q,B[2].x=D,B[2].y=z;const C=g[0],V=g[2].x-C.x,G=g[1].y-C.y;for(s=0;s<3;s++){const e=B[s];p["a"].multiplyByVector(R,e,e),e.x=(e.x-C.x)/V,e.y=(e.y-C.y)/G}const U=B[0],M=B[1],Y=B[2],W=new Array(6);return a["a"].pack(U,W),a["a"].pack(M,W,2),a["a"].pack(Y,W,4),W},t["a"]=g},"5fcc":function(e,t,n){"use strict";var a=n("c937");let r;const o={requestFullscreen:void 0,exitFullscreen:void 0,fullscreenEnabled:void 0,fullscreenElement:void 0,fullscreenchange:void 0,fullscreenerror:void 0},i={};Object.defineProperties(i,{element:{get:function(){if(i.supportsFullscreen())return document[o.fullscreenElement]}},changeEventName:{get:function(){if(i.supportsFullscreen())return o.fullscreenchange}},errorEventName:{get:function(){if(i.supportsFullscreen())return o.fullscreenerror}},enabled:{get:function(){if(i.supportsFullscreen())return document[o.fullscreenEnabled]}},fullscreen:{get:function(){if(i.supportsFullscreen())return null!==i.element}}}),i.supportsFullscreen=function(){if(Object(a["a"])(r))return r;r=!1;const e=document.body;if("function"===typeof e.requestFullscreen)return o.requestFullscreen="requestFullscreen",o.exitFullscreen="exitFullscreen",o.fullscreenEnabled="fullscreenEnabled",o.fullscreenElement="fullscreenElement",o.fullscreenchange="fullscreenchange",o.fullscreenerror="fullscreenerror",r=!0,r;const t=["webkit","moz","o","ms","khtml"];let n;for(let a=0,i=t.length;a<i;++a){const i=t[a];n=i+"RequestFullscreen","function"===typeof e[n]?(o.requestFullscreen=n,r=!0):(n=i+"RequestFullScreen","function"===typeof e[n]&&(o.requestFullscreen=n,r=!0)),n=i+"ExitFullscreen","function"===typeof document[n]?o.exitFullscreen=n:(n=i+"CancelFullScreen","function"===typeof document[n]&&(o.exitFullscreen=n)),n=i+"FullscreenEnabled",void 0!==document[n]?o.fullscreenEnabled=n:(n=i+"FullScreenEnabled",void 0!==document[n]&&(o.fullscreenEnabled=n)),n=i+"FullscreenElement",void 0!==document[n]?o.fullscreenElement=n:(n=i+"FullScreenElement",void 0!==document[n]&&(o.fullscreenElement=n)),n=i+"fullscreenchange",void 0!==document["on"+n]&&("ms"===i&&(n="MSFullscreenChange"),o.fullscreenchange=n),n=i+"fullscreenerror",void 0!==document["on"+n]&&("ms"===i&&(n="MSFullscreenError"),o.fullscreenerror=n)}return r},i.requestFullscreen=function(e,t){i.supportsFullscreen()&&e[o.requestFullscreen]({vrDisplay:t})},i.exitFullscreen=function(){i.supportsFullscreen()&&document[o.exitFullscreen]()},i._names=o,t["a"]=i},7828:function(e,t,n){"use strict";var a=n("8656"),r=n("dde0"),o=n("6b82"),i=n("ae9b"),s=n("cbf0"),c=n("1a5d"),u=n("c937"),l=n("5a72"),p=n("f3a4"),f=n("0c02"),b=n("d767"),m=n("722e"),y=n("ec1a"),d=n("3f87"),h=n("82ba"),g=n("1b9c"),w=n("514d");const O=0,v=1;function A(e){i["a"].typeOf.object("options",e),i["a"].typeOf.object("options.frustum",e.frustum),i["a"].typeOf.object("options.origin",e.origin),i["a"].typeOf.object("options.orientation",e.orientation);const t=e.frustum,n=e.orientation,a=e.origin,o=Object(c["a"])(e.vertexFormat,w["a"].DEFAULT),s=Object(c["a"])(e._drawNearPlane,!0);let u,l;t instanceof d["a"]?(u=O,l=d["a"].packedLength):t instanceof y["a"]&&(u=v,l=y["a"].packedLength),this._frustumType=u,this._frustum=t.clone(),this._origin=r["a"].clone(a),this._orientation=g["a"].clone(n),this._drawNearPlane=s,this._vertexFormat=o,this._workerName="createFrustumGeometry",this.packedLength=2+l+r["a"].packedLength+g["a"].packedLength+w["a"].packedLength}A.pack=function(e,t,n){i["a"].typeOf.object("value",e),i["a"].defined("array",t),n=Object(c["a"])(n,0);const a=e._frustumType,o=e._frustum;return t[n++]=a,a===O?(d["a"].pack(o,t,n),n+=d["a"].packedLength):(y["a"].pack(o,t,n),n+=y["a"].packedLength),r["a"].pack(e._origin,t,n),n+=r["a"].packedLength,g["a"].pack(e._orientation,t,n),n+=g["a"].packedLength,w["a"].pack(e._vertexFormat,t,n),n+=w["a"].packedLength,t[n]=e._drawNearPlane?1:0,t};const j=new d["a"],T=new y["a"],x=new g["a"],P=new r["a"],E=new w["a"];function N(e,t,n,a,r,o,i,s){const c=e/3*2;for(let l=0;l<4;++l)Object(u["a"])(t)&&(t[e]=o.x,t[e+1]=o.y,t[e+2]=o.z),Object(u["a"])(n)&&(n[e]=i.x,n[e+1]=i.y,n[e+2]=i.z),Object(u["a"])(a)&&(a[e]=s.x,a[e+1]=s.y,a[e+2]=s.z),e+=3;r[c]=0,r[c+1]=0,r[c+2]=1,r[c+3]=0,r[c+4]=1,r[c+5]=1,r[c+6]=0,r[c+7]=1}A.unpack=function(e,t,n){i["a"].defined("array",e),t=Object(c["a"])(t,0);const a=e[t++];let o;a===O?(o=d["a"].unpack(e,t,j),t+=d["a"].packedLength):(o=y["a"].unpack(e,t,T),t+=y["a"].packedLength);const s=r["a"].unpack(e,t,P);t+=r["a"].packedLength;const l=g["a"].unpack(e,t,x);t+=g["a"].packedLength;const p=w["a"].unpack(e,t,E);t+=w["a"].packedLength;const f=1===e[t];if(!Object(u["a"])(n))return new A({frustum:o,origin:s,orientation:l,vertexFormat:p,_drawNearPlane:f});const b=a===n._frustumType?n._frustum:void 0;return n._frustum=o.clone(b),n._frustumType=a,n._origin=r["a"].clone(s,n._origin),n._orientation=g["a"].clone(l,n._orientation),n._vertexFormat=w["a"].clone(p,n._vertexFormat),n._drawNearPlane=f,n};const L=new b["a"],_=new m["a"],I=new m["a"],S=new r["a"],F=new r["a"],k=new r["a"],z=new r["a"],D=new r["a"],q=new r["a"],R=new Array(3),B=new Array(4);B[0]=new o["a"](-1,-1,1,1),B[1]=new o["a"](1,-1,1,1),B[2]=new o["a"](1,1,1,1),B[3]=new o["a"](-1,1,1,1);const C=new Array(4);for(let V=0;V<4;++V)C[V]=new o["a"];A._computeNearFarPlanes=function(e,t,n,a,i,s,l,p){const f=b["a"].fromQuaternion(t,L);let y=Object(c["a"])(s,S),d=Object(c["a"])(l,F),h=Object(c["a"])(p,k);y=b["a"].getColumn(f,0,y),d=b["a"].getColumn(f,1,d),h=b["a"].getColumn(f,2,h),r["a"].normalize(y,y),r["a"].normalize(d,d),r["a"].normalize(h,h),r["a"].negate(y,y);const g=m["a"].computeView(e,h,d,y,_);let w,v;if(n===O){const e=a.projectionMatrix,t=m["a"].multiply(e,g,I);v=m["a"].inverse(t,I)}else w=m["a"].inverseTransformation(g,I);Object(u["a"])(v)?(R[0]=a.near,R[1]=a.far):(R[0]=0,R[1]=a.near,R[2]=a.far);for(let c=0;c<2;++c)for(let t=0;t<4;++t){let n=o["a"].clone(B[t],C[t]);if(Object(u["a"])(v)){n=m["a"].multiplyByVector(v,n,n);const t=1/n.w;r["a"].multiplyByScalar(n,t,n),r["a"].subtract(n,e,n),r["a"].normalize(n,n);const a=r["a"].dot(h,n);r["a"].multiplyByScalar(n,R[c]/a,n),r["a"].add(n,e,n)}else{Object(u["a"])(a._offCenterFrustum)&&(a=a._offCenterFrustum);const e=R[c],t=R[c+1];n.x=.5*(n.x*(a.right-a.left)+a.left+a.right),n.y=.5*(n.y*(a.top-a.bottom)+a.bottom+a.top),n.z=.5*(n.z*(e-t)-e-t),n.w=1,m["a"].multiplyByVector(w,n,n)}i[12*c+3*t]=n.x,i[12*c+3*t+1]=n.y,i[12*c+3*t+2]=n.z}},A.createGeometry=function(e){const t=e._frustumType,n=e._frustum,o=e._origin,i=e._orientation,c=e._drawNearPlane,b=e._vertexFormat,m=c?6:5;let y=new Float64Array(72);A._computeNearFarPlanes(o,i,t,n,y);let d=24;y[d]=y[12],y[d+1]=y[13],y[d+2]=y[14],y[d+3]=y[0],y[d+4]=y[1],y[d+5]=y[2],y[d+6]=y[9],y[d+7]=y[10],y[d+8]=y[11],y[d+9]=y[21],y[d+10]=y[22],y[d+11]=y[23],d+=12,y[d]=y[15],y[d+1]=y[16],y[d+2]=y[17],y[d+3]=y[3],y[d+4]=y[4],y[d+5]=y[5],y[d+6]=y[0],y[d+7]=y[1],y[d+8]=y[2],y[d+9]=y[12],y[d+10]=y[13],y[d+11]=y[14],d+=12,y[d]=y[3],y[d+1]=y[4],y[d+2]=y[5],y[d+3]=y[15],y[d+4]=y[16],y[d+5]=y[17],y[d+6]=y[18],y[d+7]=y[19],y[d+8]=y[20],y[d+9]=y[6],y[d+10]=y[7],y[d+11]=y[8],d+=12,y[d]=y[6],y[d+1]=y[7],y[d+2]=y[8],y[d+3]=y[18],y[d+4]=y[19],y[d+5]=y[20],y[d+6]=y[21],y[d+7]=y[22],y[d+8]=y[23],y[d+9]=y[9],y[d+10]=y[10],y[d+11]=y[11],c||(y=y.subarray(12));const g=new f["a"]({position:new p["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:y})});if(Object(u["a"])(b.normal)||Object(u["a"])(b.tangent)||Object(u["a"])(b.bitangent)||Object(u["a"])(b.st)){const e=Object(u["a"])(b.normal)?new Float32Array(12*m):void 0,t=Object(u["a"])(b.tangent)?new Float32Array(12*m):void 0,n=Object(u["a"])(b.bitangent)?new Float32Array(12*m):void 0,a=Object(u["a"])(b.st)?new Float32Array(8*m):void 0,o=S,i=F,l=k,f=r["a"].negate(o,z),y=r["a"].negate(i,D),h=r["a"].negate(l,q);d=0,c&&(N(d,e,t,n,a,h,o,i),d+=12),N(d,e,t,n,a,l,f,i),d+=12,N(d,e,t,n,a,f,h,i),d+=12,N(d,e,t,n,a,y,h,f),d+=12,N(d,e,t,n,a,o,l,i),d+=12,N(d,e,t,n,a,i,l,f),Object(u["a"])(e)&&(g.normal=new p["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:e})),Object(u["a"])(t)&&(g.tangent=new p["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:t})),Object(u["a"])(n)&&(g.bitangent=new p["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:n})),Object(u["a"])(a)&&(g.st=new p["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:2,values:a}))}const w=new Uint16Array(6*m);for(let a=0;a<m;++a){const e=6*a,t=4*a;w[e]=t,w[e+1]=t+1,w[e+2]=t+2,w[e+3]=t,w[e+4]=t+2,w[e+5]=t+3}return new l["a"]({attributes:g,indices:w,primitiveType:h["a"].TRIANGLES,boundingSphere:a["a"].fromVertices(y)})},t["a"]=A},"8e1f":function(e,t,n){"use strict";var a=n("1a5d"),r=n("61ad"),o=n("c937"),i=n("e2a6"),s=n("5fcc");let c,u,l,p,f,b,m,y,d,h,g,w,O,v,A,j,T;function x(e){const t=e.split(".");for(let n=0,a=t.length;n<a;++n)t[n]=parseInt(t[n],10);return t}function P(){if(!Object(o["a"])(u)&&(u=!1,!k())){const e=/ Chrome\/([\.0-9]+)/.exec(c.userAgent);null!==e&&(u=!0,l=x(e[1]))}return u}function E(){return P()&&l}function N(){if(!Object(o["a"])(p)&&(p=!1,!P()&&!k()&&/ Safari\/[\.0-9]+/.test(c.userAgent))){const e=/ Version\/([\.0-9]+)/.exec(c.userAgent);null!==e&&(p=!0,f=x(e[1]))}return p}function L(){return N()&&f}function _(){if(!Object(o["a"])(b)){b=!1;const e=/ AppleWebKit\/([\.0-9]+)(\+?)/.exec(c.userAgent);null!==e&&(b=!0,m=x(e[1]),m.isNightly=!!e[2])}return b}function I(){return _()&&m}function S(){if(!Object(o["a"])(y)){let e;y=!1,"Microsoft Internet Explorer"===c.appName?(e=/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(c.userAgent),null!==e&&(y=!0,d=x(e[1]))):"Netscape"===c.appName&&(e=/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(c.userAgent),null!==e&&(y=!0,d=x(e[1])))}return y}function F(){return S()&&d}function k(){if(!Object(o["a"])(h)){h=!1;const e=/ Edge\/([\.0-9]+)/.exec(c.userAgent);null!==e&&(h=!0,g=x(e[1]))}return h}function z(){return k()&&g}function D(){if(!Object(o["a"])(w)){w=!1;const e=/Firefox\/([\.0-9]+)/.exec(c.userAgent);null!==e&&(w=!0,O=x(e[1]))}return w}function q(){return Object(o["a"])(v)||(v=/Windows/i.test(c.appVersion)),v}function R(){return D()&&O}function B(){return Object(o["a"])(A)||(A=!D()&&"undefined"!==typeof PointerEvent&&(!Object(o["a"])(c.pointerEnabled)||c.pointerEnabled)),A}function C(){if(!Object(o["a"])(T)){const e=document.createElement("canvas");e.setAttribute("style","image-rendering: -moz-crisp-edges;image-rendering: pixelated;");const t=e.style.imageRendering;T=Object(o["a"])(t)&&""!==t,T&&(j=t)}return T}function V(){return C()?j:void 0}function G(){if(!G.initialized)throw new i["a"]("You must call FeatureDetection.supportsWebP.initialize and wait for the promise to resolve before calling FeatureDetection.supportsWebP");return G._result}c="undefined"!==typeof navigator?navigator:{},G._promise=void 0,G._result=void 0,G.initialize=function(){if(Object(o["a"])(G._promise))return G._promise;const e=Object(r["a"])();if(G._promise=e.promise,k())return G._result=!1,e.resolve(G._result),e.promise;const t=new Image;return t.onload=function(){G._result=t.width>0&&t.height>0,e.resolve(G._result)},t.onerror=function(){G._result=!1,e.resolve(G._result)},t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.promise},Object.defineProperties(G,{initialized:{get:function(){return Object(o["a"])(G._result)}}});const U=[];"undefined"!==typeof ArrayBuffer&&(U.push(Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array),"undefined"!==typeof Uint8ClampedArray&&U.push(Uint8ClampedArray),"undefined"!==typeof Uint8ClampedArray&&U.push(Uint8ClampedArray),"undefined"!==typeof BigInt64Array&&U.push(BigInt64Array),"undefined"!==typeof BigUint64Array&&U.push(BigUint64Array));const M={isChrome:P,chromeVersion:E,isSafari:N,safariVersion:L,isWebkit:_,webkitVersion:I,isInternetExplorer:S,internetExplorerVersion:F,isEdge:k,edgeVersion:z,isFirefox:D,firefoxVersion:R,isWindows:q,hardwareConcurrency:Object(a["a"])(c.hardwareConcurrency,3),supportsPointerEvents:B,supportsImageRenderingPixelated:C,supportsWebP:G,imageRenderingValue:V,typedArrayTypes:U,supportsBasis:function(e){return M.supportsWebAssembly()&&e.context.supportsBasis},supportsFullscreen:function(){return s["a"].supportsFullscreen()},supportsTypedArrays:function(){return"undefined"!==typeof ArrayBuffer},supportsBigInt64Array:function(){return"undefined"!==typeof BigInt64Array},supportsBigUint64Array:function(){return"undefined"!==typeof BigUint64Array},supportsBigInt:function(){return"undefined"!==typeof BigInt},supportsWebWorkers:function(){return"undefined"!==typeof Worker},supportsWebAssembly:function(){return"undefined"!==typeof WebAssembly&&!M.isEdge()}};t["a"]=M},bd7a:function(e,t,n){"use strict";const a={NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3};t["a"]=Object.freeze(a)},d292:function(e,t,n){"use strict";const a={enableModelExperimental:!1};t["a"]=a},e148:function(e,t,n){"use strict";const a={NONE:0,TOP:1,ALL:2};t["a"]=Object.freeze(a)},e242:function(e,t,n){"use strict";var a=n("e2a6");function r(){a["a"].throwInstantiationError()}r.createGeometry=function(e){a["a"].throwInstantiationError()}},e8ff:function(e,t,n){"use strict";var a=n("1a5d"),r=n("c937"),o=n("e2a6"),i=n("722e");function s(e){if(e=Object(a["a"])(e,a["a"].EMPTY_OBJECT),!Object(r["a"])(e.geometry))throw new o["a"]("options.geometry is required.");this.geometry=e.geometry,this.modelMatrix=i["a"].clone(Object(a["a"])(e.modelMatrix,i["a"].IDENTITY)),this.id=e.id,this.pickPrimitive=e.pickPrimitive,this.attributes=Object(a["a"])(e.attributes,{}),this.westHemisphereGeometry=void 0,this.eastHemisphereGeometry=void 0}t["a"]=s},f3a4:function(e,t,n){"use strict";var a=n("1a5d"),r=n("c937"),o=n("e2a6");function i(e){if(e=Object(a["a"])(e,a["a"].EMPTY_OBJECT),!Object(r["a"])(e.componentDatatype))throw new o["a"]("options.componentDatatype is required.");if(!Object(r["a"])(e.componentsPerAttribute))throw new o["a"]("options.componentsPerAttribute is required.");if(e.componentsPerAttribute<1||e.componentsPerAttribute>4)throw new o["a"]("options.componentsPerAttribute must be between 1 and 4.");if(!Object(r["a"])(e.values))throw new o["a"]("options.values is required.");this.componentDatatype=e.componentDatatype,this.componentsPerAttribute=e.componentsPerAttribute,this.normalize=Object(a["a"])(e.normalize,!1),this.values=e.values}t["a"]=i},f4ed:function(e,t,n){"use strict";const a={SEARCH:0,AUTOCOMPLETE:1};t["a"]=Object.freeze(a)},f6fe:function(e,t,n){"use strict";var a=n("cf26"),r=n("3ec6"),o=n("8656"),i=n("85b2"),s=n("dde0"),c=n("6b82"),u=n("8d54"),l=n("cbf0"),p=n("1a5d"),f=n("c937"),b=n("e2a6"),m=n("d809"),y=n("1f02"),d=n("5a72"),h=n("f3a4"),g=n("bd7a"),w=n("2642"),O=n("a61d"),v=n("7f05"),A=n("b8b5"),j=n("d767"),T=n("722e"),x=n("a7b2"),P=n("82ba"),E=n("9a62");const N={};function L(e,t,n,a,r){e[t++]=n,e[t++]=a,e[t++]=a,e[t++]=r,e[t++]=r,e[t]=n}function _(e){const t=e.length,n=t/3*6,a=w["a"].createTypedArray(t,n);let r=0;for(let o=0;o<t;o+=3,r+=6)L(a,r,e[o],e[o+1],e[o+2]);return a}function I(e){const t=e.length;if(t>=3){const n=6*(t-2),a=w["a"].createTypedArray(t,n);L(a,0,e[0],e[1],e[2]);let r=6;for(let o=3;o<t;++o,r+=6)L(a,r,e[o-1],e[o],e[o-2]);return a}return new Uint16Array}function S(e){if(e.length>0){const t=e.length-1,n=6*(t-1),a=w["a"].createTypedArray(t,n),r=e[0];let o=0;for(let i=1;i<t;++i,o+=6)L(a,o,r,e[i],e[i+1]);return a}return new Uint16Array}function F(e){const t={};for(const n in e)if(e.hasOwnProperty(n)&&Object(f["a"])(e[n])&&Object(f["a"])(e[n].values)){const a=e[n];t[n]=new h["a"]({componentDatatype:a.componentDatatype,componentsPerAttribute:a.componentsPerAttribute,normalize:a.normalize,values:[]})}return t}function k(e,t,n){for(const a in t)if(t.hasOwnProperty(a)&&Object(f["a"])(t[a])&&Object(f["a"])(t[a].values)){const r=t[a];for(let t=0;t<r.componentsPerAttribute;++t)e[a].values.push(r.values[n*r.componentsPerAttribute+t])}}N.toWireframe=function(e){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");const t=e.indices;if(Object(f["a"])(t)){switch(e.primitiveType){case P["a"].TRIANGLES:e.indices=_(t);break;case P["a"].TRIANGLE_STRIP:e.indices=I(t);break;case P["a"].TRIANGLE_FAN:e.indices=S(t);break;default:throw new b["a"]("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}e.primitiveType=P["a"].LINES}return e},N.createLineSegmentsForVectors=function(e,t,n){if(t=Object(p["a"])(t,"normal"),!Object(f["a"])(e))throw new b["a"]("geometry is required.");if(!Object(f["a"])(e.attributes.position))throw new b["a"]("geometry.attributes.position is required.");if(!Object(f["a"])(e.attributes[t]))throw new b["a"](`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${t}.`);n=Object(p["a"])(n,1e4);const a=e.attributes.position.values,r=e.attributes[t].values,i=a.length,s=new Float64Array(2*i);let c,u=0;for(let o=0;o<i;o+=3)s[u++]=a[o],s[u++]=a[o+1],s[u++]=a[o+2],s[u++]=a[o]+r[o]*n,s[u++]=a[o+1]+r[o+1]*n,s[u++]=a[o+2]+r[o+2]*n;const m=e.boundingSphere;return Object(f["a"])(m)&&(c=new o["a"](m.center,m.radius+n)),new d["a"]({attributes:{position:new h["a"]({componentDatatype:l["a"].DOUBLE,componentsPerAttribute:3,values:s})},primitiveType:P["a"].LINES,boundingSphere:c})},N.createAttributeLocations=function(e){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");const t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],n=e.attributes,a={};let r,o=0;const i=t.length;for(r=0;r<i;++r){const e=t[r];Object(f["a"])(n[e])&&(a[e]=o++)}for(const s in n)n.hasOwnProperty(s)&&!Object(f["a"])(a[s])&&(a[s]=o++);return a},N.reorderForPreVertexCache=function(e){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");const t=d["a"].computeNumberOfVertices(e),n=e.indices;if(Object(f["a"])(n)){const a=new Int32Array(t);for(let e=0;e<t;e++)a[e]=-1;const r=n,o=r.length,i=w["a"].createTypedArray(t,o);let s,c=0,u=0,p=0;while(c<o)s=a[r[c]],-1!==s?i[u]=s:(s=r[c],a[s]=p,i[u]=p,++p),++c,++u;e.indices=i;const b=e.attributes;for(const e in b)if(b.hasOwnProperty(e)&&Object(f["a"])(b[e])&&Object(f["a"])(b[e].values)){const n=b[e],r=n.values;let o=0;const i=n.componentsPerAttribute,s=l["a"].createTypedArray(n.componentDatatype,p*i);while(o<t){const e=a[o];if(-1!==e)for(let t=0;t<i;t++)s[i*e+t]=r[i*o+t];++o}n.values=s}}return e},N.reorderForPostVertexCache=function(e,t){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");const n=e.indices;if(e.primitiveType===P["a"].TRIANGLES&&Object(f["a"])(n)){const a=n.length;let r=0;for(let e=0;e<a;e++)n[e]>r&&(r=n[e]);e.indices=E["a"].tipsify({indices:n,maximumIndex:r,cacheSize:t})}return e},N.fitToUnsignedShortIndices=function(e){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");if(Object(f["a"])(e.indices)&&e.primitiveType!==P["a"].TRIANGLES&&e.primitiveType!==P["a"].LINES&&e.primitiveType!==P["a"].POINTS)throw new b["a"]("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");const t=[],n=d["a"].computeNumberOfVertices(e);if(Object(f["a"])(e.indices)&&n>=A["a"].SIXTY_FOUR_KILOBYTES){let n=[],a=[],r=0,o=F(e.attributes);const i=e.indices,s=i.length;let c;e.primitiveType===P["a"].TRIANGLES?c=3:e.primitiveType===P["a"].LINES?c=2:e.primitiveType===P["a"].POINTS&&(c=1);for(let u=0;u<s;u+=c){for(let t=0;t<c;++t){const s=i[u+t];let c=n[s];Object(f["a"])(c)||(c=r++,n[s]=c,k(o,e.attributes,s)),a.push(c)}r+c>=A["a"].SIXTY_FOUR_KILOBYTES&&(t.push(new d["a"]({attributes:o,indices:a,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),n=[],a=[],r=0,o=F(e.attributes))}0!==a.length&&t.push(new d["a"]({attributes:o,indices:a,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};const z=new s["a"],D=new u["a"];N.projectTo2D=function(e,t,n,a,r){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");if(!Object(f["a"])(t))throw new b["a"]("attributeName is required.");if(!Object(f["a"])(n))throw new b["a"]("attributeName3D is required.");if(!Object(f["a"])(a))throw new b["a"]("attributeName2D is required.");if(!Object(f["a"])(e.attributes[t]))throw new b["a"](`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==l["a"].DOUBLE)throw new b["a"]("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const o=e.attributes[t];r=Object(f["a"])(r)?r:new y["a"];const i=r.ellipsoid,c=o.values,u=new Float64Array(c.length);let p=0;for(let l=0;l<c.length;l+=3){const e=s["a"].fromArray(c,l,z),t=i.cartesianToCartographic(e,D);if(!Object(f["a"])(t))throw new b["a"](`Could not project point (${e.x}, ${e.y}, ${e.z}) to 2D.`);const n=r.project(t,z);u[p++]=n.x,u[p++]=n.y,u[p++]=n.z}return e.attributes[n]=o,e.attributes[a]=new h["a"]({componentDatatype:l["a"].DOUBLE,componentsPerAttribute:3,values:u}),delete e.attributes[t],e};const q={high:0,low:0};N.encodeAttribute=function(e,t,n,a){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");if(!Object(f["a"])(t))throw new b["a"]("attributeName is required.");if(!Object(f["a"])(n))throw new b["a"]("attributeHighName is required.");if(!Object(f["a"])(a))throw new b["a"]("attributeLowName is required.");if(!Object(f["a"])(e.attributes[t]))throw new b["a"](`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==l["a"].DOUBLE)throw new b["a"]("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const r=e.attributes[t],o=r.values,i=o.length,s=new Float32Array(i),c=new Float32Array(i);for(let l=0;l<i;++l)m["a"].encode(o[l],q),s[l]=q.high,c[l]=q.low;const u=r.componentsPerAttribute;return e.attributes[n]=new h["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:u,values:s}),e.attributes[a]=new h["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:u,values:c}),delete e.attributes[t],e};let R=new s["a"];function B(e,t){if(Object(f["a"])(t)){const n=t.values,a=n.length;for(let t=0;t<a;t+=3)s["a"].unpack(n,t,R),T["a"].multiplyByPoint(e,R,R),s["a"].pack(R,n,t)}}function C(e,t){if(Object(f["a"])(t)){const n=t.values,a=n.length;for(let t=0;t<a;t+=3)s["a"].unpack(n,t,R),j["a"].multiplyByVector(e,R,R),R=s["a"].normalize(R,R),s["a"].pack(R,n,t)}}const V=new T["a"],G=new j["a"];function U(e,t){const n=e.length,a={},r=e[0][t].attributes;let o;for(o in r)if(r.hasOwnProperty(o)&&Object(f["a"])(r[o])&&Object(f["a"])(r[o].values)){const i=r[o];let s=i.values.length,c=!0;for(let a=1;a<n;++a){const n=e[a][t].attributes[o];if(!Object(f["a"])(n)||i.componentDatatype!==n.componentDatatype||i.componentsPerAttribute!==n.componentsPerAttribute||i.normalize!==n.normalize){c=!1;break}s+=n.values.length}c&&(a[o]=new h["a"]({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:l["a"].createTypedArray(i.componentDatatype,s)}))}return a}N.transformToWorldCoordinates=function(e){if(!Object(f["a"])(e))throw new b["a"]("instance is required.");const t=e.modelMatrix;if(T["a"].equals(t,T["a"].IDENTITY))return e;const n=e.geometry.attributes;B(t,n.position),B(t,n.prevPosition),B(t,n.nextPosition),(Object(f["a"])(n.normal)||Object(f["a"])(n.tangent)||Object(f["a"])(n.bitangent))&&(T["a"].inverse(t,V),T["a"].transpose(V,V),T["a"].getMatrix3(V,G),C(G,n.normal),C(G,n.tangent),C(G,n.bitangent));const a=e.geometry.boundingSphere;return Object(f["a"])(a)&&(e.geometry.boundingSphere=o["a"].transform(a,t,a)),e.modelMatrix=T["a"].clone(T["a"].IDENTITY),e};const M=new s["a"];function Y(e,t){const n=e.length;let a,r,i,c;const u=e[0].modelMatrix,l=Object(f["a"])(e[0][t].indices),p=e[0][t].primitiveType;for(r=1;r<n;++r){if(!T["a"].equals(e[r].modelMatrix,u))throw new b["a"]("All instances must have the same modelMatrix.");if(Object(f["a"])(e[r][t].indices)!==l)throw new b["a"]("All instance geometries must have an indices or not have one.");if(e[r][t].primitiveType!==p)throw new b["a"]("All instance geometries must have the same primitiveType.")}const m=U(e,t);let y,h,g,O;for(a in m)if(m.hasOwnProperty(a))for(y=m[a].values,c=0,r=0;r<n;++r)for(h=e[r][t].attributes[a].values,g=h.length,i=0;i<g;++i)y[c++]=h[i];if(l){let a=0;for(r=0;r<n;++r)a+=e[r][t].indices.length;const o=d["a"].computeNumberOfVertices(new d["a"]({attributes:m,primitiveType:P["a"].POINTS})),i=w["a"].createTypedArray(o,a);let s=0,u=0;for(r=0;r<n;++r){const n=e[r][t].indices,a=n.length;for(c=0;c<a;++c)i[s++]=u+n[c];u+=d["a"].computeNumberOfVertices(e[r][t])}O=i}let v,A=new s["a"],j=0;for(r=0;r<n;++r){if(v=e[r][t].boundingSphere,!Object(f["a"])(v)){A=void 0;break}s["a"].add(v.center,A,A)}if(Object(f["a"])(A))for(s["a"].divideByScalar(A,n,A),r=0;r<n;++r){v=e[r][t].boundingSphere;const n=s["a"].magnitude(s["a"].subtract(v.center,A,M))+v.radius;n>j&&(j=n)}return new d["a"]({attributes:m,indices:O,primitiveType:p,boundingSphere:Object(f["a"])(A)?new o["a"](A,j):void 0})}N.combineInstances=function(e){if(!Object(f["a"])(e)||e.length<1)throw new b["a"]("instances is required and must have length greater than zero.");const t=[],n=[],a=e.length;for(let o=0;o<a;++o){const a=e[o];Object(f["a"])(a.geometry)?t.push(a):Object(f["a"])(a.westHemisphereGeometry)&&Object(f["a"])(a.eastHemisphereGeometry)&&n.push(a)}const r=[];return t.length>0&&r.push(Y(t,"geometry")),n.length>0&&(r.push(Y(n,"westHemisphereGeometry")),r.push(Y(n,"eastHemisphereGeometry"))),r};const W=new s["a"],X=new s["a"],Z=new s["a"],H=new s["a"];N.computeNormal=function(e){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");if(!Object(f["a"])(e.attributes.position)||!Object(f["a"])(e.attributes.position.values))throw new b["a"]("geometry.attributes.position.values is required.");if(!Object(f["a"])(e.indices))throw new b["a"]("geometry.indices is required.");if(e.indices.length<2||e.indices.length%3!==0)throw new b["a"]("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==P["a"].TRIANGLES)throw new b["a"]("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const t=e.indices,n=e.attributes,a=n.position.values,r=n.position.values.length/3,o=t.length,i=new Array(r),c=new Array(o/3),u=new Array(o);let p;for(p=0;p<r;p++)i[p]={indexOffset:0,count:0,currentCount:0};let m=0;for(p=0;p<o;p+=3){const e=t[p],n=t[p+1],r=t[p+2],o=3*e,u=3*n,l=3*r;X.x=a[o],X.y=a[o+1],X.z=a[o+2],Z.x=a[u],Z.y=a[u+1],Z.z=a[u+2],H.x=a[l],H.y=a[l+1],H.z=a[l+2],i[e].count++,i[n].count++,i[r].count++,s["a"].subtract(Z,X,Z),s["a"].subtract(H,X,H),c[m]=s["a"].cross(Z,H,new s["a"]),m++}let y,d=0;for(p=0;p<r;p++)i[p].indexOffset+=d,d+=i[p].count;for(m=0,p=0;p<o;p+=3){y=i[t[p]];let e=y.indexOffset+y.currentCount;u[e]=m,y.currentCount++,y=i[t[p+1]],e=y.indexOffset+y.currentCount,u[e]=m,y.currentCount++,y=i[t[p+2]],e=y.indexOffset+y.currentCount,u[e]=m,y.currentCount++,m++}const g=new Float32Array(3*r);for(p=0;p<r;p++){const e=3*p;if(y=i[p],s["a"].clone(s["a"].ZERO,W),y.count>0){for(m=0;m<y.count;m++)s["a"].add(W,c[u[y.indexOffset+m]],W);s["a"].equalsEpsilon(s["a"].ZERO,W,A["a"].EPSILON10)&&s["a"].clone(c[u[y.indexOffset]],W)}s["a"].equalsEpsilon(s["a"].ZERO,W,A["a"].EPSILON10)&&(W.z=1),s["a"].normalize(W,W),g[e]=W.x,g[e+1]=W.y,g[e+2]=W.z}return e.attributes.normal=new h["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:3,values:g}),e};const J=new s["a"],$=new s["a"],Q=new s["a"];N.computeTangentAndBitangent=function(e){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");const t=e.attributes,n=e.indices;if(!Object(f["a"])(t.position)||!Object(f["a"])(t.position.values))throw new b["a"]("geometry.attributes.position.values is required.");if(!Object(f["a"])(t.normal)||!Object(f["a"])(t.normal.values))throw new b["a"]("geometry.attributes.normal.values is required.");if(!Object(f["a"])(t.st)||!Object(f["a"])(t.st.values))throw new b["a"]("geometry.attributes.st.values is required.");if(!Object(f["a"])(n))throw new b["a"]("geometry.indices is required.");if(n.length<2||n.length%3!==0)throw new b["a"]("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==P["a"].TRIANGLES)throw new b["a"]("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const a=e.attributes.position.values,r=e.attributes.normal.values,o=e.attributes.st.values,i=e.attributes.position.values.length/3,c=n.length,u=new Array(3*i);let p,m,y,d;for(p=0;p<u.length;p++)u[p]=0;for(p=0;p<c;p+=3){const e=n[p],t=n[p+1],r=n[p+2];m=3*e,y=3*t,d=3*r;const i=2*e,s=2*t,c=2*r,l=a[m],f=a[m+1],b=a[m+2],h=o[i],g=o[i+1],w=o[s+1]-g,O=o[c+1]-g,v=1/((o[s]-h)*O-(o[c]-h)*w),A=(O*(a[y]-l)-w*(a[d]-l))*v,j=(O*(a[y+1]-f)-w*(a[d+1]-f))*v,T=(O*(a[y+2]-b)-w*(a[d+2]-b))*v;u[m]+=A,u[m+1]+=j,u[m+2]+=T,u[y]+=A,u[y+1]+=j,u[y+2]+=T,u[d]+=A,u[d+1]+=j,u[d+2]+=T}const g=new Float32Array(3*i),w=new Float32Array(3*i);for(p=0;p<i;p++){m=3*p,y=m+1,d=m+2;const e=s["a"].fromArray(r,m,J),t=s["a"].fromArray(u,m,Q),n=s["a"].dot(e,t);s["a"].multiplyByScalar(e,n,$),s["a"].normalize(s["a"].subtract(t,$,t),t),g[m]=t.x,g[y]=t.y,g[d]=t.z,s["a"].normalize(s["a"].cross(e,t,t),t),w[m]=t.x,w[y]=t.y,w[d]=t.z}return e.attributes.tangent=new h["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:3,values:g}),e.attributes.bitangent=new h["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:3,values:w}),e};const K=new i["a"],ee=new s["a"],te=new s["a"],ne=new s["a"];let ae=new i["a"];function re(e){if(Object(f["a"])(e.indices))return e;const t=d["a"].computeNumberOfVertices(e);if(t<3)throw new b["a"]("The number of vertices must be at least three.");if(t%3!==0)throw new b["a"]("The number of vertices must be a multiple of three.");const n=w["a"].createTypedArray(t,t);for(let a=0;a<t;++a)n[a]=a;return e.indices=n,e}function oe(e){const t=d["a"].computeNumberOfVertices(e);if(t<3)throw new b["a"]("The number of vertices must be at least three.");const n=w["a"].createTypedArray(t,3*(t-2));n[0]=1,n[1]=0,n[2]=2;let a=3;for(let r=3;r<t;++r)n[a++]=r-1,n[a++]=0,n[a++]=r;return e.indices=n,e.primitiveType=P["a"].TRIANGLES,e}function ie(e){const t=d["a"].computeNumberOfVertices(e);if(t<3)throw new b["a"]("The number of vertices must be at least 3.");const n=w["a"].createTypedArray(t,3*(t-2));n[0]=0,n[1]=1,n[2]=2,t>3&&(n[3]=0,n[4]=2,n[5]=3);let a=6;for(let r=3;r<t-1;r+=2)n[a++]=r,n[a++]=r-1,n[a++]=r+1,r+2<t&&(n[a++]=r,n[a++]=r+1,n[a++]=r+2);return e.indices=n,e.primitiveType=P["a"].TRIANGLES,e}function se(e){if(Object(f["a"])(e.indices))return e;const t=d["a"].computeNumberOfVertices(e);if(t<2)throw new b["a"]("The number of vertices must be at least two.");if(t%2!==0)throw new b["a"]("The number of vertices must be a multiple of 2.");const n=w["a"].createTypedArray(t,t);for(let a=0;a<t;++a)n[a]=a;return e.indices=n,e}function ce(e){const t=d["a"].computeNumberOfVertices(e);if(t<2)throw new b["a"]("The number of vertices must be at least two.");const n=w["a"].createTypedArray(t,2*(t-1));n[0]=0,n[1]=1;let a=2;for(let r=2;r<t;++r)n[a++]=r-1,n[a++]=r;return e.indices=n,e.primitiveType=P["a"].LINES,e}function ue(e){const t=d["a"].computeNumberOfVertices(e);if(t<2)throw new b["a"]("The number of vertices must be at least two.");const n=w["a"].createTypedArray(t,2*t);n[0]=0,n[1]=1;let a=2;for(let r=2;r<t;++r)n[a++]=r-1,n[a++]=r;return n[a++]=t-1,n[a]=0,e.indices=n,e.primitiveType=P["a"].LINES,e}function le(e){switch(e.primitiveType){case P["a"].TRIANGLE_FAN:return oe(e);case P["a"].TRIANGLE_STRIP:return ie(e);case P["a"].TRIANGLES:return re(e);case P["a"].LINE_STRIP:return ce(e);case P["a"].LINE_LOOP:return ue(e);case P["a"].LINES:return se(e)}return e}function pe(e,t){Math.abs(e.y)<A["a"].EPSILON6&&(e.y=t?-A["a"].EPSILON6:A["a"].EPSILON6)}function fe(e,t,n){if(0!==e.y&&0!==t.y&&0!==n.y)return pe(e,e.y<0),pe(t,t.y<0),void pe(n,n.y<0);const a=Math.abs(e.y),r=Math.abs(t.y),o=Math.abs(n.y);let i;i=a>r?a>o?A["a"].sign(e.y):A["a"].sign(n.y):r>o?A["a"].sign(t.y):A["a"].sign(n.y);const s=i<0;pe(e,s),pe(t,s),pe(n,s)}N.compressVertices=function(e){if(!Object(f["a"])(e))throw new b["a"]("geometry is required.");const t=e.attributes.extrudeDirection;let n,r;if(Object(f["a"])(t)){const o=t.values;r=o.length/3;const i=new Float32Array(2*r);let c=0;for(n=0;n<r;++n)s["a"].fromArray(o,3*n,ee),s["a"].equals(ee,s["a"].ZERO)?c+=2:(ae=a["a"].octEncodeInRange(ee,65535,ae),i[c++]=ae.x,i[c++]=ae.y);return e.attributes.compressedAttributes=new h["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:2,values:i}),delete e.attributes.extrudeDirection,e}const o=e.attributes.normal,c=e.attributes.st,u=Object(f["a"])(o),p=Object(f["a"])(c);if(!u&&!p)return e;const m=e.attributes.tangent,y=e.attributes.bitangent,d=Object(f["a"])(m),g=Object(f["a"])(y);let w,O,v,A;u&&(w=o.values),p&&(O=c.values),d&&(v=m.values),g&&(A=y.values);const j=u?w.length:O.length,T=u?3:2;r=j/T;let x=r,P=p&&u?2:1;P+=d||g?1:0,x*=P;const E=new Float32Array(x);let N=0;for(n=0;n<r;++n){p&&(i["a"].fromArray(O,2*n,K),E[N++]=a["a"].compressTextureCoordinates(K));const e=3*n;u&&Object(f["a"])(v)&&Object(f["a"])(A)?(s["a"].fromArray(w,e,ee),s["a"].fromArray(v,e,te),s["a"].fromArray(A,e,ne),a["a"].octPack(ee,te,ne,K),E[N++]=K.x,E[N++]=K.y):(u&&(s["a"].fromArray(w,e,ee),E[N++]=a["a"].octEncodeFloat(ee)),d&&(s["a"].fromArray(v,e,ee),E[N++]=a["a"].octEncodeFloat(ee)),g&&(s["a"].fromArray(A,e,ee),E[N++]=a["a"].octEncodeFloat(ee)))}return e.attributes.compressedAttributes=new h["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:P,values:E}),u&&delete e.attributes.normal,p&&delete e.attributes.st,g&&delete e.attributes.bitangent,d&&delete e.attributes.tangent,e};const be=new s["a"];function me(e,t,n,a){s["a"].add(e,s["a"].multiplyByScalar(s["a"].subtract(t,e,be),e.y/(e.y-t.y),be),n),s["a"].clone(n,a),pe(n,!0),pe(a,!1)}const ye=new s["a"],de=new s["a"],he=new s["a"],ge=new s["a"],we={positions:new Array(7),indices:new Array(9)};function Oe(e,t,n){if(e.x>=0||t.x>=0||n.x>=0)return;fe(e,t,n);const a=e.y<0,r=t.y<0,o=n.y<0;let i=0;i+=a?1:0,i+=r?1:0,i+=o?1:0;const s=we.indices;1===i?(s[1]=3,s[2]=4,s[5]=6,s[7]=6,s[8]=5,a?(me(e,t,ye,he),me(e,n,de,ge),s[0]=0,s[3]=1,s[4]=2,s[6]=1):r?(me(t,n,ye,he),me(t,e,de,ge),s[0]=1,s[3]=2,s[4]=0,s[6]=2):o&&(me(n,e,ye,he),me(n,t,de,ge),s[0]=2,s[3]=0,s[4]=1,s[6]=0)):2===i&&(s[2]=4,s[4]=4,s[5]=3,s[7]=5,s[8]=6,a?r?o||(me(n,e,ye,he),me(n,t,de,ge),s[0]=0,s[1]=1,s[3]=0,s[6]=2):(me(t,n,ye,he),me(t,e,de,ge),s[0]=2,s[1]=0,s[3]=2,s[6]=1):(me(e,t,ye,he),me(e,n,de,ge),s[0]=1,s[1]=2,s[3]=1,s[6]=0));const c=we.positions;return c[0]=e,c[1]=t,c[2]=n,c.length=3,1!==i&&2!==i||(c[3]=ye,c[4]=de,c[5]=he,c[6]=ge,c.length=7),we}function ve(e,t){const n=e.attributes;if(0===n.position.values.length)return;for(const r in n)if(n.hasOwnProperty(r)&&Object(f["a"])(n[r])&&Object(f["a"])(n[r].values)){const e=n[r];e.values=l["a"].createTypedArray(e.componentDatatype,e.values)}const a=d["a"].computeNumberOfVertices(e);return e.indices=w["a"].createTypedArray(a,e.indices),t&&(e.boundingSphere=o["a"].fromVertices(n.position.values)),e}function Ae(e){const t=e.attributes,n={};for(const a in t)if(t.hasOwnProperty(a)&&Object(f["a"])(t[a])&&Object(f["a"])(t[a].values)){const e=t[a];n[a]=new h["a"]({componentDatatype:e.componentDatatype,componentsPerAttribute:e.componentsPerAttribute,normalize:e.normalize,values:[]})}return new d["a"]({attributes:n,indices:[],primitiveType:e.primitiveType})}function je(e,t,n){const a=Object(f["a"])(e.geometry.boundingSphere);t=ve(t,a),n=ve(n,a),Object(f["a"])(n)&&!Object(f["a"])(t)?e.geometry=n:!Object(f["a"])(n)&&Object(f["a"])(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=n,e.geometry=void 0)}function Te(e,t){const n=new e,a=new e,r=new e;return function(o,i,s,c,u,l,p,f){const b=e.fromArray(u,o*t,n),m=e.fromArray(u,i*t,a),y=e.fromArray(u,s*t,r);e.multiplyByScalar(b,c.x,b),e.multiplyByScalar(m,c.y,m),e.multiplyByScalar(y,c.z,y);const d=e.add(b,m,b);e.add(d,y,d),f&&e.normalize(d,d),e.pack(d,l,p*t)}}const xe=Te(c["a"],4),Pe=Te(s["a"],3),Ee=Te(i["a"],2),Ne=function(e,t,n,a,r,o,i){const s=r[e]*a.x,c=r[t]*a.y,u=r[n]*a.z;o[i]=s+c+u>A["a"].EPSILON6?1:0},Le=new s["a"],_e=new s["a"],Ie=new s["a"],Se=new s["a"];function Fe(e,t,n,a,o,i,c,u,l,p,b,m,y,d,h,g){if(!Object(f["a"])(i)&&!Object(f["a"])(c)&&!Object(f["a"])(u)&&!Object(f["a"])(l)&&!Object(f["a"])(p)&&0===d)return;const w=s["a"].fromArray(o,3*e,Le),O=s["a"].fromArray(o,3*t,_e),v=s["a"].fromArray(o,3*n,Ie),A=Object(r["a"])(a,w,O,v,Se);if(Object(f["a"])(A)){if(Object(f["a"])(i)&&Pe(e,t,n,A,i,m.normal.values,g,!0),Object(f["a"])(p)){const a=s["a"].fromArray(p,3*e,Le),r=s["a"].fromArray(p,3*t,_e),o=s["a"].fromArray(p,3*n,Ie);let i;s["a"].multiplyByScalar(a,A.x,a),s["a"].multiplyByScalar(r,A.y,r),s["a"].multiplyByScalar(o,A.z,o),s["a"].equals(a,s["a"].ZERO)&&s["a"].equals(r,s["a"].ZERO)&&s["a"].equals(o,s["a"].ZERO)?(i=Le,i.x=0,i.y=0,i.z=0):(i=s["a"].add(a,r,a),s["a"].add(i,o,i),s["a"].normalize(i,i)),s["a"].pack(i,m.extrudeDirection.values,3*g)}if(Object(f["a"])(b)&&Ne(e,t,n,A,b,m.applyOffset.values,g),Object(f["a"])(c)&&Pe(e,t,n,A,c,m.tangent.values,g,!0),Object(f["a"])(u)&&Pe(e,t,n,A,u,m.bitangent.values,g,!0),Object(f["a"])(l)&&Ee(e,t,n,A,l,m.st.values,g),d>0)for(let a=0;a<d;a++){const r=y[a];ke(e,t,n,A,g,h[r],m[r])}}}function ke(e,t,n,a,r,o,i){const s=o.componentsPerAttribute,c=o.values,u=i.values;switch(s){case 4:xe(e,t,n,a,c,u,r,!1);break;case 3:Pe(e,t,n,a,c,u,r,!1);break;case 2:Ee(e,t,n,a,c,u,r,!1);break;default:u[r]=c[e]*a.x+c[t]*a.y+c[n]*a.z}}function ze(e,t,n,a,r,o){const i=e.position.values.length/3;if(-1!==r){const s=a[r],c=n[s];return-1===c?(n[s]=i,e.position.values.push(o.x,o.y,o.z),t.push(i),i):(t.push(c),c)}return e.position.values.push(o.x,o.y,o.z),t.push(i),i}const De={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function qe(e){const t=e.geometry,n=t.attributes,a=n.position.values,r=Object(f["a"])(n.normal)?n.normal.values:void 0,o=Object(f["a"])(n.bitangent)?n.bitangent.values:void 0,i=Object(f["a"])(n.tangent)?n.tangent.values:void 0,c=Object(f["a"])(n.st)?n.st.values:void 0,u=Object(f["a"])(n.extrudeDirection)?n.extrudeDirection.values:void 0,l=Object(f["a"])(n.applyOffset)?n.applyOffset.values:void 0,p=t.indices,b=[];for(const s in n)n.hasOwnProperty(s)&&!De[s]&&Object(f["a"])(n[s])&&b.push(s);const m=b.length,y=Ae(t),d=Ae(t);let h,g,w,O,v;const A=[];A.length=a.length/3;const j=[];for(j.length=a.length/3,v=0;v<A.length;++v)A[v]=-1,j[v]=-1;const T=p.length;for(v=0;v<T;v+=3){const e=p[v],t=p[v+1],T=p[v+2];let x=s["a"].fromArray(a,3*e),P=s["a"].fromArray(a,3*t),E=s["a"].fromArray(a,3*T);const N=Oe(x,P,E);if(Object(f["a"])(N)&&N.positions.length>3){const s=N.positions,f=N.indices,x=f.length;for(let P=0;P<x;++P){const x=f[P],E=s[x];E.y<0?(h=d.attributes,g=d.indices,w=A):(h=y.attributes,g=y.indices,w=j),O=ze(h,g,w,p,x<3?v+x:-1,E),Fe(e,t,T,E,a,r,i,o,c,u,l,h,b,m,n,O)}}else Object(f["a"])(N)&&(x=N.positions[0],P=N.positions[1],E=N.positions[2]),x.y<0?(h=d.attributes,g=d.indices,w=A):(h=y.attributes,g=y.indices,w=j),O=ze(h,g,w,p,v,x),Fe(e,t,T,x,a,r,i,o,c,u,l,h,b,m,n,O),O=ze(h,g,w,p,v+1,P),Fe(e,t,T,P,a,r,i,o,c,u,l,h,b,m,n,O),O=ze(h,g,w,p,v+2,E),Fe(e,t,T,E,a,r,i,o,c,u,l,h,b,m,n,O)}je(e,d,y)}const Re=x["a"].fromPointNormal(s["a"].ZERO,s["a"].UNIT_Y),Be=new s["a"],Ce=new s["a"];function Ve(e,t,n,a,r,o,i){if(!Object(f["a"])(i))return;const c=s["a"].fromArray(a,3*e,Le);s["a"].equalsEpsilon(c,n,A["a"].EPSILON10)?o.applyOffset.values[r]=i[e]:o.applyOffset.values[r]=i[t]}function Ge(e){const t=e.geometry,n=t.attributes,a=n.position.values,r=Object(f["a"])(n.applyOffset)?n.applyOffset.values:void 0,o=t.indices,i=Ae(t),c=Ae(t);let u;const l=o.length,p=[];p.length=a.length/3;const b=[];for(b.length=a.length/3,u=0;u<p.length;++u)p[u]=-1,b[u]=-1;for(u=0;u<l;u+=2){const e=o[u],t=o[u+1],n=s["a"].fromArray(a,3*e,Le),l=s["a"].fromArray(a,3*t,_e);let m;Math.abs(n.y)<A["a"].EPSILON6&&(n.y<0?n.y=-A["a"].EPSILON6:n.y=A["a"].EPSILON6),Math.abs(l.y)<A["a"].EPSILON6&&(l.y<0?l.y=-A["a"].EPSILON6:l.y=A["a"].EPSILON6);let y=i.attributes,d=i.indices,h=b,g=c.attributes,w=c.indices,O=p;const j=v["a"].lineSegmentPlane(n,l,Re,Ie);if(Object(f["a"])(j)){const f=s["a"].multiplyByScalar(s["a"].UNIT_Y,5*A["a"].EPSILON9,Be);n.y<0&&(s["a"].negate(f,f),y=c.attributes,d=c.indices,h=p,g=i.attributes,w=i.indices,O=b);const v=s["a"].add(j,f,Ce);m=ze(y,d,h,o,u,n),Ve(e,t,n,a,m,y,r),m=ze(y,d,h,o,-1,v),Ve(e,t,v,a,m,y,r),s["a"].negate(f,f),s["a"].add(j,f,v),m=ze(g,w,O,o,-1,v),Ve(e,t,v,a,m,g,r),m=ze(g,w,O,o,u+1,l),Ve(e,t,l,a,m,g,r)}else{let s,f,y;n.y<0?(s=c.attributes,f=c.indices,y=p):(s=i.attributes,f=i.indices,y=b),m=ze(s,f,y,o,u,n),Ve(e,t,n,a,m,s,r),m=ze(s,f,y,o,u+1,l),Ve(e,t,l,a,m,s,r)}}je(e,c,i)}const Ue=new i["a"],Me=new i["a"],Ye=new s["a"],We=new s["a"],Xe=new s["a"],Ze=new s["a"],He=new s["a"],Je=new s["a"],$e=new c["a"];function Qe(e){const t=e.attributes,n=t.position.values,a=t.prevPosition.values,r=t.nextPosition.values,o=n.length;for(let i=0;i<o;i+=3){const e=s["a"].unpack(n,i,Ye);if(e.x>0)continue;const t=s["a"].unpack(a,i,We);(e.y<0&&t.y>0||e.y>0&&t.y<0)&&(i-3>0?(a[i]=n[i-3],a[i+1]=n[i-2],a[i+2]=n[i-1]):s["a"].pack(e,a,i));const c=s["a"].unpack(r,i,Xe);(e.y<0&&c.y>0||e.y>0&&c.y<0)&&(i+3<o?(r[i]=n[i+3],r[i+1]=n[i+4],r[i+2]=n[i+5]):s["a"].pack(e,r,i))}}const Ke=5*A["a"].EPSILON9,et=A["a"].EPSILON6;function tt(e){const t=e.geometry,n=t.attributes,a=n.position.values,r=n.prevPosition.values,o=n.nextPosition.values,u=n.expandAndWidth.values,l=Object(f["a"])(n.st)?n.st.values:void 0,p=Object(f["a"])(n.color)?n.color.values:void 0,b=Ae(t),m=Ae(t);let y,d,h,g=!1;const w=a.length/3;for(y=0;y<w;y+=4){const e=y,t=y+2,n=s["a"].fromArray(a,3*e,Ye),w=s["a"].fromArray(a,3*t,We);if(Math.abs(n.y)<et)for(n.y=et*(w.y<0?-1:1),a[3*y+1]=n.y,a[3*(y+1)+1]=n.y,d=3*e;d<3*e+12;d+=3)r[d]=a[3*y],r[d+1]=a[3*y+1],r[d+2]=a[3*y+2];if(Math.abs(w.y)<et)for(w.y=et*(n.y<0?-1:1),a[3*(y+2)+1]=w.y,a[3*(y+3)+1]=w.y,d=3*e;d<3*e+12;d+=3)o[d]=a[3*(y+2)],o[d+1]=a[3*(y+2)+1],o[d+2]=a[3*(y+2)+2];let O=b.attributes,j=b.indices,T=m.attributes,x=m.indices;const P=v["a"].lineSegmentPlane(n,w,Re,Ze);if(Object(f["a"])(P)){g=!0;const a=s["a"].multiplyByScalar(s["a"].UNIT_Y,Ke,He);n.y<0&&(s["a"].negate(a,a),O=m.attributes,j=m.indices,T=b.attributes,x=b.indices);const v=s["a"].add(P,a,Je);O.position.values.push(n.x,n.y,n.z,n.x,n.y,n.z),O.position.values.push(v.x,v.y,v.z),O.position.values.push(v.x,v.y,v.z),O.prevPosition.values.push(r[3*e],r[3*e+1],r[3*e+2]),O.prevPosition.values.push(r[3*e+3],r[3*e+4],r[3*e+5]),O.prevPosition.values.push(n.x,n.y,n.z,n.x,n.y,n.z),O.nextPosition.values.push(v.x,v.y,v.z),O.nextPosition.values.push(v.x,v.y,v.z),O.nextPosition.values.push(v.x,v.y,v.z),O.nextPosition.values.push(v.x,v.y,v.z),s["a"].negate(a,a),s["a"].add(P,a,v),T.position.values.push(v.x,v.y,v.z),T.position.values.push(v.x,v.y,v.z),T.position.values.push(w.x,w.y,w.z,w.x,w.y,w.z),T.prevPosition.values.push(v.x,v.y,v.z),T.prevPosition.values.push(v.x,v.y,v.z),T.prevPosition.values.push(v.x,v.y,v.z),T.prevPosition.values.push(v.x,v.y,v.z),T.nextPosition.values.push(w.x,w.y,w.z,w.x,w.y,w.z),T.nextPosition.values.push(o[3*t],o[3*t+1],o[3*t+2]),T.nextPosition.values.push(o[3*t+3],o[3*t+4],o[3*t+5]);const E=i["a"].fromArray(u,2*e,Ue),N=Math.abs(E.y);O.expandAndWidth.values.push(-1,N,1,N),O.expandAndWidth.values.push(-1,-N,1,-N),T.expandAndWidth.values.push(-1,N,1,N),T.expandAndWidth.values.push(-1,-N,1,-N);let L=s["a"].magnitudeSquared(s["a"].subtract(P,n,Xe));if(L/=s["a"].magnitudeSquared(s["a"].subtract(w,n,Xe)),Object(f["a"])(p)){const n=c["a"].fromArray(p,4*e,$e),a=c["a"].fromArray(p,4*t,$e),r=A["a"].lerp(n.x,a.x,L),o=A["a"].lerp(n.y,a.y,L),i=A["a"].lerp(n.z,a.z,L),s=A["a"].lerp(n.w,a.w,L);for(d=4*e;d<4*e+8;++d)O.color.values.push(p[d]);for(O.color.values.push(r,o,i,s),O.color.values.push(r,o,i,s),T.color.values.push(r,o,i,s),T.color.values.push(r,o,i,s),d=4*t;d<4*t+8;++d)T.color.values.push(p[d])}if(Object(f["a"])(l)){const n=i["a"].fromArray(l,2*e,Ue),a=i["a"].fromArray(l,2*(y+3),Me),r=A["a"].lerp(n.x,a.x,L);for(d=2*e;d<2*e+4;++d)O.st.values.push(l[d]);for(O.st.values.push(r,n.y),O.st.values.push(r,a.y),T.st.values.push(r,n.y),T.st.values.push(r,a.y),d=2*t;d<2*t+4;++d)T.st.values.push(l[d])}h=O.position.values.length/3-4,j.push(h,h+2,h+1),j.push(h+1,h+2,h+3),h=T.position.values.length/3-4,x.push(h,h+2,h+1),x.push(h+1,h+2,h+3)}else{let e,t;for(n.y<0?(e=m.attributes,t=m.indices):(e=b.attributes,t=b.indices),e.position.values.push(n.x,n.y,n.z),e.position.values.push(n.x,n.y,n.z),e.position.values.push(w.x,w.y,w.z),e.position.values.push(w.x,w.y,w.z),d=3*y;d<3*y+12;++d)e.prevPosition.values.push(r[d]),e.nextPosition.values.push(o[d]);for(d=2*y;d<2*y+8;++d)e.expandAndWidth.values.push(u[d]),Object(f["a"])(l)&&e.st.values.push(l[d]);if(Object(f["a"])(p))for(d=4*y;d<4*y+16;++d)e.color.values.push(p[d]);h=e.position.values.length/3-4,t.push(h,h+2,h+1),t.push(h+1,h+2,h+3)}}g&&(Qe(m),Qe(b)),je(e,m,b)}N.splitLongitude=function(e){if(!Object(f["a"])(e))throw new b["a"]("instance is required.");const t=e.geometry,n=t.boundingSphere;if(Object(f["a"])(n)){const t=n.center.x-n.radius;if(t>0||o["a"].intersectPlane(n,x["a"].ORIGIN_ZX_PLANE)!==O["a"].INTERSECTING)return e}if(t.geometryType!==g["a"].NONE)switch(t.geometryType){case g["a"].POLYLINES:tt(e);break;case g["a"].TRIANGLES:qe(e);break;case g["a"].LINES:Ge(e);break}else le(t),t.primitiveType===P["a"].TRIANGLES?qe(e):t.primitiveType===P["a"].LINES&&Ge(e);return e},t["a"]=N}}]);