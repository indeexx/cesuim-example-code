(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-vendors~8b3eb845"],{"20f8":function(e,t,a){"use strict";var i=a("cedf");const n={ZERO:i["a"].ZERO,KEEP:i["a"].KEEP,REPLACE:i["a"].REPLACE,INCREMENT:i["a"].INCR,DECREMENT:i["a"].DECR,INVERT:i["a"].INVERT,INCREMENT_WRAP:i["a"].INCR_WRAP,DECREMENT_WRAP:i["a"].DECR_WRAP};t["a"]=Object.freeze(n)},2323:function(e,t,a){"use strict";var i=a("ae9b"),n=a("1a5d"),s=a("c937");function o(e){e=Object(n["a"])(e,n["a"].EMPTY_OBJECT),i["a"].typeOf.object("options.schema",e.schema),this._schema=e.schema;const t=e.propertyTables;this._propertyTableCount=Object(s["a"])(t)?t.length:0,this._propertyTables=t,this._propertyTextures=e.propertyTextures,this._propertyAttributes=e.propertyAttributes,this._statistics=e.statistics,this._extras=e.extras,this._extensions=e.extensions}Object.defineProperties(o.prototype,{schema:{get:function(){return this._schema}},statistics:{get:function(){return this._statistics}},extras:{get:function(){return this._extras}},extensions:{get:function(){return this._extensions}},propertyTableCount:{get:function(){return this._propertyTableCount}},propertyTables:{get:function(){return this._propertyTables}},propertyTextures:{get:function(){return this._propertyTextures}},propertyAttributes:{get:function(){return this._propertyAttributes}}}),o.prototype.getPropertyTable=function(e){return i["a"].typeOf.number("propertyTableId",e),this._propertyTables[e]},o.prototype.getPropertyTexture=function(e){return i["a"].typeOf.number("propertyTextureId",e),this._propertyTextures[e]},o.prototype.getPropertyAttribute=function(e){return i["a"].typeOf.number("propertyAttributeId",e),this._propertyAttributes[e]},t["a"]=o},2773:function(e,t,a){"use strict";var i=a("85b2"),n=a("dde0"),s=a("8d54"),o=a("ae9b"),r=a("cbf0"),c=a("1a5d"),u=a("c937"),h=a("d809"),d=a("0161"),m=a("b8b5"),p=a("722e"),l=a("4a63"),f=a("6f7c"),_=a("b3ce"),w=a("1f21"),g=a("2df8");function C(e,t,a){o["a"].typeOf.bool("extentsCulling",e),o["a"].typeOf.bool("planarExtents",t),o["a"].typeOf.object("appearance",a),this._projectionExtentDefines={eastMostYhighDefine:"",eastMostYlowDefine:"",westMostYhighDefine:"",westMostYlowDefine:""};const i=new x;i.requiresTextureCoordinates=e,i.requiresEC=!a.flat;const n=new x;if(n.requiresTextureCoordinates=e,a instanceof w["a"])i.requiresNormalEC=!a.flat;else{const e=`${a.material.shaderSource}\n${a.fragmentShaderSource}`;i.normalEC=-1!==e.indexOf("materialInput.normalEC")||-1!==e.indexOf("czm_getDefaultMaterial"),i.positionToEyeEC=-1!==e.indexOf("materialInput.positionToEyeEC"),i.tangentToEyeMatrix=-1!==e.indexOf("materialInput.tangentToEyeMatrix"),i.st=-1!==e.indexOf("materialInput.st")}this._colorShaderDependencies=i,this._pickShaderDependencies=n,this._appearance=a,this._extentsCulling=e,this._planarExtents=t}C.prototype.createFragmentShader=function(e){o["a"].typeOf.bool("columbusView2D",e);const t=this._appearance,a=this._colorShaderDependencies,i=[];e||this._planarExtents||i.push("SPHERICAL"),a.requiresEC&&i.push("REQUIRES_EC"),a.requiresWC&&i.push("REQUIRES_WC"),a.requiresTextureCoordinates&&i.push("TEXTURE_COORDINATES"),this._extentsCulling&&i.push("CULL_FRAGMENTS"),a.requiresNormalEC&&i.push("NORMAL_EC"),t instanceof w["a"]&&i.push("PER_INSTANCE_COLOR"),a.normalEC&&i.push("USES_NORMAL_EC"),a.positionToEyeEC&&i.push("USES_POSITION_TO_EYE_EC"),a.tangentToEyeMatrix&&i.push("USES_TANGENT_TO_EYE"),a.st&&i.push("USES_ST"),t.flat&&i.push("FLAT");let n="";return t instanceof w["a"]||(n=t.material.shaderSource),new _["a"]({defines:i,sources:[n,g["a"]]})},C.prototype.createPickFragmentShader=function(e){o["a"].typeOf.bool("columbusView2D",e);const t=this._pickShaderDependencies,a=["PICK"];return e||this._planarExtents||a.push("SPHERICAL"),t.requiresEC&&a.push("REQUIRES_EC"),t.requiresWC&&a.push("REQUIRES_WC"),t.requiresTextureCoordinates&&a.push("TEXTURE_COORDINATES"),this._extentsCulling&&a.push("CULL_FRAGMENTS"),new _["a"]({defines:a,sources:[g["a"]],pickColorQualifier:"varying"})},C.prototype.createVertexShader=function(e,t,a,i){return o["a"].defined("defines",e),o["a"].typeOf.string("vertexShaderSource",t),o["a"].typeOf.bool("columbusView2D",a),o["a"].defined("mapProjection",i),E(this._colorShaderDependencies,this._planarExtents,a,e,t,this._appearance,i,this._projectionExtentDefines)},C.prototype.createPickVertexShader=function(e,t,a,i){return o["a"].defined("defines",e),o["a"].typeOf.string("vertexShaderSource",t),o["a"].typeOf.bool("columbusView2D",a),o["a"].defined("mapProjection",i),E(this._pickShaderDependencies,this._planarExtents,a,e,t,void 0,i,this._projectionExtentDefines)};const b=new n["a"],S=new s["a"],y={high:0,low:0};function E(e,t,a,i,n,s,o,r){const c=i.slice();if(""===r.eastMostYhighDefine){const e=S;e.longitude=m["a"].PI,e.latitude=0,e.height=0;const t=o.project(e,b);let a=h["a"].encode(t.x,y);r.eastMostYhighDefine="EAST_MOST_X_HIGH "+a.high.toFixed((""+a.high).length+1),r.eastMostYlowDefine="EAST_MOST_X_LOW "+a.low.toFixed((""+a.low).length+1);const i=S;i.longitude=-m["a"].PI,i.latitude=0,i.height=0;const n=o.project(i,b);a=h["a"].encode(n.x,y),r.westMostYhighDefine="WEST_MOST_X_HIGH "+a.high.toFixed((""+a.high).length+1),r.westMostYlowDefine="WEST_MOST_X_LOW "+a.low.toFixed((""+a.low).length+1)}return a&&(c.push(r.eastMostYhighDefine),c.push(r.eastMostYlowDefine),c.push(r.westMostYhighDefine),c.push(r.westMostYlowDefine)),Object(u["a"])(s)&&s instanceof w["a"]&&c.push("PER_INSTANCE_COLOR"),e.requiresTextureCoordinates&&(c.push("TEXTURE_COORDINATES"),t||a||c.push("SPHERICAL"),a&&c.push("COLUMBUS_VIEW_2D")),new _["a"]({defines:c,sources:[n]})}function x(){this._requiresEC=!1,this._requiresWC=!1,this._requiresNormalEC=!1,this._requiresTextureCoordinates=!1,this._usesNormalEC=!1,this._usesPositionToEyeEC=!1,this._usesTangentToEyeMat=!1,this._usesSt=!1}function O(e,t,a){return Math.abs((t.y-e.y)*a.x-(t.x-e.x)*a.y+t.x*e.y-t.y*e.x)/i["a"].distance(t,e)}Object.defineProperties(x.prototype,{requiresEC:{get:function(){return this._requiresEC},set:function(e){this._requiresEC=e||this._requiresEC}},requiresWC:{get:function(){return this._requiresWC},set:function(e){this._requiresWC=e||this._requiresWC,this.requiresEC=this._requiresWC}},requiresNormalEC:{get:function(){return this._requiresNormalEC},set:function(e){this._requiresNormalEC=e||this._requiresNormalEC,this.requiresEC=this._requiresNormalEC}},requiresTextureCoordinates:{get:function(){return this._requiresTextureCoordinates},set:function(e){this._requiresTextureCoordinates=e||this._requiresTextureCoordinates,this.requiresWC=this._requiresTextureCoordinates}},normalEC:{set:function(e){this.requiresNormalEC=e,this._usesNormalEC=e},get:function(){return this._usesNormalEC}},tangentToEyeMatrix:{set:function(e){this.requiresWC=e,this.requiresNormalEC=e,this._usesTangentToEyeMat=e},get:function(){return this._usesTangentToEyeMat}},positionToEyeEC:{set:function(e){this.requiresEC=e,this._usesPositionToEyeEC=e},get:function(){return this._usesPositionToEyeEC}},st:{set:function(e){this.requiresTextureCoordinates=e,this._usesSt=e},get:function(){return this._usesSt}}});const v=[new i["a"],new i["a"],new i["a"],new i["a"]];function M(e,t){const a=v,n=i["a"].unpack(t,0,a[0]),s=i["a"].unpack(t,2,a[1]),o=i["a"].unpack(t,4,a[2]);e.uMaxVmax=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:[s.x,s.y,o.x,o.y]});const c=1/O(n,s,o),u=1/O(n,o,s);e.uvMinAndExtents=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:[n.x,n.y,c,u]})}const A=new s["a"],P=new n["a"],T=new n["a"],D=new n["a"],L={high:0,low:0};function N(e,t,a){const i=A;i.height=0,i.longitude=e.west,i.latitude=e.south;const n=t.project(i,P);i.latitude=e.north;const s=t.project(i,T);i.longitude=e.east,i.latitude=e.south;const o=t.project(i,D),c=[0,0,0,0],u=[0,0,0,0];let m=h["a"].encode(n.x,L);c[0]=m.high,u[0]=m.low,m=h["a"].encode(n.y,L),c[1]=m.high,u[1]=m.low,m=h["a"].encode(s.y,L),c[2]=m.high,u[2]=m.low,m=h["a"].encode(o.x,L),c[3]=m.high,u[3]=m.low,a.planes2D_HIGH=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:c}),a.planes2D_LOW=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:u})}const F=new p["a"],R=new p["a"],z=new n["a"],I=new s["a"],j=[new s["a"],new s["a"],new s["a"],new s["a"],new s["a"],new s["a"],new s["a"],new s["a"]];function W(e,t,a,i,o,r){const c=l["a"].center(e,I);c.height=a;const u=s["a"].toCartesian(c,t,z),h=f["a"].eastNorthUpToFixedFrame(u,t,F),d=p["a"].inverse(h,R),m=e.west,_=e.east,w=e.north,g=e.south,C=j;C[0].latitude=g,C[0].longitude=m,C[1].latitude=w,C[1].longitude=m,C[2].latitude=w,C[2].longitude=_,C[3].latitude=g,C[3].longitude=_;const b=.5*(m+_),S=.5*(w+g);C[4].latitude=g,C[4].longitude=b,C[5].latitude=w,C[5].longitude=b,C[6].latitude=S,C[6].longitude=m,C[7].latitude=S,C[7].longitude=_;let y=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY,x=Number.POSITIVE_INFINITY,O=Number.NEGATIVE_INFINITY;for(let n=0;n<8;n++){C[n].height=a;const e=s["a"].toCartesian(C[n],t,z);p["a"].multiplyByPoint(d,e,e),e.z=0,y=Math.min(y,e.x),E=Math.max(E,e.x),x=Math.min(x,e.y),O=Math.max(O,e.y)}const v=i;v.x=y,v.y=x,v.z=0,p["a"].multiplyByPoint(h,v,v);const M=o;M.x=E,M.y=x,M.z=0,p["a"].multiplyByPoint(h,M,M),n["a"].subtract(M,v,o);const A=r;A.x=y,A.y=O,A.z=0,p["a"].multiplyByPoint(h,A,A),n["a"].subtract(A,v,r)}const V=new n["a"],U=new n["a"],B=new h["a"];C.getPlanarTextureCoordinateAttributes=function(e,t,a,i,s){o["a"].typeOf.object("boundingRectangle",e),o["a"].defined("textureCoordinateRotationPoints",t),o["a"].typeOf.object("ellipsoid",a),o["a"].typeOf.object("projection",i);const u=P,m=V,p=U;W(e,a,Object(c["a"])(s,0),u,m,p);const l={};M(l,t);const f=h["a"].fromCartesian(u,B);return l.southWest_HIGH=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,normalize:!1,value:n["a"].pack(f.high,[0,0,0])}),l.southWest_LOW=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,normalize:!1,value:n["a"].pack(f.low,[0,0,0])}),l.eastward=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,normalize:!1,value:n["a"].pack(m,[0,0,0])}),l.northward=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,normalize:!1,value:n["a"].pack(p,[0,0,0])}),N(e,i,l),l};const H=new n["a"];function Y(e,t,a,i){const n=A;n.latitude=e,n.longitude=t,n.height=0;const o=s["a"].toCartesian(n,a,H),r=Math.sqrt(o.x*o.x+o.y*o.y),c=m["a"].fastApproximateAtan2(r,o.z),u=m["a"].fastApproximateAtan2(o.x,o.y);return i.x=c,i.y=u,i}const k=new i["a"];function q(e){return Math.max(e.width,e.height)>C.MAX_WIDTH_FOR_PLANAR_EXTENTS}C.getSphericalExtentGeometryInstanceAttributes=function(e,t,a,i){o["a"].typeOf.object("boundingRectangle",e),o["a"].defined("textureCoordinateRotationPoints",t),o["a"].typeOf.object("ellipsoid",a),o["a"].typeOf.object("projection",i);const n=Y(e.south,e.west,a,k);let s=n.x,c=n.y;const u=Y(e.north,e.east,a,k);let h=u.x,p=u.y,l=0;c>p&&(l=m["a"].PI-c,c=-m["a"].PI,p+=l),s-=m["a"].EPSILON5,c-=m["a"].EPSILON5,h+=m["a"].EPSILON5,p+=m["a"].EPSILON5;const f=1/(p-c),_=1/(h-s),w={sphericalExtents:new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:[s,c,_,f]}),longitudeRotation:new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:1,normalize:!1,value:[l]})};return M(w,t),N(e,i,w),w},C.hasAttributesForTextureCoordinatePlanes=function(e){return Object(u["a"])(e.southWest_HIGH)&&Object(u["a"])(e.southWest_LOW)&&Object(u["a"])(e.northward)&&Object(u["a"])(e.eastward)&&Object(u["a"])(e.planes2D_HIGH)&&Object(u["a"])(e.planes2D_LOW)&&Object(u["a"])(e.uMaxVmax)&&Object(u["a"])(e.uvMinAndExtents)},C.hasAttributesForSphericalExtents=function(e){return Object(u["a"])(e.sphericalExtents)&&Object(u["a"])(e.longitudeRotation)&&Object(u["a"])(e.planes2D_HIGH)&&Object(u["a"])(e.planes2D_LOW)&&Object(u["a"])(e.uMaxVmax)&&Object(u["a"])(e.uvMinAndExtents)},C.shouldUseSphericalCoordinates=function(e){return o["a"].typeOf.object("rectangle",e),q(e)},C.MAX_WIDTH_FOR_PLANAR_EXTENTS=m["a"].toRadians(1),t["a"]=C},"2bc31":function(e,t,a){"use strict";var i=a("e2a6");function n(){}n.prototype.evaluate=function(e,t){i["a"].throwInstantiationError()},n.prototype.evaluateColor=function(e,t){i["a"].throwInstantiationError()},n.prototype.getShaderFunction=function(e,t,a,n){i["a"].throwInstantiationError()},n.prototype.getVariables=function(){i["a"].throwInstantiationError()}},"39ab":function(e,t,a){"use strict";var i=a("3736"),n=a("1a5d"),s=a("61ad"),o=a("c937"),r=a("e2a6"),c=a("f7b5"),u=a("2dd3"),h=a("4a63"),d=a("9f38"),m=a("e2aa"),p=a("3242"),l=a("e956");function f(e){if(e=Object(n["a"])(e,n["a"].EMPTY_OBJECT),!Object(o["a"])(e.url))throw new r["a"]("options.url is required.");this.defaultAlpha=void 0,this.defaultNightAlpha=void 0,this.defaultDayAlpha=void 0,this.defaultBrightness=void 0,this.defaultContrast=void 0,this.defaultHue=void 0,this.defaultSaturation=void 0,this.defaultGamma=void 0,this.defaultMinificationFilter=void 0,this.defaultMagnificationFilter=void 0;const t=d["a"].createIfNeeded(e.url),a=Object(n["a"])(e.rectangle,h["a"].MAX_VALUE),f=new u["a"]({rectangle:a,numberOfLevelZeroTilesX:1,numberOfLevelZeroTilesY:1,ellipsoid:e.ellipsoid});this._tilingScheme=f,this._resource=t,this._image=void 0,this._texture=void 0,this._tileWidth=0,this._tileHeight=0,this._errorEvent=new c["a"],this._ready=!1,this._readyPromise=Object(s["a"])();let _=e.credit;"string"===typeof _&&(_=new i["a"](_)),this._credit=_;const w=this;let g;function C(e){w._image=e,w._tileWidth=e.width,w._tileHeight=e.height,w._ready=!0,w._readyPromise.resolve(!0),p["a"].handleSuccess(w._errorEvent)}function b(e){const a=`Failed to load image ${t.url}.`;g=p["a"].handleError(g,w,w._errorEvent,a,0,0,0,S,e),g.retry||w._readyPromise.reject(new m["a"](a))}function S(){l["a"].loadImage(null,t).then(C).catch(b)}S()}Object.defineProperties(f.prototype,{url:{get:function(){return this._resource.url}},proxy:{get:function(){return this._resource.proxy}},tileWidth:{get:function(){if(!this._ready)throw new r["a"]("tileWidth must not be called before the imagery provider is ready.");return this._tileWidth}},tileHeight:{get:function(){if(!this._ready)throw new r["a"]("tileHeight must not be called before the imagery provider is ready.");return this._tileHeight}},maximumLevel:{get:function(){if(!this._ready)throw new r["a"]("maximumLevel must not be called before the imagery provider is ready.");return 0}},minimumLevel:{get:function(){if(!this._ready)throw new r["a"]("minimumLevel must not be called before the imagery provider is ready.");return 0}},tilingScheme:{get:function(){if(!this._ready)throw new r["a"]("tilingScheme must not be called before the imagery provider is ready.");return this._tilingScheme}},rectangle:{get:function(){return this._tilingScheme.rectangle}},tileDiscardPolicy:{get:function(){if(!this._ready)throw new r["a"]("tileDiscardPolicy must not be called before the imagery provider is ready.")}},errorEvent:{get:function(){return this._errorEvent}},ready:{get:function(){return this._ready}},readyPromise:{get:function(){return this._readyPromise.promise}},credit:{get:function(){return this._credit}},hasAlphaChannel:{get:function(){return!0}}}),f.prototype.getTileCredits=function(e,t,a){},f.prototype.requestImage=function(e,t,a,i){if(!this._ready)throw new r["a"]("requestImage must not be called before the imagery provider is ready.");if(Object(o["a"])(this._image))return Promise.resolve(this._image)},f.prototype.pickFeatures=function(e,t,a,i,n){},t["a"]=f},"47c8":function(e,t,a){"use strict";var i=a("6af0"),n=a("8656"),s=a("547b"),o=a("85b2"),r=a("dde0"),c=a("6b82"),u=a("8d54"),h=a("44e9"),d=a("4051"),m=a("ed17"),p=a("2fad"),l=a("c76f"),f=a("1a5d"),_=a("c937"),w=a("21b7"),g=a("e2a6"),C=a("8e1f"),b=a("e8ff"),S=a("a61d"),y=a("b8b5"),E=a("722e"),x=a("1345"),O=a("3f87"),v=a("0238"),M=a("1b9c"),A=a("a38f"),P=a("cedf"),T=a("a3c8"),D=a("2341"),L=a("ef87"),N=a("d5cf"),F=a("b18b"),R=a("51f2"),z=a("2992"),I=a("1494"),j=a("932f"),W=a("acf9"),V=a("5027"),U=a("4d68"),B=a("1a75"),H=a("c70c"),Y=a("ddd8"),k=a("2b78"),q=a("1f21"),G=a("5769"),X=a("9bb2");function $(e){e=Object(f["a"])(e,f["a"].EMPTY_OBJECT);const t=e.context;if(!Object(_["a"])(t))throw new g["a"]("context is required.");if(!Object(_["a"])(e.lightCamera))throw new g["a"]("lightCamera is required.");if(Object(_["a"])(e.numberOfCascades)&&1!==e.numberOfCascades&&4!==e.numberOfCascades)throw new g["a"]("Only one or four cascades are supported.");this._enabled=Object(f["a"])(e.enabled,!0),this._softShadows=Object(f["a"])(e.softShadows,!1),this._normalOffset=Object(f["a"])(e.normalOffset,!0),this.dirty=!0,this.fromLightSource=Object(f["a"])(e.fromLightSource,!0),this.darkness=Object(f["a"])(e.darkness,.3),this._darkness=this.darkness,this.fadingEnabled=Object(f["a"])(e.fadingEnabled,!0),this.maximumDistance=Object(f["a"])(e.maximumDistance,5e3),this._outOfView=!1,this._outOfViewPrevious=!1,this._needsUpdate=!0;let a,i=!0;(C["a"].isInternetExplorer()||C["a"].isEdge()||(C["a"].isChrome()||C["a"].isFirefox())&&C["a"].isWindows()&&!t.depthTexture)&&(i=!1),this._polygonOffsetSupported=i,this._terrainBias={polygonOffset:i,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:.5,normalShading:!0,normalShadingSmooth:.3,depthBias:1e-4},this._primitiveBias={polygonOffset:i,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:.1,normalShading:!0,normalShadingSmooth:.05,depthBias:2e-5},this._pointBias={polygonOffset:!1,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:0,normalShading:!0,normalShadingSmooth:.1,depthBias:5e-4},this._depthAttachment=void 0,this._colorAttachment=void 0,this._shadowMapMatrix=new E["a"],this._shadowMapTexture=void 0,this._lightDirectionEC=new r["a"],this._lightPositionEC=new c["a"],this._distance=0,this._lightCamera=e.lightCamera,this._shadowMapCamera=new ge,this._shadowMapCullingVolume=void 0,this._sceneCamera=void 0,this._boundingSphere=new n["a"],this._isPointLight=Object(f["a"])(e.isPointLight,!1),this._pointLightRadius=Object(f["a"])(e.pointLightRadius,100),this._cascadesEnabled=!this._isPointLight&&Object(f["a"])(e.cascadesEnabled,!0),this._numberOfCascades=this._cascadesEnabled?Object(f["a"])(e.numberOfCascades,4):0,this._fitNearFar=!0,this._maximumCascadeDistances=[25,150,700,Number.MAX_VALUE],this._textureSize=new o["a"],this._isSpotLight=!1,this._cascadesEnabled?this._shadowMapCamera.frustum=new x["a"]:Object(_["a"])(this._lightCamera.frustum.fov)&&(this._isSpotLight=!0),this._cascadeSplits=[new c["a"],new c["a"]],this._cascadeMatrices=[new E["a"],new E["a"],new E["a"],new E["a"]],this._cascadeDistances=new c["a"],a=this._isPointLight?6:this._cascadesEnabled?this._numberOfCascades:1,this._passes=new Array(a);for(let n=0;n<a;++n)this._passes[n]=new K(t);this.debugShow=!1,this.debugFreezeFrame=!1,this._debugFreezeFrame=!1,this._debugCascadeColors=!1,this._debugLightFrustum=void 0,this._debugCameraFrustum=void 0,this._debugCascadeFrustums=new Array(this._numberOfCascades),this._debugShadowViewCommand=void 0,this._usesDepthTexture=t.depthTexture,this._isPointLight&&(this._usesDepthTexture=!1),this._primitiveRenderState=void 0,this._terrainRenderState=void 0,this._pointRenderState=void 0,Z(this),this._clearCommand=new T["a"]({depth:1,color:new d["a"]}),this._clearPassState=new z["a"](t),this._size=Object(f["a"])(e.size,2048),this.size=this._size}function K(e){this.camera=new ge,this.passState=new z["a"](e),this.framebuffer=void 0,this.textureOffsets=void 0,this.commandList=[],this.cullingVolume=void 0}function Q(e,t){return V["a"].fromCache({cull:{enabled:!0,face:Y["a"].BACK},depthTest:{enabled:!0},colorMask:{red:e,green:e,blue:e,alpha:e},depthMask:!0,polygonOffset:{enabled:t.polygonOffset,factor:t.polygonOffsetFactor,units:t.polygonOffsetUnits}})}function Z(e){const t=!e._usesDepthTexture;e._primitiveRenderState=Q(t,e._primitiveBias),e._terrainRenderState=Q(t,e._terrainBias),e._pointRenderState=Q(t,e._pointBias)}function J(e){const t=e._passes.length;for(let a=0;a<t;++a){const t=e._passes[a],i=t.framebuffer;Object(_["a"])(i)&&!i.isDestroyed()&&i.destroy(),t.framebuffer=void 0}e._depthAttachment=e._depthAttachment&&e._depthAttachment.destroy(),e._colorAttachment=e._colorAttachment&&e._colorAttachment.destroy()}function ee(e,t){const a=new j["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,format:W["a"].DEPTH_COMPONENT16}),i=new B["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:v["a"].RGBA,pixelDatatype:I["a"].UNSIGNED_BYTE,sampler:U["a"].NEAREST}),n=new F["a"]({context:t,depthRenderbuffer:a,colorTextures:[i],destroyAttachments:!1}),s=e._passes.length;for(let o=0;o<s;++o){const t=e._passes[o];t.framebuffer=n,t.passState.framebuffer=n}e._shadowMapTexture=i,e._depthAttachment=a,e._colorAttachment=i}function te(e,t){const a=new B["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:v["a"].DEPTH_STENCIL,pixelDatatype:I["a"].UNSIGNED_INT_24_8,sampler:U["a"].NEAREST}),i=new F["a"]({context:t,depthStencilTexture:a,destroyAttachments:!1}),n=e._passes.length;for(let s=0;s<n;++s){const t=e._passes[s];t.framebuffer=i,t.passState.framebuffer=i}e._shadowMapTexture=a,e._depthAttachment=a}function ae(e,t){const a=new j["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,format:W["a"].DEPTH_COMPONENT16}),i=new L["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:v["a"].RGBA,pixelDatatype:I["a"].UNSIGNED_BYTE,sampler:U["a"].NEAREST}),n=[i.negativeX,i.negativeY,i.negativeZ,i.positiveX,i.positiveY,i.positiveZ];for(let s=0;s<6;++s){const i=new F["a"]({context:t,depthRenderbuffer:a,colorTextures:[n[s]],destroyAttachments:!1}),o=e._passes[s];o.framebuffer=i,o.passState.framebuffer=i}e._shadowMapTexture=i,e._depthAttachment=a,e._colorAttachment=i}function ie(e,t){e._isPointLight?ae(e,t):e._usesDepthTexture?te(e,t):ee(e,t)}function ne(e,t){e._usesDepthTexture&&e._passes[0].framebuffer.status!==P["a"].FRAMEBUFFER_COMPLETE&&(e._usesDepthTexture=!1,Z(e),J(e),ie(e,t))}function se(e,t){Object(_["a"])(e._passes[0].framebuffer)&&e._shadowMapTexture.width===e._textureSize.x||(J(e),ie(e,t),ne(e,t),oe(e,t))}function oe(e,t,a){a=Object(f["a"])(a,0),(e._isPointLight||0===a)&&(e._clearCommand.framebuffer=e._passes[a].framebuffer,e._clearCommand.execute(t,e._clearPassState))}function re(e,t){e._size=t;const a=e._passes,n=a.length,s=e._textureSize;if(e._isPointLight){t=D["a"].maximumCubeMapSize>=t?t:D["a"].maximumCubeMapSize,s.x=t,s.y=t;const e=new i["a"](0,0,t,t);a[0].passState.viewport=e,a[1].passState.viewport=e,a[2].passState.viewport=e,a[3].passState.viewport=e,a[4].passState.viewport=e,a[5].passState.viewport=e}else 1===n?(t=D["a"].maximumTextureSize>=t?t:D["a"].maximumTextureSize,s.x=t,s.y=t,a[0].passState.viewport=new i["a"](0,0,t,t)):4===n&&(t=D["a"].maximumTextureSize>=2*t?t:D["a"].maximumTextureSize/2,s.x=2*t,s.y=2*t,a[0].passState.viewport=new i["a"](0,0,t,t),a[1].passState.viewport=new i["a"](t,0,t,t),a[2].passState.viewport=new i["a"](0,t,t,t),a[3].passState.viewport=new i["a"](t,t,t,t));e._clearPassState.viewport=new i["a"](0,0,s.x,s.y);for(let i=0;i<n;++i){const e=a[i],t=e.passState.viewport,n=t.x/s.x,o=t.y/s.y,r=t.width/s.x,c=t.height/s.y;e.textureOffsets=new E["a"](r,0,0,n,0,c,0,o,0,0,1,0,0,0,0,1)}}$.MAXIMUM_DISTANCE=2e4,$.prototype.debugCreateRenderStates=function(){Z(this)},Object.defineProperties($.prototype,{enabled:{get:function(){return this._enabled},set:function(e){this.dirty=this._enabled!==e,this._enabled=e}},normalOffset:{get:function(){return this._normalOffset},set:function(e){this.dirty=this._normalOffset!==e,this._normalOffset=e,this._terrainBias.normalOffset=e,this._primitiveBias.normalOffset=e,this._pointBias.normalOffset=e}},softShadows:{get:function(){return this._softShadows},set:function(e){this.dirty=this._softShadows!==e,this._softShadows=e}},size:{get:function(){return this._size},set:function(e){re(this,e)}},outOfView:{get:function(){return this._outOfView}},shadowMapCullingVolume:{get:function(){return this._shadowMapCullingVolume}},passes:{get:function(){return this._passes}},isPointLight:{get:function(){return this._isPointLight}},debugCascadeColors:{get:function(){return this._debugCascadeColors},set:function(e){this.dirty=this._debugCascadeColors!==e,this._debugCascadeColors=e}}});const ce=new i["a"];function ue(e,t){let a;a=e._isPointLight?"uniform samplerCube shadowMap_textureCube; \nvarying vec2 v_textureCoordinates; \nvoid main() \n{ \n    vec2 uv = v_textureCoordinates; \n    vec3 dir; \n \n    if (uv.y < 0.5) \n    { \n        if (uv.x < 0.333) \n        { \n            dir.x = -1.0; \n            dir.y = uv.x * 6.0 - 1.0; \n            dir.z = uv.y * 4.0 - 1.0; \n        } \n        else if (uv.x < 0.666) \n        { \n            dir.y = -1.0; \n            dir.x = uv.x * 6.0 - 3.0; \n            dir.z = uv.y * 4.0 - 1.0; \n        } \n        else \n        { \n            dir.z = -1.0; \n            dir.x = uv.x * 6.0 - 5.0; \n            dir.y = uv.y * 4.0 - 1.0; \n        } \n    } \n    else \n    { \n        if (uv.x < 0.333) \n        { \n            dir.x = 1.0; \n            dir.y = uv.x * 6.0 - 1.0; \n            dir.z = uv.y * 4.0 - 3.0; \n        } \n        else if (uv.x < 0.666) \n        { \n            dir.y = 1.0; \n            dir.x = uv.x * 6.0 - 3.0; \n            dir.z = uv.y * 4.0 - 3.0; \n        } \n        else \n        { \n            dir.z = 1.0; \n            dir.x = uv.x * 6.0 - 5.0; \n            dir.y = uv.y * 4.0 - 3.0; \n        } \n    } \n \n    float shadow = czm_unpackDepth(textureCube(shadowMap_textureCube, dir)); \n    gl_FragColor = vec4(vec3(shadow), 1.0); \n} \n":`uniform sampler2D shadowMap_texture; \nvarying vec2 v_textureCoordinates; \nvoid main() \n{ \n${e._usesDepthTexture?"    float shadow = texture2D(shadowMap_texture, v_textureCoordinates).r; \n":"    float shadow = czm_unpackDepth(texture2D(shadowMap_texture, v_textureCoordinates)); \n"}    gl_FragColor = vec4(vec3(shadow), 1.0); \n} \n`;const i=t.createViewportQuadCommand(a,{uniformMap:{shadowMap_texture:function(){return e._shadowMapTexture},shadowMap_textureCube:function(){return e._shadowMapTexture}}});return i.pass=R["a"].OVERLAY,i}function he(e,t){const a=t.context,n=t.context.drawingBufferWidth,s=t.context.drawingBufferHeight,o=.3*Math.min(n,s),r=ce;r.x=n-o,r.y=0,r.width=o,r.height=o;let c=e._debugShadowViewCommand;Object(_["a"])(c)||(c=ue(e,a),e._debugShadowViewCommand=c),Object(_["a"])(c.renderState)&&i["a"].equals(c.renderState.viewport,r)||(c.renderState=V["a"].fromCache({viewport:i["a"].clone(r)})),t.commandList.push(e._debugShadowViewCommand)}const de=new Array(8);de[0]=new c["a"](-1,-1,-1,1),de[1]=new c["a"](1,-1,-1,1),de[2]=new c["a"](1,1,-1,1),de[3]=new c["a"](-1,1,-1,1),de[4]=new c["a"](-1,-1,1,1),de[5]=new c["a"](1,-1,1,1),de[6]=new c["a"](1,1,1,1),de[7]=new c["a"](-1,1,1,1);const me=new E["a"],pe=new Array(8);for(let Ye=0;Ye<8;++Ye)pe[Ye]=new c["a"];function le(e,t){const a=new b["a"]({geometry:new s["a"]({minimum:new r["a"](-.5,-.5,-.5),maximum:new r["a"](.5,.5,.5)}),attributes:{color:m["a"].fromColor(t)}}),i=new b["a"]({geometry:new A["a"]({radius:.5}),attributes:{color:m["a"].fromColor(t)}});return new G["a"]({geometryInstances:[a,i],appearance:new q["a"]({translucent:!1,flat:!0}),asynchronous:!1,modelMatrix:e})}const fe=[d["a"].RED,d["a"].GREEN,d["a"].BLUE,d["a"].MAGENTA],_e=new r["a"];function we(e,t){he(e,t);const a=e.debugFreezeFrame&&!e._debugFreezeFrame;if(e._debugFreezeFrame=e.debugFreezeFrame,e.debugFreezeFrame&&(a&&(e._debugCameraFrustum=e._debugCameraFrustum&&e._debugCameraFrustum.destroy(),e._debugCameraFrustum=new k["a"]({camera:e._sceneCamera,color:d["a"].CYAN,updateOnChange:!1})),e._debugCameraFrustum.update(t)),e._cascadesEnabled){if(e.debugFreezeFrame){a&&(e._debugLightFrustum=e._debugLightFrustum&&e._debugLightFrustum.destroy(),e._debugLightFrustum=new k["a"]({camera:e._shadowMapCamera,color:d["a"].YELLOW,updateOnChange:!1})),e._debugLightFrustum.update(t);for(let i=0;i<e._numberOfCascades;++i)a&&(e._debugCascadeFrustums[i]=e._debugCascadeFrustums[i]&&e._debugCascadeFrustums[i].destroy(),e._debugCascadeFrustums[i]=new k["a"]({camera:e._passes[i].camera,color:fe[i],updateOnChange:!1})),e._debugCascadeFrustums[i].update(t)}}else if(e._isPointLight){if(!Object(_["a"])(e._debugLightFrustum)||e._needsUpdate){const t=e._shadowMapCamera.positionWC,a=M["a"].IDENTITY,i=2*e._pointLightRadius,n=r["a"].fromElements(i,i,i,_e),s=E["a"].fromTranslationQuaternionRotationScale(t,a,n,me);e._debugLightFrustum=e._debugLightFrustum&&e._debugLightFrustum.destroy(),e._debugLightFrustum=le(s,d["a"].YELLOW)}e._debugLightFrustum.update(t)}else Object(_["a"])(e._debugLightFrustum)&&!e._needsUpdate||(e._debugLightFrustum=new k["a"]({camera:e._shadowMapCamera,color:d["a"].YELLOW,updateOnChange:!1})),e._debugLightFrustum.update(t)}function ge(){this.viewMatrix=new E["a"],this.inverseViewMatrix=new E["a"],this.frustum=void 0,this.positionCartographic=new u["a"],this.positionWC=new r["a"],this.directionWC=r["a"].clone(r["a"].UNIT_Z),this.upWC=r["a"].clone(r["a"].UNIT_Y),this.rightWC=r["a"].clone(r["a"].UNIT_X),this.viewProjectionMatrix=new E["a"]}ge.prototype.clone=function(e){E["a"].clone(e.viewMatrix,this.viewMatrix),E["a"].clone(e.inverseViewMatrix,this.inverseViewMatrix),this.frustum=e.frustum.clone(this.frustum),u["a"].clone(e.positionCartographic,this.positionCartographic),r["a"].clone(e.positionWC,this.positionWC),r["a"].clone(e.directionWC,this.directionWC),r["a"].clone(e.upWC,this.upWC),r["a"].clone(e.rightWC,this.rightWC)};const Ce=new E["a"](.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);ge.prototype.getViewProjection=function(){const e=this.viewMatrix,t=this.frustum.projectionMatrix;return E["a"].multiply(t,e,this.viewProjectionMatrix),E["a"].multiply(Ce,this.viewProjectionMatrix,this.viewProjectionMatrix),this.viewProjectionMatrix};const be=new Array(5),Se=new O["a"],ye=new Array(4),Ee=new r["a"],xe=new r["a"];function Oe(e,t){const a=e._shadowMapCamera,i=e._sceneCamera,n=i.frustum.near,s=i.frustum.far,o=e._numberOfCascades;let u;const h=s-n,d=s/n;let m=.9,p=!1;t.shadowState.closestObjectSize<200&&(p=!0,m=.9);const l=ye,f=be;for(f[0]=n,f[o]=s,u=0;u<o;++u){const e=(u+1)/o,t=n*Math.pow(d,e),a=n+h*e,i=y["a"].lerp(a,t,m);f[u+1]=i,l[u]=i-f[u]}if(p){for(u=0;u<o;++u)l[u]=Math.min(l[u],e._maximumCascadeDistances[u]);let t=f[0];for(u=0;u<o-1;++u)t+=l[u],f[u+1]=t}c["a"].unpack(f,0,e._cascadeSplits[0]),c["a"].unpack(f,1,e._cascadeSplits[1]),c["a"].unpack(l,0,e._cascadeDistances);const _=a.frustum,w=_.left,g=_.right,C=_.bottom,b=_.top,S=_.near,x=_.far,O=a.positionWC,v=a.directionWC,M=a.upWC,A=i.frustum.clone(Se),P=a.getViewProjection();for(u=0;u<o;++u){A.near=f[u],A.far=f[u+1];const t=E["a"].multiply(A.projectionMatrix,i.viewMatrix,me),n=E["a"].inverse(t,me),s=E["a"].multiply(P,n,me),o=r["a"].fromElements(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Ee),h=r["a"].fromElements(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,xe);for(let e=0;e<8;++e){const t=c["a"].clone(de[e],pe[e]);E["a"].multiplyByVector(s,t,t),r["a"].divideByScalar(t,t.w,t),r["a"].minimumByComponent(t,o,o),r["a"].maximumByComponent(t,h,h)}o.x=Math.max(o.x,0),o.y=Math.max(o.y,0),o.z=0,h.x=Math.min(h.x,1),h.y=Math.min(h.y,1),h.z=Math.min(h.z,1);const d=e._passes[u],m=d.camera;m.clone(a);const p=m.frustum;p.left=w+o.x*(g-w),p.right=w+h.x*(g-w),p.bottom=C+o.y*(b-C),p.top=C+h.y*(b-C),p.near=S+o.z*(x-S),p.far=S+h.z*(x-S),d.cullingVolume=m.frustum.computeCullingVolume(O,v,M);const l=e._cascadeMatrices[u];E["a"].multiply(m.getViewProjection(),i.inverseViewMatrix,l),E["a"].multiply(d.textureOffsets,l,l)}}const ve=new E["a"],Me=new r["a"],Ae=new r["a"],Pe=new r["a"];function Te(e,t){const a=e._shadowMapCamera,i=e._sceneCamera,n=E["a"].multiply(i.frustum.projectionMatrix,i.viewMatrix,me),s=E["a"].inverse(n,me),o=a.directionWC;let u=i.directionWC;r["a"].equalsEpsilon(o,u,y["a"].EPSILON10)&&(u=i.upWC);const h=r["a"].cross(o,u,Me);u=r["a"].cross(h,o,Ae),r["a"].normalize(u,u),r["a"].normalize(h,h);const d=r["a"].fromElements(0,0,0,Pe);let m=E["a"].computeView(d,o,u,h,ve);const p=E["a"].multiply(m,s,me),l=r["a"].fromElements(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Ee),f=r["a"].fromElements(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,xe);for(let y=0;y<8;++y){const e=c["a"].clone(de[y],pe[y]);E["a"].multiplyByVector(p,e,e),r["a"].divideByScalar(e,e.w,e),r["a"].minimumByComponent(e,l,l),r["a"].maximumByComponent(e,f,f)}f.z+=1e3,l.z-=10;const _=Pe;_.x=-.5*(l.x+f.x),_.y=-.5*(l.y+f.y),_.z=-f.z;const w=E["a"].fromTranslation(_,me);m=E["a"].multiply(w,m,m);const g=.5*(f.x-l.x),C=.5*(f.y-l.y),b=f.z-l.z,S=a.frustum;S.left=-g,S.right=g,S.bottom=-C,S.top=C,S.near=.01,S.far=b,E["a"].clone(m,a.viewMatrix),E["a"].inverse(m,a.inverseViewMatrix),E["a"].getTranslation(a.inverseViewMatrix,a.positionWC),t.mapProjection.ellipsoid.cartesianToCartographic(a.positionWC,a.positionCartographic),r["a"].clone(o,a.directionWC),r["a"].clone(u,a.upWC),r["a"].clone(h,a.rightWC)}const De=[new r["a"](-1,0,0),new r["a"](0,-1,0),new r["a"](0,0,-1),new r["a"](1,0,0),new r["a"](0,1,0),new r["a"](0,0,1)],Le=[new r["a"](0,-1,0),new r["a"](0,0,-1),new r["a"](0,-1,0),new r["a"](0,-1,0),new r["a"](0,0,1),new r["a"](0,-1,0)],Ne=[new r["a"](0,0,1),new r["a"](1,0,0),new r["a"](-1,0,0),new r["a"](0,0,-1),new r["a"](1,0,0),new r["a"](1,0,0)];function Fe(e,t){const a=new O["a"];a.fov=y["a"].PI_OVER_TWO,a.near=1,a.far=e._pointLightRadius,a.aspectRatio=1;for(let i=0;i<6;++i){const n=e._passes[i].camera;n.positionWC=e._shadowMapCamera.positionWC,n.positionCartographic=t.mapProjection.ellipsoid.cartesianToCartographic(n.positionWC,n.positionCartographic),n.directionWC=De[i],n.upWC=Le[i],n.rightWC=Ne[i],E["a"].computeView(n.positionWC,n.directionWC,n.upWC,n.rightWC,n.viewMatrix),E["a"].inverse(n.viewMatrix,n.inverseViewMatrix),n.frustum=a}}const Re=new r["a"],ze=new r["a"],Ie=new n["a"],je=Ie.center;function We(e,t){const a=e._sceneCamera,i=e._shadowMapCamera,s=Ie;if(e._cascadesEnabled){if(a.frustum.near>=e.maximumDistance)return e._outOfView=!0,void(e._needsUpdate=!1);const n=t.mapProjection.ellipsoid.geodeticSurfaceNormal(a.positionWC,Re),s=r["a"].negate(i.directionWC,ze),o=r["a"].dot(n,s);if(e.fadingEnabled){const t=y["a"].clamp(o/.1,0,1);e._darkness=y["a"].lerp(1,e.darkness,t)}else e._darkness=e.darkness;if(o<0)return e._outOfView=!0,void(e._needsUpdate=!1);e._needsUpdate=!0,e._outOfView=!1}else if(e._isPointLight)s.center=i.positionWC,s.radius=e._pointLightRadius,e._outOfView=t.cullingVolume.computeVisibility(s)===S["a"].OUTSIDE,e._needsUpdate=!e._outOfView&&!e._boundingSphere.equals(s),n["a"].clone(s,e._boundingSphere);else{const a=i.frustum.far/2,o=r["a"].add(i.positionWC,r["a"].multiplyByScalar(i.directionWC,a,je),je);s.center=o,s.radius=a,e._outOfView=t.cullingVolume.computeVisibility(s)===S["a"].OUTSIDE,e._needsUpdate=!e._outOfView&&!e._boundingSphere.equals(s),n["a"].clone(s,e._boundingSphere)}}function Ve(e,t){const a=t.camera,i=e._lightCamera,n=e._sceneCamera,s=e._shadowMapCamera;e._cascadesEnabled?r["a"].clone(i.directionWC,s.directionWC):e._isPointLight?r["a"].clone(i.positionWC,s.positionWC):s.clone(i);const o=e._lightDirectionEC;let c,u;E["a"].multiplyByPointAsVector(a.viewMatrix,s.directionWC,o),r["a"].normalize(o,o),r["a"].negate(o,o),E["a"].multiplyByPoint(a.viewMatrix,s.positionWC,e._lightPositionEC),e._lightPositionEC.w=e._pointLightRadius,e._fitNearFar?(c=Math.min(t.shadowState.nearPlane,e.maximumDistance),u=Math.min(t.shadowState.farPlane,e.maximumDistance),u=Math.max(u,c+1)):(c=a.frustum.near,u=e.maximumDistance),e._sceneCamera=H["a"].clone(a,n),a.frustum.clone(e._sceneCamera.frustum),e._sceneCamera.frustum.near=c,e._sceneCamera.frustum.far=u,e._distance=u-c,We(e,t),!e._outOfViewPrevious&&e._outOfView&&(e._needsUpdate=!0),e._outOfViewPrevious=e._outOfView}$.prototype.update=function(e){if(Ve(this,e),this._needsUpdate)if(se(this,e.context),this._isPointLight&&Fe(this,e),this._cascadesEnabled&&(Te(this,e),this._numberOfCascades>1&&Oe(this,e)),this._isPointLight)this._shadowMapCullingVolume=l["a"].fromBoundingSphere(this._boundingSphere);else{const e=this._shadowMapCamera,t=e.positionWC,a=e.directionWC,i=e.upWC;this._shadowMapCullingVolume=e.frustum.computeCullingVolume(t,a,i),1===this._passes.length&&this._passes[0].camera.clone(e)}if(1===this._passes.length){const e=this._sceneCamera.inverseViewMatrix;E["a"].multiply(this._shadowMapCamera.getViewProjection(),e,this._shadowMapMatrix)}this.debugShow&&we(this,e)},$.prototype.updatePass=function(e,t){oe(this,e,t)};const Ue=new o["a"];function Be(e,t,a){const i=e._isPointLight?e._pointBias:a?e._terrainBias:e._primitiveBias,n={shadowMap_texture:function(){return e._shadowMapTexture},shadowMap_textureCube:function(){return e._shadowMapTexture},shadowMap_matrix:function(){return e._shadowMapMatrix},shadowMap_cascadeSplits:function(){return e._cascadeSplits},shadowMap_cascadeMatrices:function(){return e._cascadeMatrices},shadowMap_lightDirectionEC:function(){return e._lightDirectionEC},shadowMap_lightPositionEC:function(){return e._lightPositionEC},shadowMap_cascadeDistances:function(){return e._cascadeDistances},shadowMap_texelSizeDepthBiasAndNormalShadingSmooth:function(){const t=Ue;return t.x=1/e._textureSize.x,t.y=1/e._textureSize.y,c["a"].fromElements(t.x,t.y,i.depthBias,i.normalShadingSmooth,this.combinedUniforms1)},shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness:function(){return c["a"].fromElements(i.normalOffsetScale,e._distance,e.maximumDistance,e._darkness,this.combinedUniforms2)},combinedUniforms1:new c["a"],combinedUniforms2:new c["a"]};return Object(p["a"])(t,n,!1)}function He(e,t,a,i,n,s){let o,r,c;if(Object(_["a"])(s)&&(o=s.shaderProgram,r=s.renderState,c=s.uniformMap),s=N["a"].shallowClone(a,s),s.castShadows=!0,s.receiveShadows=!1,!Object(_["a"])(o)||n!==a.shaderProgram.id||t){const t=a.shaderProgram,n=a.pass===R["a"].GLOBE,s=a.pass!==R["a"].TRANSLUCENT,u=e._isPointLight,d=e._usesDepthTexture,m=X["a"].getShadowCastShaderKeyword(u,n,d,s);if(o=i.shaderCache.getDerivedShaderProgram(t,m),!Object(_["a"])(o)){const e=t.vertexShaderSource,a=t.fragmentShaderSource,r=X["a"].createShadowCastVertexShader(e,u,n),c=X["a"].createShadowCastFragmentShader(a,u,d,s);o=i.shaderCache.createDerivedShaderProgram(t,m,{vertexShaderSource:r,fragmentShaderSource:c,attributeLocations:t._attributeLocations})}r=e._primitiveRenderState,u?r=e._pointRenderState:n&&(r=e._terrainRenderState);const p=a.renderState.cull.enabled;p||(r=Object(h["a"])(r,!1),r.cull=Object(h["a"])(r.cull,!1),r.cull.enabled=!1,r=V["a"].fromCache(r)),c=Be(e,a.uniformMap,n)}return s.shaderProgram=o,s.renderState=r,s.uniformMap=c,s}$.createReceiveDerivedCommand=function(e,t,a,i,n){Object(_["a"])(n)||(n={});const s=e.length>0,o=t.shaderProgram,r=o.vertexShaderSource,c=o.fragmentShaderSource,u=t.pass===R["a"].GLOBE;let h=!1;if(u&&(h=t.owner.data.renderedMesh.encoding.hasVertexNormals),t.receiveShadows&&s){let s,d;Object(_["a"])(n.receiveCommand)&&(s=n.receiveCommand.shaderProgram,d=n.receiveCommand.uniformMap),n.receiveCommand=N["a"].shallowClone(t,n.receiveCommand),n.castShadows=!1,n.receiveShadows=!0;const m=n.receiveShaderCastShadows!==t.castShadows,p=n.receiveShaderProgramId!==t.shaderProgram.id;if(!Object(_["a"])(s)||p||a||m){const a=X["a"].getShadowReceiveShaderKeyword(e[0],t.castShadows,u,h);if(s=i.shaderCache.getDerivedShaderProgram(o,a),!Object(_["a"])(s)){const n=X["a"].createShadowReceiveVertexShader(r,u,h),d=X["a"].createShadowReceiveFragmentShader(c,e[0],t.castShadows,u,h);s=i.shaderCache.createDerivedShaderProgram(o,a,{vertexShaderSource:n,fragmentShaderSource:d,attributeLocations:o._attributeLocations})}d=Be(e[0],t.uniformMap,u)}n.receiveCommand.shaderProgram=s,n.receiveCommand.uniformMap=d,n.receiveShaderProgramId=t.shaderProgram.id,n.receiveShaderCastShadows=t.castShadows}return n},$.createCastDerivedCommand=function(e,t,a,i,n){if(Object(_["a"])(n)||(n={}),t.castShadows){let s=n.castCommands;Object(_["a"])(s)||(s=n.castCommands=[]);const o=n.castShaderProgramId,r=e.length;s.length=r;for(let n=0;n<r;++n)s[n]=He(e[n],a,t,i,o,s[n]);n.castShaderProgramId=t.shaderProgram.id}return n},$.prototype.isDestroyed=function(){return!1},$.prototype.destroy=function(){J(this),this._debugLightFrustum=this._debugLightFrustum&&this._debugLightFrustum.destroy(),this._debugCameraFrustum=this._debugCameraFrustum&&this._debugCameraFrustum.destroy(),this._debugShadowViewCommand=this._debugShadowViewCommand&&this._debugShadowViewCommand.shaderProgram&&this._debugShadowViewCommand.shaderProgram.destroy();for(let e=0;e<this._numberOfCascades;++e)this._debugCascadeFrustums[e]=this._debugCascadeFrustums[e]&&this._debugCascadeFrustums[e].destroy();return Object(w["a"])(this)},t["a"]=$},"4c8c":function(e,t,a){"use strict";var i=a("dde0"),n=a("ae9b"),s=a("1a5d"),o=a("b8b5");function r(e){e=Object(s["a"])(e,1),n["a"].typeOf.number.greaterThan("radius",e,0),this._radius=Object(s["a"])(e,1)}Object.defineProperties(r.prototype,{radius:{get:function(){return this._radius},set:function(e){n["a"].typeOf.number.greaterThan("value",e,0),this._radius=e}}}),r.prototype.emit=function(e){const t=o["a"].randomBetween(0,o["a"].TWO_PI),a=o["a"].randomBetween(0,o["a"].PI),n=o["a"].randomBetween(0,this._radius),s=n*Math.cos(t)*Math.sin(a),r=n*Math.sin(t)*Math.sin(a),c=n*Math.cos(a);e.position=i["a"].fromElements(s,r,c,e.position),e.velocity=i["a"].normalize(e.position,e.velocity)}},"4d91":function(e,t,a){"use strict";var i=a("b3ce");const n={modifyFragmentShader:function(e){return e=i["a"].replaceMain(e,"czm_splitter_main"),e+="uniform float czm_splitDirection; \nvoid main() \n{ \n#ifndef SHADOW_MAP\n    if (czm_splitDirection < 0.0 && gl_FragCoord.x > czm_splitPosition) discard; \n    if (czm_splitDirection > 0.0 && gl_FragCoord.x < czm_splitPosition) discard; \n#endif\n    czm_splitter_main(); \n} \n",e},addUniforms:function(e,t){t.czm_splitDirection=function(){return e.splitDirection}}};t["a"]=n},"66a6":function(e,t,a){"use strict";const i={LEFT:-1,NONE:0,RIGHT:1};t["a"]=Object.freeze(i)},"73b9":function(e,t,a){"use strict";var i=a("dde0"),n=a("1a5d"),s=a("c937"),o=a("21b7"),r=a("e107"),c=a("2459"),u=a("f6fe"),h=a("b8b5"),d=a("722e"),m=a("514d"),p=a("6ba7"),l=a("d5cf"),f=a("5027"),_=a("8f7d"),w=a("b3ce"),g=a("dc15"),C=a("0fa2"),b=a("f2f9"),S=a("2e1c"),y=a("77df"),E=a("da23"),x=a("ddd8"),O=a("dc6c");function v(e){e=Object(n["a"])(e,r["a"].WGS84),this.show=!0,this.perFragmentAtmosphere=!1,this._ellipsoid=e;const t=1.025,a=i["a"].multiplyByScalar(e.radii,t,new i["a"]);this._scaleMatrix=d["a"].fromScale(a),this._modelMatrix=new d["a"],this._command=new l["a"]({owner:this,modelMatrix:this._modelMatrix}),this._spSkyFromSpace=void 0,this._spSkyFromAtmosphere=void 0,this._flags=void 0,this.hueShift=0,this.saturationShift=0,this.brightnessShift=0,this._hueSaturationBrightness=new i["a"];const s=new i["a"];s.x=e.maximumRadius*t,s.y=e.maximumRadius,s.z=0,this._radiiAndDynamicAtmosphereColor=s;const o=this;this._command.uniformMap={u_radiiAndDynamicAtmosphereColor:function(){return o._radiiAndDynamicAtmosphereColor},u_hsbShift:function(){return o._hueSaturationBrightness.x=o.hueShift,o._hueSaturationBrightness.y=o.saturationShift,o._hueSaturationBrightness.z=o.brightnessShift,o._hueSaturationBrightness}}}Object.defineProperties(v.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}}),v.prototype.setDynamicAtmosphereColor=function(e,t){const a=e?t?2:1:0;this._radiiAndDynamicAtmosphereColor.z=a};const M=new d["a"];function A(e){return!(h["a"].equalsEpsilon(e.hueShift,0,h["a"].EPSILON7)&&h["a"].equalsEpsilon(e.saturationShift,0,h["a"].EPSILON7)&&h["a"].equalsEpsilon(e.brightnessShift,0,h["a"].EPSILON7))}v.prototype.update=function(e,t){if(!this.show)return;const a=e.mode;if(a!==O["a"].SCENE3D&&a!==O["a"].MORPHING)return;if(!e.passes.render)return;const n=d["a"].fromRotationTranslation(e.context.uniformState.inverseViewRotation,i["a"].ZERO,M),o=d["a"].multiplyTransformation(n,y["a"].Y_UP_TO_Z_UP,M),r=d["a"].multiply(this._scaleMatrix,o,M);d["a"].clone(r,this._modelMatrix);const h=e.context,l=A(this),v=e.globeTranslucencyState.translucent,P=this.perFragmentAtmosphere||v||!Object(s["a"])(t)||!t.show,T=this._command;if(!Object(s["a"])(T.vertexArray)){const e=c["a"].createGeometry(new c["a"]({radii:new i["a"](1,1,1),slicePartitions:256,stackPartitions:256,vertexFormat:m["a"].POSITION_ONLY}));T.vertexArray=g["a"].fromGeometry({context:h,geometry:e,attributeLocations:u["a"].createAttributeLocations(e),bufferUsage:p["a"].STATIC_DRAW}),T.renderState=f["a"].fromCache({cull:{enabled:!0,face:x["a"].FRONT},blending:E["a"].ALPHA_BLEND,depthMask:!1})}const D=l|P<<2|v<<3;if(D!==this._flags){this._flags=D;const e=[];l&&e.push("COLOR_CORRECT"),P&&e.push("PER_FRAGMENT_ATMOSPHERE"),v&&e.push("GLOBE_TRANSLUCENT");let t=new w["a"]({defines:e.concat("SKY_FROM_SPACE"),sources:[C["a"],S["a"]]}),a=new w["a"]({defines:e.concat("SKY_FROM_SPACE"),sources:[C["a"],b["a"]]});this._spSkyFromSpace=_["a"].fromCache({context:h,vertexShaderSource:t,fragmentShaderSource:a}),t=new w["a"]({defines:e.concat("SKY_FROM_ATMOSPHERE"),sources:[C["a"],S["a"]]}),a=new w["a"]({defines:e.concat("SKY_FROM_ATMOSPHERE"),sources:[C["a"],b["a"]]}),this._spSkyFromAtmosphere=_["a"].fromCache({context:h,vertexShaderSource:t,fragmentShaderSource:a})}const L=e.camera.positionWC,N=i["a"].magnitude(L);return N>this._radiiAndDynamicAtmosphereColor.x?T.shaderProgram=this._spSkyFromSpace:T.shaderProgram=this._spSkyFromAtmosphere,T},v.prototype.isDestroyed=function(){return!1},v.prototype.destroy=function(){const e=this._command;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),this._spSkyFromSpace=this._spSkyFromSpace&&this._spSkyFromSpace.destroy(),this._spSkyFromAtmosphere=this._spSkyFromAtmosphere&&this._spSkyFromAtmosphere.destroy(),Object(o["a"])(this)},t["a"]=v},"79a2":function(e,t,a){"use strict";var i=a("cedf");const n={NEVER:i["a"].NEVER,LESS:i["a"].LESS,EQUAL:i["a"].EQUAL,LESS_OR_EQUAL:i["a"].LEQUAL,GREATER:i["a"].GREATER,NOT_EQUAL:i["a"].NOTEQUAL,GREATER_OR_EQUAL:i["a"].GEQUAL,ALWAYS:i["a"].ALWAYS};t["a"]=Object.freeze(n)},"8d2f":function(e,t,a){"use strict";var i=a("79a2"),n=a("20f8");const s={CESIUM_3D_TILE_MASK:128,SKIP_LOD_MASK:112,SKIP_LOD_BIT_SHIFT:4,CLASSIFICATION_MASK:15,setCesium3DTileBit:function(){return{enabled:!0,frontFunction:i["a"].ALWAYS,frontOperation:{fail:n["a"].KEEP,zFail:n["a"].KEEP,zPass:n["a"].REPLACE},backFunction:i["a"].ALWAYS,backOperation:{fail:n["a"].KEEP,zFail:n["a"].KEEP,zPass:n["a"].REPLACE},reference:s.CESIUM_3D_TILE_MASK,mask:s.CESIUM_3D_TILE_MASK}}};t["a"]=Object.freeze(s)},"9bb2":function(e,t,a){"use strict";var i=a("c937"),n=a("b3ce");function s(){}s.getShadowCastShaderKeyword=function(e,t,a,i){return`castShadow ${e} ${t} ${a} ${i}`},s.createShadowCastVertexShader=function(e,t,a){const s=e.defines.slice(0),o=e.sources.slice(0);s.push("SHADOW_MAP"),a&&s.push("GENERATE_POSITION");const r=n["a"].findPositionVarying(e),c=Object(i["a"])(r);if(t&&!c){const e=o.length;for(let a=0;a<e;++a)o[a]=n["a"].replaceMain(o[a],"czm_shadow_cast_main");const t="varying vec3 v_positionEC; \nvoid main() \n{ \n    czm_shadow_cast_main(); \n    v_positionEC = (czm_inverseProjection * gl_Position).xyz; \n}";o.push(t)}return new n["a"]({defines:s,sources:o})},s.createShadowCastFragmentShader=function(e,t,a,s){const o=e.defines.slice(0),r=e.sources.slice(0);o.push("SHADOW_MAP");let c=n["a"].findPositionVarying(e);const u=Object(i["a"])(c);u||(c="v_positionEC");const h=r.length;for(let i=0;i<h;++i)r[i]=n["a"].replaceMain(r[i],"czm_shadow_cast_main");let d="";return t&&(u||(d+="varying vec3 v_positionEC; \n"),d+="uniform vec4 shadowMap_lightPositionEC; \n"),d+=s?"void main() \n{ \n":"void main() \n{ \n    czm_shadow_cast_main(); \n    if (gl_FragColor.a == 0.0) \n    { \n       discard; \n    } \n",d+=t?`    float distance = length(${c}); \n    if (distance >= shadowMap_lightPositionEC.w) \n    { \n        discard; \n    } \n    distance /= shadowMap_lightPositionEC.w; // radius \n    gl_FragColor = czm_packDepth(distance); \n`:a?"    gl_FragColor = vec4(1.0); \n":"    gl_FragColor = czm_packDepth(gl_FragCoord.z); \n",d+="} \n",r.push(d),new n["a"]({defines:o,sources:r})},s.getShadowReceiveShaderKeyword=function(e,t,a,i){const n=e._usesDepthTexture,s=e._polygonOffsetSupported,o=e._isPointLight,r=e._isSpotLight,c=e._numberOfCascades>1,u=e.debugCascadeColors,h=e.softShadows;return`receiveShadow ${n}${s}${o}${r}${c}${u}${h}${t}${a}${i}`},s.createShadowReceiveVertexShader=function(e,t,a){const i=e.defines.slice(0),s=e.sources.slice(0);return i.push("SHADOW_MAP"),t&&(a?i.push("GENERATE_POSITION_AND_NORMAL"):i.push("GENERATE_POSITION")),new n["a"]({defines:i,sources:s})},s.createShadowReceiveFragmentShader=function(e,t,a,s,o){const r=n["a"].findNormalVarying(e),c=!s&&Object(i["a"])(r)||s&&o,u=n["a"].findPositionVarying(e),h=Object(i["a"])(u),d=t._usesDepthTexture,m=t._polygonOffsetSupported,p=t._isPointLight,l=t._isSpotLight,f=t._numberOfCascades>1,_=t.debugCascadeColors,w=t.softShadows,g=p?t._pointBias:s?t._terrainBias:t._primitiveBias,C=e.defines.slice(0),b=e.sources.slice(0),S=b.length;for(let i=0;i<S;++i)b[i]=n["a"].replaceMain(b[i],"czm_shadow_receive_main");p?C.push("USE_CUBE_MAP_SHADOW"):d&&C.push("USE_SHADOW_DEPTH_TEXTURE"),w&&!p&&C.push("USE_SOFT_SHADOWS"),f&&a&&s&&(c?C.push("ENABLE_VERTEX_LIGHTING"):C.push("ENABLE_DAYNIGHT_SHADING")),a&&g.normalShading&&c&&(C.push("USE_NORMAL_SHADING"),g.normalShadingSmooth>0&&C.push("USE_NORMAL_SHADING_SMOOTH"));let y,E="";return E+=p?"uniform samplerCube shadowMap_textureCube; \n":"uniform sampler2D shadowMap_texture; \n",y=h?`    return vec4(${u}, 1.0); \n`:"#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n",E+=`uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n${y}} \nvec3 getNormalEC() \n{ \n${c?`    return normalize(${r}); \n`:"    return vec3(1.0); \n"}} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n${g.normalOffset&&c?"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n":""}} \n`,E+="void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n",E+="    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n",s?E+="    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n":m||(E+="    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n"),E+=p?"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n":l?"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n":f?"    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n"+(_?"    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n":""):"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n",E+="    gl_FragColor.rgb *= visibility; \n} \n",b.push(E),new n["a"]({defines:C,sources:b})},t["a"]=s},dbb4:function(e,t,a){"use strict";var i=a("90c5"),n=a("dde0"),s=a("1a5d"),o=a("c937"),r=a("21b7"),c=a("e2a6"),u=a("f6fe"),h=a("722e"),d=a("514d"),m=a("6ba7"),p=a("ef87"),l=a("d5cf"),f=a("28ea"),_=a("5027"),w=a("8f7d"),g=a("b3ce"),C=a("dc15"),b=a("d691"),S=a("55d7"),y=a("da23"),E=a("dc6c");function x(e){this.sources=e.sources,this._sources=void 0,this.show=Object(s["a"])(e.show,!0),this._command=new l["a"]({modelMatrix:h["a"].clone(h["a"].IDENTITY),owner:this}),this._cubeMap=void 0,this._attributeLocations=void 0,this._useHdr=void 0}x.prototype.update=function(e,t){const a=this;if(!this.show)return;if(e.mode!==E["a"].SCENE3D&&e.mode!==E["a"].MORPHING)return;if(!e.passes.render)return;const s=e.context;if(this._sources!==this.sources){this._sources=this.sources;const e=this.sources;if(!Object(o["a"])(e.positiveX)||!Object(o["a"])(e.negativeX)||!Object(o["a"])(e.positiveY)||!Object(o["a"])(e.negativeY)||!Object(o["a"])(e.positiveZ)||!Object(o["a"])(e.negativeZ))throw new c["a"]("this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.");if(typeof e.positiveX!==typeof e.negativeX||typeof e.positiveX!==typeof e.positiveY||typeof e.positiveX!==typeof e.negativeY||typeof e.positiveX!==typeof e.positiveZ||typeof e.positiveX!==typeof e.negativeZ)throw new c["a"]("this.sources properties must all be the same type.");"string"===typeof e.positiveX?Object(f["a"])(s,this._sources).then((function(e){a._cubeMap=a._cubeMap&&a._cubeMap.destroy(),a._cubeMap=e})):(this._cubeMap=this._cubeMap&&this._cubeMap.destroy(),this._cubeMap=new p["a"]({context:s,source:e}))}const r=this._command;if(!Object(o["a"])(r.vertexArray)){r.uniformMap={u_cubeMap:function(){return a._cubeMap}};const e=i["a"].createGeometry(i["a"].fromDimensions({dimensions:new n["a"](2,2,2),vertexFormat:d["a"].POSITION_ONLY})),t=this._attributeLocations=u["a"].createAttributeLocations(e);r.vertexArray=C["a"].fromGeometry({context:s,geometry:e,attributeLocations:t,bufferUsage:m["a"].STATIC_DRAW}),r.renderState=_["a"].fromCache({blending:y["a"].ALPHA_BLEND})}if(!Object(o["a"])(r.shaderProgram)||this._useHdr!==t){const e=new g["a"]({defines:[t?"HDR":""],sources:[b["a"]]});r.shaderProgram=w["a"].fromCache({context:s,vertexShaderSource:S["a"],fragmentShaderSource:e,attributeLocations:this._attributeLocations}),this._useHdr=t}return Object(o["a"])(this._cubeMap)?r:void 0},x.prototype.isDestroyed=function(){return!1},x.prototype.destroy=function(){const e=this._command;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),e.shaderProgram=e.shaderProgram&&e.shaderProgram.destroy(),this._cubeMap=this._cubeMap&&this._cubeMap.destroy(),Object(r["a"])(this)},t["a"]=x},ff3a:function(e,t,a){"use strict";const i={DISABLED:0,ENABLED:1,CAST_ONLY:2,RECEIVE_ONLY:3,NUMBER_OF_SHADOW_MODES:4,castShadows:function(e){return e===i.ENABLED||e===i.CAST_ONLY},receiveShadows:function(e){return e===i.ENABLED||e===i.RECEIVE_ONLY},fromCastReceive:function(e,t){return e&&t?i.ENABLED:e?i.CAST_ONLY:t?i.RECEIVE_ONLY:i.DISABLED}};t["a"]=Object.freeze(i)}}]);